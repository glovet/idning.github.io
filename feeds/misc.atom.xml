<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>ning</title><link href="/" rel="alternate"></link><link href="http://idning.github.io/feeds/misc.atom.xml" rel="self"></link><id>/</id><updated>2014-10-14T18:53:04+08:00</updated><entry><title>我们应该检查malloc的返回值么?</title><link href="/should-we-check-malloc.html" rel="alternate"></link><updated>2014-10-14T18:53:04+08:00</updated><author><name>ning</name></author><id>tag:,2014-10-14:should-we-check-malloc.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;我们想要什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;现有程序做法&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mysql" id="id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis" id="id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nginx" id="id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lighttpd" id="id10"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;lighttpd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#twemproxy" id="id11"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id13"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;我们经常纠结这种代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
some_small_struct *ptr=(some_small_struct *) malloc(sizeof(some_small_struct));
ptr-&amp;gt;some_member= ...;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;正方: 检查有用:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如果不检查, 没内存时会出现非预期行为.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;反方: 检查没用:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;因为这是一个小程序, 基本不可能超内存, 我们还需要检查malloc是否成功么?&lt;/li&gt;
&lt;li&gt;linux 上, 如果打开了 &lt;tt class="docutils literal"&gt;overcommit&lt;/tt&gt;, 基本上所有的alloc都会返回说有内存,
等到真正写到这片的时候才可能通过oom-killer 杀掉某个(也许是其它)进程.&lt;/li&gt;
&lt;li&gt;linux上, 如果打开了部分swap, alloc通常也会返回有内存,&lt;/li&gt;
&lt;li&gt;就算我们检查, 我们也不能避免栈空间不够之类的错误.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overcommit参考 man malloc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://linux.die.net/man/3/malloc

By default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. This is a really bad bug. In case it turns out that the system is out of memory, one or more processes will be killed by the infamous OOM killer.
&lt;/pre&gt;
&lt;p&gt;但是这时候malloc也是可能返回NULL的, 比如 address space is full.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;我们想要什么&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们的期望分成4级:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 程序依然能够正常工作, 比如http服务器能拒绝掉部分请求而保证另一部分请求正常.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 优雅退出, 防止:
- 因为文件未关闭造成数据丢失   (如果我们写了文件, 未关闭, 操作系统会保证sync到磁盘么  -- 应该是不能保证)
- socket未关闭导致对端长等待.
- 比如是一个文件编辑器, 需要保存用户的工作先.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 通过ASSERT显示core掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;发生非预期异常(可能core).&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如alloc了一个NULL, 但是不是alloc的时候报错, 而是往里面写东西的时候报错, 就很难追查了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很显然, 1是最好的情况, 是一个有尊严的程序员所期望的, 4是一定不能发生的. 2,3是需要权衡的.&lt;/p&gt;
&lt;p&gt;3 是基线, 做到3可能保证出错时知道原因.&lt;/p&gt;
&lt;p&gt;其它:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对嵌入式系统: 内存有限, 所以应该总是检查&lt;/li&gt;
&lt;li&gt;对c++: 尽量使用new, 这样有exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;现有程序做法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们看看一些有名程序的做法&lt;/p&gt;
&lt;div class="section" id="mysql"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;多数地方都做到1:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
HP_INFO *heap_open_from_share(HP_SHARE *share, int mode)
{
  HP_INFO *info;
  DBUG_ENTER(&amp;quot;heap_open_from_share&amp;quot;);

  if (!(info= (HP_INFO*) my_malloc((uint) sizeof(HP_INFO) +
                  2 * share-&amp;gt;max_key_length,
                  MYF(MY_ZEROFILL))))
  {
    DBUG_RETURN(0);
  }
&lt;/pre&gt;
&lt;p&gt;有的地方只能做到4:&lt;/p&gt;
&lt;p&gt;storage/innobase/handler/ha_innodb.cc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
    field_lengths = (ulint*) my_malloc(sizeof(ulint) * n_fields,
            MYF(MY_FAE));

    namebuf = (char*) my_malloc((uint) len + 2, MYF(0));
    memcpy(namebuf, ptr, len);

innobase_rename_table(
    ...
    norm_to = (char*) my_malloc(strlen(to) + 64, MYF(0));
    norm_from = (char*) my_malloc(strlen(from) + 64, MYF(0));
&lt;/pre&gt;
&lt;p&gt;storage/myisam/myisampack.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static my_bool open_isam_files(PACK_MRG_INFO *mrg, char **names, uint count)
{
  mrg-&amp;gt;file=(MI_INFO**) my_malloc(sizeof(MI_INFO*)*count,MYF(MY_FAE));
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="redis"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;做到3:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
    block = zmalloc(sizeof(*block));
    block-&amp;gt;free = AOF_RW_BUF_BLOCK_SIZE;
&lt;/pre&gt;
&lt;p&gt;不过在zmalloc里面做到了assert:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void zmalloc_default_oom(size_t size) {
    fprintf(stderr, &amp;quot;zmalloc: Out of memory trying to allocate %zu bytes\n&amp;quot;,
        size);
    fflush(stderr);
    abort();
}

static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;

void *zmalloc(size_t size) {
    void *ptr = malloc(size+PREFIX_SIZE);

    if (!ptr) zmalloc_oom_handler(size);
&lt;/pre&gt;
&lt;p&gt;但是在cli等不重要代码里面做到4:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void cliInitHelp() {
    tmp.argv = malloc(sizeof(sds));
    tmp.argv[0] = sdscatprintf(sdsempty(),&amp;quot;&amp;#64;%s&amp;quot;,commandGroups[i]);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;alloc 里面打日志, 不是ASSERT (不过ngx_log_error里面应该还会malloc):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void *
ngx_alloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = malloc(size);
    if (p == NULL) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      &amp;quot;malloc(%uz) failed&amp;quot;, size);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, &amp;quot;malloc: %p:%uz&amp;quot;, p, size);

    return p;
}
&lt;/pre&gt;
&lt;p&gt;使用时检查(90%的地方都有检查):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
env = ngx_palloc(cycle-&amp;gt;pool, (n + 1) * sizeof(char *));
if (env == NULL) {
    return NULL;
}

overflow_list = ngx_alloc(sizeof(struct pollfd) * rtscf-&amp;gt;overflow_events,
                          cycle-&amp;gt;log);
if (overflow_list == NULL) {
    return NGX_ERROR;
}
&lt;/pre&gt;
&lt;p&gt;也有不检查:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)
    var = ngx_alloc(sizeof(NGINX_VAR)
                    + cycle-&amp;gt;listening.nelts * (NGX_INT32_LEN + 1) + 2,
                    cycle-&amp;gt;log);

    p = ngx_cpymem(var, NGINX_VAR &amp;quot;=&amp;quot;, sizeof(NGINX_VAR));
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="lighttpd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;lighttpd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ASSERT&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="twemproxy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;和nginx一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void *
_nc_alloc(size_t size, const char *name, int line)
{
    void *p;

    ASSERT(size != 0);

    p = malloc(size);
    if (p == NULL) {
        log_error(&amp;quot;malloc(%zu) failed &amp;#64; %s:%d&amp;quot;, size, name, line);
    } else {
        log_verb(&amp;quot;malloc(%zu) at %p &amp;#64; %s:%d&amp;quot;, size, p, name, line);
    }

    return p;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;nginx 和mysql, redis 做的差不多, 尽量检查.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;推荐的做法:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;alloc里面如果有NULL打日志, 上层每次检查, 发现NULL处理错误&lt;/li&gt;
&lt;li&gt;对小的alloc, alloc 后写ASSERT.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;讨论: &lt;a class="reference external" href="http://stackoverflow.com/questions/1941323/always-check-malloced-memory"&gt;http://stackoverflow.com/questions/1941323/always-check-malloced-memory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>我们还需要80列的限制么</title><link href="/do_we_need_80_column_rule.html" rel="alternate"></link><updated>2014-07-21T13:02:07+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-21:do_we_need_80_column_rule.html</id><summary type="html">&lt;p&gt;现在, 我们写代码通常不限制80列. 现在我们的屏幕都很宽, 一般都能放180列到200列. 所以貌似没必要限制80列了&lt;/p&gt;
&lt;p&gt;但是, 我们经常用diff工具来查看代码, 这样超过80列的代码在diff工具中就不好看了.&lt;/p&gt;
&lt;p&gt;所以, 我们还是坚持80列原则把.&lt;/p&gt;
</summary><category term="all"></category></entry><entry><title>Understanding the Linux Kernel(notes)</title><link href="/ulk.html" rel="alternate"></link><updated>2014-01-05T11:54:31+08:00</updated><author><name>ning</name></author><id>tag:,2014-01-05:ulk.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c1" id="id48"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c1&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id49"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;微内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#user-mode-kernel-mode" id="id50"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;user mode &amp;amp; kernel mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id51"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;内核可重入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id52"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id53"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核和用户内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#zombie" id="id54"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;僵尸进程 (zombie)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#init" id="id55"&gt;1.6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;如果父进程先结束, 子进程会继续, 并且挂到init上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id56"&gt;1.6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;清除僵尸进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id57"&gt;1.6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c2" id="id58"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c2 内存寻址(段页管理)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id59"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;逻辑地址, 线性地址, 物理地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id60"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分段&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id61"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;80286 后的实模式/保护模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id62"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;保护模式中的地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#segment-selectors" id="id63"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器(Segment Selectors)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id64"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;段寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#segment-descriptors" id="id65"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;段描述符(Segment Descriptors)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gdt-ldt" id="id66"&gt;2.2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;GDT/LDT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id67"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器, 段描述符的关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id68"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;分段单元: 从逻辑地址到线性地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linux" id="id69"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分段&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linux-gdt" id="id70"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的GDT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linuxldt" id="id71"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux中的LDT:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id72"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分页&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id73"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;常规分页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id74"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;扩展分页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pae-324g" id="id75"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;PAE: 允许在32位系统上访问大于4G内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id17" id="id76"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;64位架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-cache" id="id77"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Cache&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cache-snooping" id="id78"&gt;2.4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;cache snooping:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tlb-translation-lookaside-buffers" id="id79"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;TLB(Translation Lookaside Buffers)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id18" id="id80"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分页&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#layout" id="id81"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;物理内存Layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-page-table" id="id82"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Page Table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kernel-page-table" id="id83"&gt;2.5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Page Table&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id19" id="id84"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c3-processes" id="id85"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c3 Processes&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#processes-lightweight-processes-and-threads" id="id86"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Processes, Lightweight Processes, and Threads&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pthread" id="id87"&gt;3.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于pthread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linuxthreads-nptl" id="id88"&gt;3.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;LinuxThreads 和NPTL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id20" id="id89"&gt;3.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-descriptor" id="id90"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Descriptor&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id21" id="id91"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;能有多少个进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pidthread-group" id="id92"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;pid在thread group中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-list" id="id93"&gt;3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;process list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process" id="id94"&gt;3.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Process 资源限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-switch" id="id95"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Switch&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-context" id="id96"&gt;3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Context 切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#schedule" id="id97"&gt;3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;schedule()  函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#create-processes" id="id98"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Create Processes&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clone" id="id99"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核底层的clone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clone-fork-and-vfork" id="id100"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;clone( ), fork( ), and vfork( )&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#man-clone" id="id101"&gt;3.4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;man clone(库函数)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#do-fork" id="id102"&gt;3.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;do_fork() 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id22" id="id103"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pdflush" id="id104"&gt;3.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pdflush&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id23" id="id105"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;进程0 &amp;amp; 进程1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#destorying-processes" id="id106"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Destorying Processes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c4-interrupts-and-exceptions" id="id107"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 Interrupts and Exceptions&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupts-and-exceptions" id="id108"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupts and Exceptions&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupt" id="id109"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupt-handling" id="id110"&gt;4.1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#irqs-interrupt-requests" id="id111"&gt;4.1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQs (Interrupt ReQuests)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pic" id="id112"&gt;4.1.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;老的PIC 的硬件结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pic-the-advanced-programmable-interrupt-controller-apic" id="id113"&gt;4.1.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;新的PIC 的硬件结构 The Advanced Programmable Interrupt Controller (APIC)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#exceptions" id="id114"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#idt" id="id115"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;中断描述符表IDT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nested-execution-of-exception-and-interrupt-handlers" id="id116"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Nested Execution of Exception and Interrupt Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#initializing-the-interrupt-descriptor-table" id="id117"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Initializing the Interrupt Descriptor Table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#exception-handling" id="id118"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id24" id="id119"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt Handling(硬件产生的)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#irq" id="id120"&gt;4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQ在多处理器系统上的分发&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cpuirq" id="id121"&gt;4.5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;CPU的IRQ亲和力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id25" id="id122"&gt;4.5.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;例子:网卡多队列的中断绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id26" id="id123"&gt;4.5.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;把进程绑在核上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id27" id="id124"&gt;4.5.1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;网卡多队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id28" id="id125"&gt;4.5.1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;千兆网卡多队列&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id29" id="id126"&gt;4.5.1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;是否支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id30" id="id127"&gt;4.5.1.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;开启多队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#proc-softirqs" id="id128"&gt;4.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;/proc/softirqs&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mpstat" id="id129"&gt;4.5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mpstat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vmstat" id="id130"&gt;4.5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;vmstat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#softirqs-and-tasklets" id="id131"&gt;4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Softirqs and Tasklets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#work-queues" id="id132"&gt;4.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Work Queues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#returning-from-interrupts-and-exceptions" id="id133"&gt;4.8&amp;nbsp;&amp;nbsp;&amp;nbsp;Returning from Interrupts and Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c5-kernel-synchronization" id="id134"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 Kernel Synchronization&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-the-kernel-services-requests" id="id135"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;How the Kernel Services Requests&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id31" id="id136"&gt;5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核抢占&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronization-primitives" id="id137"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronization Primitives(同步原语)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cpu" id="id138"&gt;5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;每CPU变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id32" id="id139"&gt;5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;原子操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id33" id="id140"&gt;5.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障&amp;amp;内存屏障&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#optimization-barrier" id="id141"&gt;5.2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障(optimization barrier) 原语保证编译程序不会混淆原语前后的汇编指令.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id34" id="id142"&gt;5.2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;内存屏障确保原语之后的操作开始执行之前, 原语之前的操作已完成.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id35" id="id143"&gt;5.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id36" id="id144"&gt;5.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;读/写自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id37" id="id145"&gt;5.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;顺序锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rcu" id="id146"&gt;5.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;读-拷贝-更新 (RCU通过指针而不是锁)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id38" id="id147"&gt;5.2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;信号量&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#completion" id="id148"&gt;5.2.8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;补充原语(completion)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id39" id="id149"&gt;5.2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;本地中断禁止&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id40" id="id150"&gt;5.2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;本地软中断禁止&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronizing-accesses-to-kernel-data-structures" id="id151"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronizing Accesses to Kernel Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#examples-of-race-condition-prevention" id="id152"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Examples of Race Condition Prevention&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c6-timing-measurements" id="id153"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;c6 Timing Measurements&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clock-and-timer-circuits" id="id154"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Clock and Timer Circuits (几种硬件计时器)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-linux-timekeeping-architecture" id="id155"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Linux Timekeeping Architecture&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id41" id="id156"&gt;6.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;时钟中断时处理&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id42" id="id157"&gt;6.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;系统负载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id43" id="id158"&gt;6.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;监管内核代码&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#readprofiler-hot-spot" id="id159"&gt;6.2.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;readprofiler, 用于确定内核热点(hot spot).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#oprofile" id="id160"&gt;6.2.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;oprofile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id44" id="id161"&gt;6.2.1.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;检测死锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id45" id="id162"&gt;6.2.1.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;蒙特卡洛:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-the-time-and-date" id="id163"&gt;6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating the Time and Date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-system-statistics" id="id164"&gt;6.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating System Statistics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#software-timers-and-delay-functions" id="id165"&gt;6.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Software Timers and Delay Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-timing-measurements" id="id166"&gt;6.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Timing Measurements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c7-process-scheduling" id="id167"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;c7 Process Scheduling&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#scheduling-policy" id="id168"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Scheduling Policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-scheduling-algorithm" id="id169"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Scheduling Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#data-structures-used-by-the-scheduler" id="id170"&gt;7.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Data Structures Used by the Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#functions-used-by-the-scheduler-schedule" id="id171"&gt;7.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Functions Used by the Scheduler(schedule)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id46" id="id172"&gt;7.5&amp;nbsp;&amp;nbsp;&amp;nbsp;多处理器系统中 执行队列的平衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-scheduling" id="id173"&gt;7.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Scheduling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c8-memory-management" id="id174"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 Memory Management&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#page-frame-management" id="id175"&gt;8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Frame Management&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#numa" id="id176"&gt;8.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;非一致内存访问(NUMA)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-area-management" id="id177"&gt;8.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Area Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#noncontiguous-memory-area-management" id="id178"&gt;8.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Noncontiguous Memory Area Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c9-process-address-space" id="id179"&gt;9&amp;nbsp;&amp;nbsp;&amp;nbsp;c9. Process Address Space&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-processs-address-space" id="id180"&gt;9.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Process’s Address Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-memory-descriptor" id="id181"&gt;9.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Memory Descriptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-regions" id="id182"&gt;9.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Regions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#page-fault-exception-handler" id="id183"&gt;9.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Fault Exception Handler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-and-deleting-a-process-address-space" id="id184"&gt;9.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating and Deleting a Process Address Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#managing-the-heap" id="id185"&gt;9.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing the Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c10-system-calls" id="id186"&gt;10&amp;nbsp;&amp;nbsp;&amp;nbsp;c10 System Calls&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#posix-apis-and-system-calls" id="id187"&gt;10.1&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX APIs and System Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-call-handler-and-service-routines" id="id188"&gt;10.2&amp;nbsp;&amp;nbsp;&amp;nbsp;System Call Handler and Service Routines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#entering-and-exiting-a-system-call" id="id189"&gt;10.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Entering and Exiting a System Call&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#parameter-passing" id="id190"&gt;10.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Parameter Passing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kernel-wrapper-routines" id="id191"&gt;10.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Wrapper Routines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c11-signals" id="id192"&gt;11&amp;nbsp;&amp;nbsp;&amp;nbsp;c11. Signals&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-role-of-signals" id="id193"&gt;11.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of Signals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#generating-a-signal" id="id194"&gt;11.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Generating a Signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#delivering-a-signal" id="id195"&gt;11.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Delivering a Signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-signal-handling" id="id196"&gt;11.4&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Signal Handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c12-the-virtual-filesystem" id="id197"&gt;12&amp;nbsp;&amp;nbsp;&amp;nbsp;c12 The Virtual Filesystem&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-role-of-the-virtual-filesystem-vfs" id="id198"&gt;12.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of the Virtual Filesystem (VFS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vfs-data-structures" id="id199"&gt;12.2&amp;nbsp;&amp;nbsp;&amp;nbsp;VFS Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#filesystem-types" id="id200"&gt;12.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#filesystem-handling" id="id201"&gt;12.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pathname-lookup" id="id202"&gt;12.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Pathname Lookup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementations-of-vfs-system-calls" id="id203"&gt;12.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementations of VFS System Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#file-locking" id="id204"&gt;12.7&amp;nbsp;&amp;nbsp;&amp;nbsp;File Locking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c13-i-o-architecture-and-device-drivers" id="id205"&gt;13&amp;nbsp;&amp;nbsp;&amp;nbsp;c13. I/O Architecture and Device Drivers&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#i-o-architecture" id="id206"&gt;13.1&amp;nbsp;&amp;nbsp;&amp;nbsp;I/O Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-device-driver-model" id="id207"&gt;13.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Device Driver Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#device-files" id="id208"&gt;13.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#device-drivers" id="id209"&gt;13.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#character-device-drivers" id="id210"&gt;13.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Character Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c14-block-device-drivers" id="id211"&gt;14&amp;nbsp;&amp;nbsp;&amp;nbsp;c14. Block Device Drivers&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block-devices-handling" id="id212"&gt;14.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Devices Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-generic-block-layer" id="id213"&gt;14.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Generic Block Layer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-i-o-scheduler" id="id214"&gt;14.3&amp;nbsp;&amp;nbsp;&amp;nbsp;The I/O Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block-device-drivers" id="id215"&gt;14.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#opening-a-block-device-file" id="id216"&gt;14.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Opening a Block Device File&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c15-the-page-cache" id="id217"&gt;15&amp;nbsp;&amp;nbsp;&amp;nbsp;c15. The Page Cache&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-page-cache" id="id218"&gt;15.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#storing-blocks-in-the-page-cache" id="id219"&gt;15.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Storing Blocks in the Page Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#writing-dirty-pages-to-disk" id="id220"&gt;15.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Writing Dirty Pages to Disk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-sync-fsync-and-fdatasync-system-calls" id="id221"&gt;15.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The sync( ), fsync( ), and fdatasync() System Calls&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c16-accessing-files" id="id222"&gt;16&amp;nbsp;&amp;nbsp;&amp;nbsp;c16. Accessing Files&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reading-and-writing-a-file" id="id223"&gt;16.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Reading and Writing a File&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-mapping" id="id224"&gt;16.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#direct-i-o-transfers" id="id225"&gt;16.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Direct I/O Transfers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#asynchronous-i-o" id="id226"&gt;16.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Asynchronous I/O&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c17-page-frame-reclaiming" id="id227"&gt;17&amp;nbsp;&amp;nbsp;&amp;nbsp;c17. Page Frame Reclaiming&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-page-frame-reclaiming-algorithm" id="id228"&gt;17.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Frame Reclaiming Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reverse-mapping" id="id229"&gt;17.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Reverse Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementing-the-pfra" id="id230"&gt;17.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing the PFRA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#swapping" id="id231"&gt;17.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Swapping&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c18-the-ext2-and-ext3-filesystems" id="id232"&gt;18&amp;nbsp;&amp;nbsp;&amp;nbsp;c18. The Ext2 and Ext3 Filesystems&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#general-characteristics-of-ext2" id="id233"&gt;18.1&amp;nbsp;&amp;nbsp;&amp;nbsp;General Characteristics of Ext2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-disk-data-structures" id="id234"&gt;18.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Disk Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-memory-data-structures" id="id235"&gt;18.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Memory Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-the-ext2-filesystem" id="id236"&gt;18.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating the Ext2 Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-methods" id="id237"&gt;18.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#managing-ext2-disk-space" id="id238"&gt;18.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing Ext2 Disk Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-ext3-filesystem" id="id239"&gt;18.7&amp;nbsp;&amp;nbsp;&amp;nbsp;The Ext3 Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c19-process-communication" id="id240"&gt;19&amp;nbsp;&amp;nbsp;&amp;nbsp;c19. Process Communication&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pipes" id="id241"&gt;19.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Pipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fifos" id="id242"&gt;19.2&amp;nbsp;&amp;nbsp;&amp;nbsp;FIFOs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-v-ipc" id="id243"&gt;19.3&amp;nbsp;&amp;nbsp;&amp;nbsp;System V IPC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#posix-message-queues" id="id244"&gt;19.4&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX Message Queues&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c20-program-execution" id="id245"&gt;20&amp;nbsp;&amp;nbsp;&amp;nbsp;c20. Program Execution&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#executable-files" id="id246"&gt;20.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#executable-formats" id="id247"&gt;20.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Formats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#execution-domains" id="id248"&gt;20.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Execution Domains&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-exec-functions" id="id249"&gt;20.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The exec Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id47" id="id250"&gt;21&amp;nbsp;&amp;nbsp;&amp;nbsp;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
内存 c2, c8, c9
进程 c3, c7
中断 c4,
IO: 12, 13, 14, 15, 16, 17, 18
其它: 5, 6, 10, 11, 19, 20
&lt;/pre&gt;
&lt;p&gt;内存和io是重点, 没有网络中, 如epoll的实现.&lt;/p&gt;
&lt;p&gt;c1-c9看的比较认真, 有笔记, 后面看的比较粗.&lt;/p&gt;
&lt;div class="section" id="c1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id48"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c1&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;微内核&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;微内核vs巨内核 微内核慢，linux就是微内核&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="user-mode-kernel-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id50"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;user mode &amp;amp; kernel mode&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;两个模式是cpu提供的功能。应该理解为在两个模式下cpu可以使用的指令是不同的。或者说可以访问的内存区是不同的。&lt;/li&gt;
&lt;li&gt;用户程序调用系统调用，然后系统调用的使用cpu的指令进行切换到内核模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt; : 这是同一个进程, 一个进程可以运行在用户模式也可以在内核模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_mode.png" /&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_mode_2.png" /&gt;
&lt;p&gt;这个图很好的解释了什么情况下会从user mode 进入kernel mode:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;user mode 程序调用系统调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;时钟中断(此时内核会调用scheduler, 找一个程序来run)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;设备中断(此时内核处理设备响应)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如对读磁盘操作, 这里把磁盘缓冲区的内容读到内存&lt;/li&gt;
&lt;li&gt;对写磁盘操作, 这里检查写是否成功.&lt;/li&gt;
&lt;li&gt;接下来可以调用scheduler, 把那个Process 唤起就是 scheduler 的问题了&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;内存越界等(Excption)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;内核可重入&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核是可重入的, 意思就是说, 在中断中处理中, 可以再接受中断(某些中断当然是不可重入的)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如oom killer&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核和用户内存&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在的理解是这样的:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_space.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="zombie"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id54"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;僵尸进程 (zombie)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这样产生的:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;父进程fork后, 不去wait它(比如父进程在做sleep() 或其它操作, 总之就是没有调用wait()). 这也就产生了僵尸进程&lt;/li&gt;
&lt;li&gt;如果父进程挂掉, 这个进程就会被挂到init(1), init总是会wait() 它, 所以不会产生僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码, 子进程退出后, 父进程没去wait它:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int main(){
    int pid = fork();
    if(pid== 0) {
        fprintf(stderr, &amp;quot;child pid: %d\n&amp;quot;, getpid());
        sleep(1);
        fprintf(stderr, &amp;quot;child finish\n&amp;quot;);
    } else {                //Parent
        fprintf(stderr, &amp;quot;parent pid: %d\n&amp;quot;, getpid());
        sleep(100);
        fprintf(stderr, &amp;quot;parent finish\n&amp;quot;);
    }
    return 0;
}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
$ ./a.out
parent pid: 1221
child pid: 1222
child finish
&lt;/pre&gt;
&lt;p&gt;此时pstree看, 子进程挂到 父进程, 状态已经变成Z:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
init(1)-+-NetworkManager(1022)-+-dhclient(28101)
        |                      |-bash(31597)---a.out(1221)---a.out(1222)

$ ps  -elF
1 Z ning      1222  1221  0  80   0 -     0 exit       0   1 13:16 pts/1    00:00:00 [a.out] &amp;lt;defunct&amp;gt;
&lt;/pre&gt;
&lt;div class="section" id="init"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id55"&gt;1.6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;如果父进程先结束, 子进程会继续, 并且挂到init上&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int main(){
    int pid = fork();
    if(pid== 0) {
        fprintf(stderr, &amp;quot;child pid: %d\n&amp;quot;, getpid());
        sleep(2*100);
        fprintf(stderr, &amp;quot;child finish\n&amp;quot;);
    } else {                //Parent
        fprintf(stderr, &amp;quot;parent pid: %d\n&amp;quot;, getpid());
        sleep(1);
        fprintf(stderr, &amp;quot;parent finish\n&amp;quot;);
    }
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;父进程先退出, 子进程后退出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./a.out
parent pid: 928
child pid: 929
parent finish
&lt;/pre&gt;
&lt;p&gt;此时pstree看, 子进程已经挂到 init上了, 但是这时状态不是Z:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
init(1)-+-NetworkManager(1022)-+-dhclient(28101)
        |                      `-{NetworkManager}(1851)
        |-a.out(929)

$ ps  -elF
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  5961 poll_s  1888   0 Jan03 ?        00:00:01 /sbin/init
1 S ning       929     1  0  80   0 -  2936 hrtime   320   3 13:11 pts/1    00:00:00 ./a.out
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id56"&gt;1.6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;清除僵尸进程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;僵尸进程本身是不能被kill的(因为本来就是死的):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
0 S ning     20696 20023  0  80   0 -   969 hrtime   428   1 08:53 pts/16   00:00:00 ./a.out
1 Z ning     20697 20696  0  80   0 -     0 exit       0   3 08:53 pts/16   00:00:00 [a.out] &amp;lt;defunct&amp;gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ kill 20697                                           (不能kill掉)
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
0 S ning     20696 20023  0  80   0 -   969 hrtime   428   1 08:53 pts/16   00:00:00 ./a.out
1 Z ning     20697 20696  0  80   0 -     0 exit       0   3 08:53 pts/16   00:00:00 [a.out] &amp;lt;defunct&amp;gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ kill 20696                                           (解决方法是kill掉附进程)
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
nothing
&lt;/pre&gt;
&lt;p&gt;解决方法是kill掉父进程, 这样子进程会挂到 init, 并被init wait()&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id57"&gt;1.6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;父进程不一定非要调用wait, 忽略 &lt;tt class="docutils literal"&gt;SIGCHILD&lt;/tt&gt; 也可以(wait就是等待 &lt;tt class="docutils literal"&gt;SIGCHILD&lt;/tt&gt; ) 参考:&lt;/p&gt;
&lt;p&gt;引用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
僵尸进程简而言之就是：子进程退出时，父进程并未对其发出的SIGCHILD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵死进程。

在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵死进程，无法正常结束，此时即使是root身份kill -9也不能杀死僵死进程。补救办法是杀死僵尸进程的父进程(僵死进程的父进程必然存在)，僵死进程成为&amp;quot;孤儿进程&amp;quot;，过继给1号进程init，init始终会负责清理僵死进程。

在unix术语中，一个已经终止但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程称为僵尸进程(zombie)。
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id58"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c2 内存寻址(段页管理)&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;段主要是 隔离的作用!&lt;/li&gt;
&lt;li&gt;linux里面用的段主要是4个:
用户代码段, 用户数据段, 内核代码段, 内核数据段&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id59"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;逻辑地址, 线性地址, 物理地址&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
+-----------------+               +-----------------+            +-----------------+
|                 |   分段单元    |                 |  分页单元  |                 |
|  逻辑地址       |  ----------&amp;gt;  |     线性地址    | ---------&amp;gt; |    物理地址     |
|                 |               |                 |            |                 |
+-----------------+               +-----------------+            +-----------------+
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id60"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分段&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id61"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;80286 后的实模式/保护模式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一般系统刚启动的时候是在实模式,&lt;/p&gt;
&lt;p&gt;正常运行中, 是保护模式,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id62"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;保护模式中的地址&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;逻辑地址是段选择器和offset的组合:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="segment-selectors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id63"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器(Segment Selectors)&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
+------------------+                +----------------+
|                  |                |                |
|    段选择器      |       +        |   offset       |
|                  |                |                |
+------------------+                +----------------+
&lt;/pre&gt;
&lt;p&gt;段选择器有16 bit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
15                                        3   2   1  0
+-------------------------------------------+---+------+
|                   index                   |TI | RPL  |
+-------------------------------------------+---+------+

TI: Table Indicator
RPL Requestor Privilege Level
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id64"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;段寄存器&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在cpu中有专门设置的段寄存器, 用于存放段选择器:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cs: 代码段 (code)
    有两个bit表示 CPU Privilege Level(CPL)   &amp;lt;Linux 只用了0和3 (内核态/用户态)&amp;gt;
ss: 栈段   (stack)
ds: 数据段 (全局和static数据)
es
fs
gs
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="segment-descriptors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id65"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;段描述符(Segment Descriptors)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;存放在 &lt;tt class="docutils literal"&gt;GDT/LDT&lt;/tt&gt; 中.&lt;/p&gt;
&lt;p&gt;8byte的段描述符:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-Segment-Descriptors.png" /&gt;
&lt;div class="section" id="gdt-ldt"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id66"&gt;2.2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;GDT/LDT&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
GDT: 通常一个系统只有一个
LDT: 如果每个进程需要额外的段
&lt;/pre&gt;
&lt;p&gt;gdtr寄存器: 指向内存中存放的GDT
ldtr集群器: 指向内存中存放的LDT&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id67"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器, 段描述符的关系&lt;/a&gt;&lt;/h4&gt;
&lt;img alt="" src="/imgs/ulk-Segment-Descriptors-and-Segment-Selector.png" /&gt;
&lt;p&gt;段选择器的字段:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;index:&lt;/th&gt;&lt;td class="field-body"&gt;Identifies the Segment Descriptor entry contained in the GDT or in the LDT (described further in the text following this table).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;TI:&lt;/th&gt;&lt;td class="field-body"&gt;Table Indicator: specifies whether the Segment Descriptor is included in the GDT (TI = 0) or in the LDT (TI = 1).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RPL:&lt;/th&gt;&lt;td class="field-body"&gt;Requestor Privilege Level: specifies the Current Privilege Level of the CPU when the corresponding Segment Selector is loaded into the cs register; it also may be used to selectively weaken the processor privilege level when accessing data segments (see Intel documentation for details).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;计算:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gdtr 中存放的地址 +  段选择器中index*8 = 段描述符的位置.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id68"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;分段单元: 从逻辑地址到线性地址&lt;/a&gt;&lt;/h4&gt;
&lt;img alt="" src="/imgs/ulk-Translating-a-logical-address.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id69"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分段&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为分段和分页功能上比较重复, Linux实现中对分段用的很少&lt;/p&gt;
&lt;p&gt;Linux 2.6 只在80x86架构下使用分段, 只使用4个段:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-linux-segment.png" /&gt;
&lt;p&gt;这4个段的线性地址空间都是 &lt;tt class="docutils literal"&gt;0 - &lt;span class="pre"&gt;2^32-1&lt;/span&gt;&lt;/tt&gt; , 意味着&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有的进程(不管用户模式还是内核模式) 都使用相同的线性地址空间.&lt;/li&gt;
&lt;li&gt;因为开始于0x0000000, 线性地址 = 逻辑地址是一样的&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="linux-gdt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id70"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的GDT&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;单核系统只有一个GDT&lt;/li&gt;
&lt;li&gt;多核系统, 对每个核有一个GDT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each GDT includes 18 segment descriptors and 14 null, unused, or reserved entries&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linuxldt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id71"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux中的LDT:&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;User Application 不使用LDT, 大家共享一个 &lt;tt class="docutils literal"&gt;default_ldt&lt;/tt&gt;, 可以用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;modify_ldt()系统调用&lt;/span&gt;&lt;/tt&gt; 来修改ldt, (Wine使用, 模拟window)&lt;/p&gt;
&lt;p&gt;man modify_ldt:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;sys/types.h&amp;gt;
int modify_ldt(int func, void *ptr, unsigned long bytecount);

DESCRIPTION:
modify_ldt()  reads or writes the local descriptor table (ldt) for a process.  The ldt is a per-process memory management table used by the i386 processor.
For more information on this table, see an Intel 386 processor handbook.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id72"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分页&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;检查对页的访问是否有权限, 如果没有, 产生PageFault exception&lt;/p&gt;
&lt;p&gt;page frame: 物理概念(physical page)&lt;/p&gt;
&lt;p&gt;80x86: 控制寄存器cr0中的PG标志控制是否使用硬件提供的分页机制:&lt;/p&gt;
&lt;p&gt;PG = 0: linear addresses 就是 physical addresses
PG = 1: 使用页表分页.&lt;/p&gt;
&lt;div class="section" id="id15"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id73"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;常规分页&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;4KB 的page, 两极页表:&lt;/p&gt;
&lt;p&gt;如果用一级页表, 当用户稀疏使用了4G线性地址空间，比如只用了0x00000000和0xFFFFFFFF, 就需要 2^20个页表项 (2^32/4k) 需要4M内存.
如果用2级页表, 如果用户实际用的内存较少, 页表所需空间就较小&lt;/p&gt;
&lt;p&gt;当然, 如果一个进程使用全部4G空间, 那么一级页表和两极页表都需要占用相同的空间, (二级页表还更多些)&lt;/p&gt;
&lt;p&gt;分页机制示意图:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging.png" /&gt;
&lt;p&gt;每个进程都必须有自己的 &lt;tt class="docutils literal"&gt;Page Dirrectory&lt;/tt&gt;, 但是只需要部分的 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; .&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Page Dirrectory&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 都是大小都是1024个页表条目. 页表条目包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;Present flag&lt;/tt&gt; : 是否在内存中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;20bit物理地址&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Dirty flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Read/Write flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;User/Supervisor&lt;/tt&gt; flag (注意, 只有两种权限级别, 不像段映射, 有4个权限级别)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;标志为0时, 只允许 CPL &amp;lt; 3 的时候访问(在Linux里面就是内核态)&lt;/li&gt;
&lt;li&gt;标志为1时, 总是允许访问.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id74"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;扩展分页&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;允许4M的 &lt;tt class="docutils literal"&gt;page frame&lt;/tt&gt;:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-extended-paging.png" /&gt;
&lt;p&gt;相当于省掉了 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 这一层.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pae-324g"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id75"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;PAE: 允许在32位系统上访问大于4G内存&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Physical Address Extension&lt;/p&gt;
&lt;p&gt;从 &lt;tt class="docutils literal"&gt;Pentium Pro&lt;/tt&gt; 开始, Intel 把地址总线宽度从 32 升级到36, 允许访问2^36=64G内存.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PAE is activated by setting the Physical Address Extension (PAE) flag in the cr4 con- trol register.
增加了:
A new level of Page Table called the Page Directory Pointer Table (PDPT)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id76"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;64位架构&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;64位是 256 TB 地址空间&lt;/p&gt;
&lt;p&gt;64位中, 一般使用48位, 如果依然使用4KB的页, 还剩下48-12=36 bit, 这放在两级页表中, &lt;tt class="docutils literal"&gt;Page Directory&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 就分别要有2^18条目, 得占用1M空间.&lt;/p&gt;
&lt;p&gt;所以, 64位系统中, 一般使用多级页表:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging-level.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-cache"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id77"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Cache&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Today’s microprocessors have clock rates of several gigahertz, while dynamic RAM (DRAM) chips have access times in the range of hundreds of clock cycles.&lt;/p&gt;
&lt;p&gt;L1 cache, L2 cache 之类&lt;/p&gt;
&lt;div class="section" id="cache-snooping"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id78"&gt;2.4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;cache snooping:&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;在多核架构中, 每个核有自己的cache, 一个核在写数据到cache时, 需要确保另一个核没有对应着一块内存的cache.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="tlb-translation-lookaside-buffers"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id79"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;TLB(Translation Lookaside Buffers)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;80x86 中: to speed up linear address translation&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id18"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id80"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分页&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对32位架构和64位架构使用同样的分页模型&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2.6.10: 3级页表&lt;/li&gt;
&lt;li&gt;2.6.11: 4级页表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4级页表:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging-level-in-linux.png" /&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于32位系统: Linux直接把Upper Dirrectory 和Middle Directory 设为只有1个条目, 这样就可以变为2级页表.&lt;/li&gt;
&lt;li&gt;对于32位+PAE的系统: Linux使用3级页表,&lt;/li&gt;
&lt;li&gt;对于64位系统, 使用3或4级页表. (见前面的表格)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="layout"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id81"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;物理内存Layout&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Linux 内核通常在RAM的0x00100000(from the second megabyte)&lt;/p&gt;
&lt;p&gt;因为第一M通常是BIOS,&lt;/p&gt;
&lt;p&gt;启动时, 内核向BIOS查询可用物理内存大小:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
In the early stage of the boot sequence (see Appendix A), the kernel queries the BIOS and learns the size of the physical memory.
&lt;/pre&gt;
&lt;p&gt;之后内核调用 &lt;tt class="docutils literal"&gt;machine_specific_memory_setup()&lt;/tt&gt; 构造可用空间的一个列表, 例如&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Start      End        Type
0x00000000 0x0009ffff Usable
0x000f0000 0x000fffff Reserved
0x00100000 0x07feffff Usable
0x07ff0000 0x07ff2fff ACPI data
0x07ff3000 0x07ffffff ACPI NVS
0xffff0000 0xffffffff Reserved
&lt;/pre&gt;
&lt;p&gt;arch/i386/kernel/setup.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void __init setup_arch(char **cmdline_p)
{

    print_memory_map(machine_specific_memory_setup());
    max_low_pfn = setup_memory();

    paging_init();

    register_memory();
}
&lt;/pre&gt;
&lt;p&gt;内核加载后, 一般占3M空间, 也分为代码段, 数据段.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="process-page-table"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id82"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Page Table&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;注意这里说的是线性地址空间:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Linear addresses from 0x00000000 to 0xbfffffff can be addressed when the process runs in either User or Kernel Mode.&lt;/li&gt;
&lt;li&gt;Linear addresses from 0xc0000000 to 0xffffffff can be addressed only when the process runs in Kernel Mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel-page-table"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id83"&gt;2.5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Page Table&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The kernel maintains a set of page tables for its own use, rooted at a so-called master kernel Page Global Directory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id84"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 中所有的进程(不管用户模式还是内核模式) 都使用相同的线性地址空间: &lt;tt class="docutils literal"&gt;0 - &lt;span class="pre"&gt;2^32-1&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c3-processes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id85"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c3 Processes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Processes are often called tasks or threads in the Linux source code.&lt;/p&gt;
&lt;p&gt;LWP: Lightweight Processes, Linux 的多线程就是用LWP实现的.&lt;/p&gt;
&lt;div class="section" id="processes-lightweight-processes-and-threads"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id86"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Processes, Lightweight Processes, and Threads&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;老的Unix: 进程通过fork产生新进程, 共享代码段, 有不同的数据段(Copy on Write)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不支持multithreaded, 内核看到的都是进程, 线程的概念是在用户态实现的(pthread)&lt;/li&gt;
&lt;li&gt;老的pthread库是用这种实现.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;新的Unix: 直接支持多线程,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;user programs having many relatively independent execution flows sharing a large portion of the application data structures&lt;/li&gt;
&lt;li&gt;In such systems, a process is composed of several user threads&lt;/li&gt;
&lt;li&gt;Linux 用 &lt;tt class="docutils literal"&gt;Lightweight processes&lt;/tt&gt; 支持multithreaded&lt;/li&gt;
&lt;li&gt;Examples of POSIX-compliant pthread libraries that use Linux’s lightweight processes are LinuxThreads, Native POSIX Thread Library (NPTL), and IBM’s Next Generation Posix Threading Package (NGPT).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In Linux a thread group is basically a set of lightweight processes that implement a multithreaded application and act as a whole with regards to some system calls such as getpid(), kill(), and _exit().&lt;/p&gt;
&lt;div class="section" id="pthread"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id87"&gt;3.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于pthread&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
The code below comes from &amp;quot;Advanced Programing in Unix Environment&amp;quot;, it creates a new thread, and prints the process id and thread id for main and new threads.

In the book, it said that in linux, the output of this code would show that two threads have different process ids, because pthread uses lightweight process to emulate thread. But when I ran this code in Ubuntu 12.04, it has kernel 3.2, printed the same pid.

so, does the new linux kernel change the internal implementation of pthread?

#include &amp;quot;apue.h&amp;quot;
#include &amp;lt;pthread.h&amp;gt;

pthread_t ntid;

void printids(const char *s) {
  pid_t     pid;
  pthread_t tid;
  pid = getpid();
  tid = pthread_self();
  printf(&amp;quot;%s pid %u tid %u (0x%x)\n&amp;quot;,
         s, (unsigned int)pid, (unsigned int)tid, (unsigned int)tid);
}

void *thread_fn(void* arg) {
  printids(&amp;quot;new thread: &amp;quot;);
  return (void *)0;
}

int main(void) {
  int err;
  err = pthread_create(&amp;amp;ntid, NULL, thread_fn, NULL);
  if (err != 0)
    err_quit(&amp;quot;can't create thread: %s\n&amp;quot;, strerror(err));
  printids(&amp;quot;main thread: &amp;quot;);
  sleep(1);
  return 0;
}
&lt;/pre&gt;
&lt;p&gt;On Linux pthread uses the clone syscall with a special flag CLONE_THREAD.&lt;/p&gt;
&lt;p&gt;See the documentation of clone syscall:&lt;/p&gt;
&lt;p&gt;CLONE_THREAD (since Linux 2.4.0-test8):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
If CLONE_THREAD is set, the child is placed in the same thread group as the calling process. To make the remainder of the discussion of CLONE_THREAD more readable, the term &amp;quot;thread&amp;quot; is used to refer to the processes within a thread group.

Thread groups were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that share a single PID. Internally, this shared PID is the so-called thread group identifier (TGID) for the thread group. Since Linux 2.4, calls to getpid(2) return the TGID of the caller.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="linuxthreads-nptl"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id88"&gt;3.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;LinuxThreads 和NPTL&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一个系统里面的pthread实现只会是两种之一, 可以用下面这个命令查询本系统使用的pthread版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
getconf GNU_LIBPTHREAD_VERSION
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id89"&gt;3.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads/"&gt;https://computing.llnl.gov/tutorials/pthreads/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可以参考这本书: &lt;a class="reference external" href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_47.html"&gt;http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_47.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="process-descriptor"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id90"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Descriptor&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;进程描述符&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-process-descriptor.png" /&gt;
&lt;p&gt;注意内核里面 没有thread 的概念.&lt;/p&gt;
&lt;p&gt;进程到Process Descriptor 的一一对应关系, 是通过 Process Descriptor结构的地址值确定的.&lt;/p&gt;
&lt;div class="section" id="id21"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id91"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;能有多少个进程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;by default, the maximum PID number is 32,767 (PID_MAX_DEFAULT - 1) , 32位系统最多3w个进程.&lt;/p&gt;
&lt;p&gt;the system administrator may reduce this limit by writing a smaller value into the /proc/sys/kernel/pid_max file&lt;/p&gt;
&lt;p&gt;In 64-bit architectures, the system administrator can enlarge the maximum PID number up to 4,194,303&lt;/p&gt;
&lt;p&gt;因为内核分配一个pid的时候, 需要确保这个pid没有被用过, 所以需要一个bitmap, 32767个bit, 正好是4k(一个page).
在64位系统中, 如果pid_max设置为 4,194,303, 就可能需要0.5M内存做bitmap, 这些内存一旦用了就不会被释放的.&lt;/p&gt;
&lt;p&gt;我们的机器一般都是默认的32767&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pidthread-group"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id92"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;pid在thread group中&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在一个thread group 中的进程, 从用户看来pid相等, 实际上, 内核中它们的pid不相等, 是因为getpid 返回的是 &lt;tt class="docutils literal"&gt;tgid&lt;/tt&gt; .&lt;/p&gt;
&lt;p&gt;To comply with this standard, Linux makes use of thread groups. The identifier shared by the threads is the PID of the thread group leader, that is, the PID of the first lightweight process in the group;&lt;/p&gt;
&lt;p&gt;it is stored in the tgid field of the process descriptors. The getpid() system call returns the value of &lt;tt class="docutils literal"&gt;tgid&lt;/tt&gt; relative to the current process instead of the value of pid, so all the threads of a multithreaded application share the same identifier&lt;/p&gt;
&lt;p&gt;注意: 但是 &lt;tt class="docutils literal"&gt;kill()&lt;/tt&gt; 的时候用的是pid.&lt;/p&gt;
&lt;p&gt;因为内核中 内核栈后面有意个指向 &lt;tt class="docutils literal"&gt;Process Descriptor&lt;/tt&gt; 的指针, 所以:&lt;/p&gt;
&lt;p&gt;the kernel can easily obtain the address of the thread_info Structure of the process currently running on a CPU from the value of the esp register:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
current_thread_info()  这个函数用的非常多
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="process-list"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id93"&gt;3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;process list&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;用内核的双链表结构&lt;/p&gt;
&lt;p&gt;不同优先级:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
truct list_head [140];  #queue The 140 heads of the priority lists
&lt;/pre&gt;
&lt;p&gt;四个hash表用于从id到 Process Descriptor 的映射:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Hash table type     Field name  Description
PIDTYPE_PID         pid         PID of the process
PIDTYPE_TGID        tgid        PID of thread group leader process
PIDTYPE_PGID        pgrp        PID of the group leader process
PIDTYPE_SID         session     PID of the session leader process
&lt;/pre&gt;
&lt;p&gt;用于pid的hash函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
unsigned long hash_long(unsigned long val, unsigned int bits)
{
    unsigned long hash = val * 0x9e370001UL;
    return hash &amp;gt;&amp;gt; (32 - bits);
}
&lt;/pre&gt;
&lt;p&gt;这个数字0x9e370001UL, 是一个质数. 而且比较容易算(二进制中1的位数较少)&lt;/p&gt;
&lt;p&gt;A process wishing to wait for a specific condition can invoke any of the functions shown in the following list.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
The sleep_on() function operates on the current process:
void sleep_on(wait_queue_head_t *wq)
{
    wait_queue_t wait;
    init_waitqueue_entry(&amp;amp;wait, current);
    current-&amp;gt;state = TASK_UNINTERRUPTIBLE;
    add_wait_queue(wq,&amp;amp;wait); /* wq points to the wait queue head */
    schedule();
    remove_wait_queue(wq, &amp;amp;wait);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="process"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id94"&gt;3.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Process 资源限制&lt;/a&gt;&lt;/h4&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_AS:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum size of process address space, in bytes. The kernel checks this value when the
process uses malloc( ) or a related function to enlarge its address space (see the section
The Process’s Address Space” in Chapter 9).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_CORE:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum core dump file size, in bytes. The kernel checks this value when a process is
aborted, before creating a core file in the current directory of the process (see the section
Actions Performed upon Delivering a Signal” in Chapter 11). If the limit is 0, the kernel
won’t create the file.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_CPU:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum CPU time for the process, in seconds. If the process exceeds the limit, the ker-
nel sends it a SIGXCPU signal, and then, if the process doesn’t terminate, a SIGKILL sig-
nal (see Chapter 11).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_DATA:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum &lt;tt class="docutils literal"&gt;heap size&lt;/tt&gt; , in bytes. The kernel checks this value before expanding the heap of
the process (see the section “Managing the Heap” in Chapter 9).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_FSIZE:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum file size allowed, in bytes. If the process tries to enlarge a file to a size greater
than this value, the kernel sends it a SIGXFSZ signal.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_LOCKS:&lt;/th&gt;&lt;td class="field-body"&gt;Maximum number of file locks (currently, not enforced).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_NOFILE:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="process-switch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id95"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Switch&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="hardware-context"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id96"&gt;3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Context 切换&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;2.6以前, 使用 &lt;tt class="docutils literal"&gt;far jmp&lt;/tt&gt; 来实现硬件层次的切换, 自动保存寄存器的值.
But Linux 2.6 uses software to perform a process switch for the following reasons:&lt;/p&gt;
&lt;p&gt;总之就是保存各种寄存器. MMX&amp;lt; FPU, SSE之类.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="schedule"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id97"&gt;3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;schedule()  函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;every process switch consists of two steps:
1. Switching the Page Global Directory to install a new address space; we’ll describe this step in Chapter 9.
2. Switching the Kernel Mode stack and the hardware context, which provides all the information needed by the kernel to execute the new process, including the CPU registers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="create-processes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id98"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Create Processes&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="clone"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id99"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核底层的clone&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;各种flag:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_VM:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the memory descriptor and all Page Tables (see Chapter 9).
共享地址空间.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_FS:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the table that identifies the root directory and the current working directory, as
well as the value of the bitmask used to mask the initial file permissions of a new file
(the so-called file umask).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_FILES:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the table that identifies the open files (see Chapter 12).
共享打开的文件fd.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_SIGHAND:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the tables that identify the signal handlers and the blocked and pending signals
(see Chapter 11). If this flag is true, the CLONE_VM flag must also be set.
共享sighandler(比如nohup 先设置了SIGHANDLER, 再打开子进程的时候, 肯定就设置了这个标记)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_PTRACE:&lt;/th&gt;&lt;td class="field-body"&gt;If traced, the parent wants the child to be traced too. Furthermore, the debugger may
want to trace the child on its own; in this case, the kernel forces the flag to 1.
跟踪模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_VFORK:&lt;/th&gt;&lt;td class="field-body"&gt;Set when the system call issued is a vfork( ) (see later in this section).
...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_STOPPED:&lt;/th&gt;&lt;td class="field-body"&gt;Forces the child to start in the TASK_STOPPED state.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="clone-fork-and-vfork"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id100"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;clone( ), fork( ), and vfork( )&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;clone 创建线程, 基本上就是上面sys_clone系统调用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;fork: 用clone实现, 设置了SIGCHILD, 所有的flag都未设置 (TODO: ? 难道CLONE_SIGHAND也没设置?)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;它的chile_stack参数是父进程当前堆栈指针(所以创建完成后, 父子两个进程的堆栈指针是一样的.)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;copy on write&lt;/tt&gt; 保证堆栈上有写操作的时候, 父子进程就会使用不同的堆栈.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;vfork (create a child process and block parent)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;设置SIGCHILD, CLONE_VM, CLONE_VFORK,&lt;/li&gt;
&lt;li&gt;vfork 阻塞父进程的执行, 一直到子进程退出或执行一个新的程序为止.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="man-clone"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id101"&gt;3.4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;man clone(库函数)&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;

int clone(int (*fn)(void *), void *child_stack,
          int flags, void *arg, ...
          /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );

 It is actually a library function layered on top of the underlying clone() system call, hereinafter referred to as sys_clone.
 (这个clone是一个library函数, 下层是通过sys_clone系统调用实现, sys_clone没有 fn, arg参数, 这两个参数是 clone这个库函数加上的.)

 这个clone是用于实现thread的. 允许设置共享内存, 栈空间, 栈位置等.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="do-fork"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id102"&gt;3.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;do_fork() 函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;do_fork() 负责处理clone(), fork(), vfork() 系统调用.&lt;/p&gt;
&lt;p&gt;几个重要步骤:
1. 查找pidmap_array 位图, 为子进程分配新的pid
2. If the child will run on the &lt;strong&gt;same CPU&lt;/strong&gt; as the parent, and parent and child do not share the same set of page tables (CLONE_VM flag cleared), it then forces the child to run before the parent by inserting it into the parent’s runqueue right before the parent.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This simple step yields better performance if the child flushes its address space and executes a new program right after the forking. If we let the parent run first, the Copy On Write mechanism would give rise to a series of unnecessary page duplications.&lt;/p&gt;
&lt;p&gt;这种情况, 强迫 子进程先运行,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id103"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核中, 周期性执行, 只运行在内核态, 用kernel_thread() 函数创建.&lt;/p&gt;
&lt;p&gt;The function essentially invokes do_fork() as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, pregs, 0, NULL, NULL);
&lt;/pre&gt;
&lt;p&gt;常见的内核线程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;keventd (also called events)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Executes the functions in the keventd_wq workqueue (see Chapter 4).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kapmd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Handles the events related to the Advanced Power Management (APM).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kswapd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Reclaims memory, as described in the section “Periodic Reclaiming” in Chapter 17.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pdflush&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Flushes “dirty” buffers to disk to reclaim memory, as described in the section “The pdflush Kernel Threads” in Chapter 15.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kblockd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Executes the functions in the kblockd_workqueue workqueue. Essentially, it periodically activates the block device drivers, as described in the section “Activating the Block Device Driver” in Chapter 14.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ksoftirqd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Runs the tasklets (see section “Softirqs and Tasklets” in Chapter 4); there is one of these kernel threads for each CPU in the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="pdflush"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id104"&gt;3.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pdflush&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;参考: &lt;a class="reference external" href="http://www.westnet.com/~gsmith/content/linux-pdflush.htm"&gt;http://www.westnet.com/~gsmith/content/linux-pdflush.htm&lt;/a&gt;
&lt;a class="reference external" href="http://www.linuxjournal.com/article/6931"&gt;http://www.linuxjournal.com/article/6931&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可能有 2 - 8 个pdflush threads.&lt;/p&gt;
&lt;p&gt;You can monitor how many are active by looking at /proc/sys/vm/nr_pdflush_threads.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Whenever all existing pdflush threads are busy for at least one second, an additional pdflush daemon is spawned.&lt;/li&gt;
&lt;li&gt;Each time a second has passed without any pdflush activity, one of the threads is removed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调优:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_writeback_centisecs (default 500):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;In hundredths of a second, this is how often pdflush wakes up to write data to disk.&lt;/li&gt;
&lt;li&gt;The default wakes up the two (or more) active threads every five seconds.&lt;/li&gt;
&lt;li&gt;减小这个值会让pdflush 更加激进.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_expire_centiseconds (default 3000):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;In hundredths of a second, how long data can be in the page cache before it's considered expired and must be written at the next opportunity. Note that this default is very long: a full 30 seconds. That means that under normal circumstances, unless you write enough to trigger the other pdflush method, Linux won't actually commit anything you write until 30 seconds later.&lt;/li&gt;
&lt;li&gt;多长时间以上的page需要flush&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_background_ratio (default 10):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Maximum percentage of active that can be filled with dirty pages before pdflush begins to write them&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_ratio (default 40):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Maximum percentage of total memory that can be filled with dirty pages before processes are forced to write dirty buffers themselves during their time slice instead of being allowed to do more writes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id105"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;进程0 &amp;amp; 进程1&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;进程0: 所有进程的祖先, (idle进程)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;是一个内核线程&lt;/li&gt;
&lt;li&gt;执行 &lt;tt class="docutils literal"&gt;cpu_idle()&lt;/tt&gt; 函数, 本质上是在开中断的情况下重复执行hlt指令&lt;/li&gt;
&lt;li&gt;只有当没有其它进程处于TASK_RUNNING 状态时, 调度程序才选择进程0&lt;/li&gt;
&lt;li&gt;多核系统中, 每个核都有一个进程0 (TODO: how)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;进程1: init进程, 由进程0创建,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;创建后调用 execve() 装载init二进制, 不是内核线程.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="destorying-processes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id106"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Destorying Processes&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;exit_group() 系统调用, 终止整个线程组, 对应 &lt;tt class="docutils literal"&gt;c库函数exit()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;exit() 系统调用, 终止一个线程          对应 &lt;tt class="docutils literal"&gt;pthread_exit()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c4-interrupts-and-exceptions"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id107"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 Interrupts and Exceptions&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;strong&gt;Interrupts&lt;/strong&gt; Asynchronous interrupts: &lt;strong&gt;硬件&lt;/strong&gt; 发出的.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;可屏蔽中断&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;不可屏蔽中断&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;极少数. Only a few critical events (such as hardware failures)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;Exceptions&lt;/tt&gt; Synchronous interrupts: cpu执行完一个指令后发出的&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Processor-detected exceptions (怎么翻译)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Faults&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如Page Fault Exception Handler&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Traps&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Aborts&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Programmed exceptions(程序主动触发)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;int&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;int3&lt;/tt&gt; instructions&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;into&lt;/tt&gt; (check for overflow) and &lt;tt class="docutils literal"&gt;bound&lt;/tt&gt;  (check on address bound) instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exception 和interrupt 是intel的术语.&lt;/p&gt;
&lt;div class="section" id="interrupts-and-exceptions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id108"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupts and Exceptions&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="interrupt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id109"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="interrupt-handling"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id110"&gt;4.1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt handling&lt;/a&gt;&lt;/h5&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;非常轻量, 内核必须尽量处理尽量多的中断, 这样内核就必须把Interrupt Handler 做的很轻.
比如有数据ready时, 中断处理程序只是简单的做一个标记, 然后通知相应的程序, 而不会在中断处理程序里面拷贝数据到内存.&lt;/li&gt;
&lt;li&gt;可重入&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="irqs-interrupt-requests"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id111"&gt;4.1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQs (Interrupt ReQuests)&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;每个硬件都有一个 Interrupt ReQuest (IRQ) line 引脚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;所有硬件的引脚 都连到 &lt;tt class="docutils literal"&gt;Programmable Interrupt Controller(PIC)&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;PIC (Programmable Interrupt Controller)&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Monitors the IRQ lines, checking for raised signals. If two or more IRQ lines are raised, selects the one having the lower pin number.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;If a raised signal occurs on an IRQ line:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last loweralpha simple"&gt;
&lt;li&gt;Converts the raised signal received into a corresponding vector.&lt;/li&gt;
&lt;li&gt;Stores the vector in an Interrupt Controller I/O port, thus allowing the CPU to read it via the data bus.&lt;/li&gt;
&lt;li&gt;Sends a raised signal to the processor INTR pin—that is, issues an interrupt. (给CPU的INTR引脚发信号)&lt;/li&gt;
&lt;li&gt;Waits until the CPU acknowledges the interrupt signal by writing into one of the Programmable Interrupt Controllers (PIC) I/O ports; when this occurs, clears the INTR line.&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Goes back to step 1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IRQ线可以屏蔽.&lt;/p&gt;
&lt;div class="section" id="pic"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id112"&gt;4.1.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;老的PIC 的硬件结构&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;2个8259芯片, 第二个向上连在第一个的一个引脚, 可以处理15个IRQ线&lt;/p&gt;
&lt;p&gt;Traditional PICs are implemented by connecting “in cascade” two 8259A-style external chips. Each chip can handle up to eight different IRQ input lines. Because the INT output line of the slave PIC is connected to the IRQ2 pin of the master PIC, the number of available IRQ lines is limited to 15.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pic-the-advanced-programmable-interrupt-controller-apic"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id113"&gt;4.1.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;新的PIC 的硬件结构 The Advanced Programmable Interrupt Controller (APIC)&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;Pentium III 以后有APIC&lt;/p&gt;
&lt;p&gt;多核系统中, 每个核都应该可以处理中断, 所以有一个中断总线, APIC和CPU都连到这个总线上, 有总线仲裁/路由机制:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-multi-apic.png" /&gt;
&lt;p&gt;硬件终端可以有两种处理方式:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Static distribution&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;指定中断有某个CPU处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Dynamic distribution&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;信号被分发到CPU 中 priority 最小的一个. (这个priority可以编程修改)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CPU之间也能发送中断.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exceptions"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id114"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Exceptions&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; “Divide error” (fault)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Raised when a program issues an integer division by 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;1&lt;/tt&gt; “Debug” (trap or fault)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Raised when the TF flag of eflags is set (quite useful to implement single-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register (see the section “Hardware Context” in Chapter 3).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;3&lt;/tt&gt; “Breakpoint” (trap)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Caused by an int3 (breakpoint) instruction (usually inserted by a debugger).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;4&lt;/tt&gt; “Overflow” (trap)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;An into (check for overflow) instruction has been executed while the OF (overflow) flag of eflags is set.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;8&lt;/tt&gt; “Double fault”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;11&lt;/tt&gt; “Segment not present” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;12&lt;/tt&gt; “Stack segment fault” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;14&lt;/tt&gt; “Page Fault” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核收到中断后，通常会向进程发送信号(这就是我们段错误的时候是收到信号的原因)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Table 4-1. Signals sent by the exception handlers

# Exception                         Exception handler                  Signal
0 Divide error                      divide_error( )                    SIGFPE
1 Debug                             debug( )                           SIGTRAP
2 NMI                               nmi( )                             None
3 Breakpoint                        int3( )                            SIGTRAP
4 Overflow                          overflow( )                        SIGSEGV
5 Bounds check                      bounds( )                          SIGSEGV
6 Invalid opcode                    invalid_op( )                      SIGILL
7 Device not available              device_not_available( )            None
8 Double fault                      doublefault_fn()                   None
9 Coprocessor segment overrun       coprocessor_segment_overrun( )     SIGFPE
10 Invalid TSS                      invalid_TSS( )                     SIGSEGV
11 Segment not present              segment_not_present( )             SIGBUS
12 Stack segment fault              stack_segment( )                   SIGBUS
13 General protection               general_protection( )              SIGSEGV
14 Page Fault                       page_fault( )                      SIGSEGV
15 Intel-reserved                   None                               None
16 Floating-point error             coprocessor_error( )               SIGFPE
17 Alignment check                  alignment_check( )                 SIGBUS
18 Machine check                    machine_check()                    None
19 SIMD floating point              simd_coprocessor_error()           SIGFPE
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="idt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id115"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;中断描述符表IDT&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="nested-execution-of-exception-and-interrupt-handlers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id116"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Nested Execution of Exception and Interrupt Handlers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="initializing-the-interrupt-descriptor-table"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id117"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Initializing the Interrupt Descriptor Table&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Intel 提供三种 Interrupt, Trap, and System Gates, 权限不同, o, 比较复杂:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set_trap_gate(0,&amp;amp;divide_error);
set_trap_gate(1,&amp;amp;debug);

set_intr_gate(2,&amp;amp;nmi);
set_system_intr_gate(3,&amp;amp;int3);
set_system_gate(4,&amp;amp;overflow);
set_system_gate(5,&amp;amp;bounds);
set_trap_gate(6,&amp;amp;invalid_op);
set_trap_gate(7,&amp;amp;device_not_available);
set_task_gate(8,31);
set_trap_gate(9,&amp;amp;coprocessor_segment_overrun);
set_trap_gate(10,&amp;amp;invalid_TSS);
set_trap_gate(11,&amp;amp;segment_not_present);
set_trap_gate(12,&amp;amp;stack_segment);
set_trap_gate(13,&amp;amp;general_protection);
set_intr_gate(14,&amp;amp;page_fault);
...
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="exception-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id118"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception Handling&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常是发信号到响应进程.&lt;/p&gt;
&lt;p&gt;Most exceptions issued by the CPU are interpreted by Linux as error conditions.
When one of them occurs, the kernel sends a signal to the process that caused the
exception to notify it of an anomalous condition.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;If, for instance, a process performs
a division by zero, the CPU raises a “Divide error” exception, and the corresponding
exception handler sends a SIGFPE signal to the current process, which then takes the
necessary steps to recover or (if no signal handler is set for that signal) abort.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
current-&amp;gt;thread.error_code = error_code;
current-&amp;gt;thread.trap_no = vector;
force_sig(sig_number, current);
&lt;/pre&gt;
&lt;p&gt;The current process takes care of the signal right after the termination of the exception handler.&lt;/p&gt;
&lt;p&gt;The signal will be handled either in User Mode by the process’s own signal handler (if it exists) or in Kernel Mode. In the latter case, the kernel usually kills the process (see Chapter 11). The signals sent by the exception handlers are listed in Table 4-1.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id119"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt Handling(硬件产生的)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;this approach does not hold for interrupts, because they frequently arrive long after the process to which they are related&lt;/p&gt;
&lt;p&gt;前面方法不适用, 因为当前进程和中断并没有关系.&lt;/p&gt;
&lt;p&gt;三种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;I/O interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;An I/O device requires attention; the corresponding interrupt handler must query the device to determine the proper course of action. We cover this type of interrupt in the later section “I/O Interrupt Handling.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Timer interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Some timer, either a local APIC timer or an external timer, has issued an interrupt; this kind of interrupt tells the kernel that a fixed-time interval has elapsed.  These interrupts are handled mostly as I/O interrupts; we discuss the peculiar characteristics of timer interrupts in Chapter 6.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Interprocessor interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;A CPU issued an interrupt to another CPU of a multiprocessor system. We cover such interrupts in the later section “Interprocessor Interrupt Handling.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Table 4-3. An example of IRQ assignment to I/O devices:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
IRQ INT     Hardware device
0   32      Timer  Timer 必须是0号IRQ线.
1   33      Keyboard
2   34      PIC cascading
3   35      Second serial port
4   36      First serial port
6   38      Floppy disk
8   40      System clock
10  42      Network interface
11  43      USB port, sound card
12  44      PS/2 mouse
13  45      Mathematical coprocessor
14  46      EIDE disk controller’s first chain
15  47      EIDE disk controller’s second chain
&lt;/pre&gt;
&lt;div class="section" id="irq"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id120"&gt;4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQ在多处理器系统上的分发&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Linux 遵守对称多处理器模型(SMP), 这意味着， 内核对每个CPU都不应该有偏爱.&lt;/p&gt;
&lt;p&gt;内核试图以轮转的方式把来自硬件的IRQ信号在多个CPU之间分发, 所有CPU服务于I/O中断的执行时间片几乎相同.&lt;/p&gt;
&lt;p&gt;这是由硬件完成的, 但是有的硬件存在问题, Linux 使用kirqd的特殊内核线程来纠正对CPU进行的IRQ自动分配&lt;/p&gt;
&lt;div class="section" id="cpuirq"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id121"&gt;4.5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;CPU的IRQ亲和力&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;多APIC系统中, 通过修改APIC中断重定向表, 可以把指定中断发到特定的CPU上.&lt;/p&gt;
&lt;p&gt;kirqd内核线程定期执行 do_irq_balance() 函数, 它记录最近时间内每个cpu的终端次数, 如果发现负载不均衡, 就把IRQ从一个CPU转到另一个CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id122"&gt;4.5.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;例子:网卡多队列的中断绑定&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;如果大家用的万兆网卡跑linux或者nginx做大规模的负载均衡，那么肯定会遇到网卡中断占耗尽一个CPU的情况，会发现有一个ksoftirqd进程耗CPU非常厉害。这个时候就需要把万兆网卡的多个队列分别绑定到不同的核上。简单的在自己的笔记本上测试一下把单个中断绑定到指定CPU的方式。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
  0:       1120         78         73         89   IO-APIC-edge      timer
  1:       8372       8326       4485       1256   IO-APIC-edge      i8042
  8:          0          0          0          1   IO-APIC-edge      rtc0
  9:     919824     902422     945216     917506   IO-APIC-fasteoi   acpi
 12:      70724      74831      73671     130628   IO-APIC-edge      i8042
 14:    3836954     375689     389297     391612   IO-APIC-edge      ata_piix
 15:          0          0          0          0   IO-APIC-edge      ata_piix
 17:     228109        213     105882      40581   IO-APIC-fasteoi   ata_piix, HDA Intel
 19:    2129264    2483519    2266058    1798885   IO-APIC-fasteoi   ehci_hcd:usb2
 23:     548565     795696     859954     207891   IO-APIC-fasteoi   ehci_hcd:usb1
 27:        929      23923       1717       2311   PCI-MSI-edge      eth0
 28:   60226455    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
 29:    1156981    1577957    3826559    1869343   PCI-MSI-edge      i915&amp;#64;pci:0000:00:02.0
NMI:          0          0          0          0   Non-maskable interrupts
LOC:   88922568   93984839  101969505   97218270   Local timer interrupts
SPU:          0          0          0          0   Spurious interrupts
PMI:          0          0          0          0   Performance monitoring interrupts
PND:          0          0          0          0   Performance pending work
RES:   15963006   16173515   13643964   13852799   Rescheduling interrupts
CAL:     264642     254329     620940     555868   Function call interrupts
TLB:    2069687    1882570    1553231    1561555   TLB shootdowns
TRM:          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0   Threshold APIC interrupts
MCE:          0          0          0          0   Machine check exceptions
MCP:       1349       1345       1345       1345   Machine check polls
ERR:          0
MIS:          0
&lt;/pre&gt;
&lt;p&gt;通过两次cat:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237470    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237488    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237512    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
&lt;/pre&gt;
&lt;p&gt;这里发现28号中断(iwlagn) 只有CPU0这一列在增加, 说明28号中断绑定在CPU0上.&lt;/p&gt;
&lt;p&gt;比如要绑定到CPU3:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
echo 4 &amp;gt; /proc/irq/28/smp_affinity
&lt;/pre&gt;
&lt;p&gt;这里:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1 : CPU0
2 : CPU1
4 : CPU2
8 : CPU3
&lt;/pre&gt;
&lt;p&gt;再观察, 发现只有CPU2这一列在增加:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893707    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893727    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893740    8392505   PCI-MSI-edge      iwlagn
&lt;/pre&gt;
&lt;p&gt;一个核每秒能处理多少中断?&lt;/p&gt;
&lt;p&gt;我们的机器eth中断都绑定在CPU0上面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/interrupts | grep eth
  49:  273896202          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-0
  50: 2839469681          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-1
  51: 2443166700          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-2
  52:  947194873          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-3
  53: 3035084892          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-4
  54: 2586224100          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-5
  55: 1861561263          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-6
  56: 4154271481          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-7
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/interrupts | grep eth | awk '{A+=$2} END{print A}' &amp;amp;&amp;amp; sleep 10 &amp;amp;&amp;amp; cat /proc/interrupts | grep eth | awk '{A+=$2} END{print A}'
18144814547
18145846813 (10s)
&lt;/pre&gt;
&lt;p&gt;大约每秒10w个中断, 这个机器负载不重.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id26"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id123"&gt;4.5.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;把进程绑在核上&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ taskset -p 40234
pid 40234's current affinity mask: fff
&lt;/pre&gt;
&lt;p&gt;说明每个核都可能运行.&lt;/p&gt;
&lt;p&gt;设置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ taskset -p 7537
pid 7537's current affinity mask: f

ning&amp;#64;ning-laptop ~/test$ taskset -p e 7537
pid 7537's current affinity mask: f
pid 7537's new affinity mask: e

ning&amp;#64;ning-laptop ~/test$ taskset -p 7537
pid 7537's current affinity mask: e
&lt;/pre&gt;
&lt;p&gt;另外一种格式set:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
taskset -pc 0,3,7-11 700
&lt;/pre&gt;
&lt;p&gt;进程启动时指定CPU:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
taskset -c 1 ./redis-server ../redis.conf
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id27"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id124"&gt;4.5.1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;网卡多队列&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;对于万兆网卡, 一把提供多个中断号(多队列), 如果中断都绑在一个核上, 就悲剧了.&lt;/p&gt;
&lt;p&gt;有多个RSS队列.&lt;/p&gt;
&lt;p&gt;英特尔 X520万兆网卡里，最大可以同时支持128个队列，足以满足当前主流的服务器CPU配置。&lt;/p&gt;
&lt;p&gt;开启多队列:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sed -i 's/e1000/igb/g' /etc/modprobe.conf
echo &amp;quot;options igb RSS=8,8&amp;quot; &amp;gt;&amp;gt; /etc/modprobe.conf
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id28"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id125"&gt;4.5.1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;千兆网卡多队列&lt;/a&gt;&lt;/h5&gt;
&lt;div class="section" id="id29"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id126"&gt;4.5.1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;是否支持&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;&lt;a class="reference external" href="http://blog.csdn.net/turkeyzhou/article/details/7528182"&gt;http://blog.csdn.net/turkeyzhou/article/details/7528182&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#lspci -vvv
Ethernet controller的条目内容，如果有MSI-X &amp;amp;&amp;amp; Enable+ &amp;amp;&amp;amp; TabSize &amp;gt; 1，则该网卡是多队列网卡，如图4.4所示。

图4.4 lspci内容
Message Signaled Interrupts(MSI)是PCI规范的一个实现，可以突破CPU 256条interrupt的限制，使每个设备具有多个中断线变成可能，多队列网卡驱动给每个queue申请了MSI。MSI-X是MSI数组，Enable+指使能，TabSize是数组大小。

02:00.1 Ethernet controller: Intel Corporation: Unknown device 150e (rev 01)
        Subsystem: Intel Corporation: Unknown device 0000
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
        Status: Cap+ 66Mhz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR-
        Latency: 0, Cache Line Size 10
        Interrupt: pin B routed to IRQ 30
        Region 0: Memory at 94800000 (32-bit, non-prefetchable) [size=512K]
        Region 2: I/O ports at 5000 [size=32]
        Region 3: Memory at 94900000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: [40] Power Management version 3
                Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)
                Status: D0 PME-Enable- DSel=0 DScale=1 PME-
        Capabilities: [50] Message Signalled Interrupts: 64bit+ Queue=0/0 Enable-
                Address: 0000000000000000  Data: 0000
        Capabilities: [70] MSI-X: Enable+ Mask- TabSize=10
                Vector table: BAR=3 offset=00000000
                PBA: BAR=3 offset=00002000
        Capabilities: [a0] Express Endpoint IRQ 0
                Device: Supported: MaxPayload 512 bytes, PhantFunc 0, ExtTag-
                Device: Latency L0s &amp;lt;512ns, L1 &amp;lt;64us
                Device: AtnBtn- AtnInd- PwrInd-
                Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
                Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
                Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
                Link: Supported Speed unknown, Width x4, ASPM L0s L1, Port 2
                Link: Latency L0s &amp;lt;4us, L1 &amp;lt;8us
                Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
                Link: Speed unknown, Width x4
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [140] Device Serial Number ab-fb-2b-ff-ff-c7-0b-20
        Capabilities: [1a0] Unknown (23)
&lt;/pre&gt;
&lt;p&gt;还有种通用的方式，直接查看 interrupts 文件，看关键字 MSI 就知道了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# grep -i msi /proc/interrupts
&lt;/pre&gt;
&lt;p&gt;3.dmsg:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#  dmesg  | grep -i msi
hpet: hpet2 irq 72 for MSI
hpet: hpet3 irq 73 for MSI
hpet: hpet4 irq 74 for MSI
hpet: hpet5 irq 75 for MSI
hpet: hpet6 irq 76 for MSI
hpet: hpet7 irq 77 for MSI
megaraid_sas 0000:03:00.0: irq 78 for MSI/MSI-X
ahci 0000:00:1f.2: irq 79 for MSI/MSI-X
igb 0000:02:00.0: irq 80 for MSI/MSI-X
igb 0000:02:00.0: irq 81 for MSI/MSI-X
igb 0000:02:00.0: Using MSI-X interrupts. 1 rx queue(s), 1 tx queue(s)
igb 0000:02:00.1: irq 82 for MSI/MSI-X
igb 0000:02:00.1: irq 83 for MSI/MSI-X
igb 0000:02:00.1: Using MSI-X interrupts. 1 rx queue(s), 1 tx queue(s)
isci 0000:04:00.0: irq 84 for MSI/MSI-X
isci 0000:04:00.0: irq 85 for MSI/MSI-X
&lt;/pre&gt;
&lt;ol class="arabic" start="4"&gt;
&lt;li&gt;&lt;p class="first"&gt;ethtool:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# ethtool -S eth0 | tail -20
     os2bmc_tx_by_bmc: 0
     os2bmc_tx_by_host: 0
     os2bmc_rx_by_host: 0
     rx_errors: 0
     tx_errors: 0
     tx_dropped: 0
     rx_length_errors: 0
     rx_over_errors: 0
     rx_frame_errors: 0
     rx_fifo_errors: 0
     tx_fifo_errors: 0
     tx_heartbeat_errors: 0
     tx_queue_0_packets: 0
     tx_queue_0_bytes: 0
     tx_queue_0_restart: 0
     rx_queue_0_packets: 0
     rx_queue_0_bytes: 0
     rx_queue_0_drops: 0
     rx_queue_0_csum_err: 0
     rx_queue_0_alloc_failed: 0
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id30"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id127"&gt;4.5.1.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;开启多队列&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;首先要支持MSI-X (内核2.6.24+)&lt;/p&gt;
&lt;p&gt;Linux 网卡驱动一般只有两种 e1000 和 igb. (无线的是iwlagn):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#下面来自
本发行版包括两个适用于英特尔® 网卡的 Linux 基础驱动程序。这两个驱动程序的名称是 e1000 和 igb。为支持任何基于 82575 的网卡，必须安装 igb 驱动程序。其它所有网卡要求 e1000 驱动程序。
&lt;/pre&gt;
&lt;p&gt;先通过lspci看看当前用的是什么驱动:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
06:00.2 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation I350 Gigabit Network Connection
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Latency: 0, Cache Line Size: 64 bytes
        Interrupt: pin C routed to IRQ 18
        Region 0: Memory at a9a20000 (32-bit, non-prefetchable) [size=128K]
        Region 2: I/O ports at 1020 [size=32]
        Region 3: Memory at a9a84000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &amp;lt;access denied&amp;gt;
        Kernel driver in use: igb
        Kernel modules: igb

06:00.3 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation I350 Gigabit Network Connection
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Latency: 0, Cache Line Size: 64 bytes
        Interrupt: pin D routed to IRQ 19
        Region 0: Memory at a9a00000 (32-bit, non-prefetchable) [size=128K]
        Region 2: I/O ports at 1000 [size=32]
        Region 3: Memory at a9a80000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &amp;lt;access denied&amp;gt;
        Kernel driver in use: igb
        Kernel modules: igb
&lt;/pre&gt;
&lt;p&gt;igb是一个内核mod:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ lsmod | grep igb
igb                   143886  0
&lt;/pre&gt;
&lt;p&gt;看看这个mod支持啥参数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ modinfo igb
filename:       /lib/modules/2.6.32_1-12-0-0/kernel/drivers/net/igb/igb.ko
version:        4.0.17
license:        GPL
description:    Intel(R) Gigabit Ethernet Network Driver
author:         Intel Corporation, &amp;lt;e1000-devel&amp;#64;lists.sourceforge.net&amp;gt;
srcversion:     BCB38D2CABB33E0A1BA8385
...
depends:
vermagic:       2.6.32_1-12-0-0 SMP mod_unload modversions
parm:           InterruptThrottleRate:Maximum interrupts per second, per vector, (max 100000), default 3=adaptive (array of int)
parm:           IntMode:Change Interrupt Mode (0=Legacy, 1=MSI, 2=MSI-X), default 2 (array of int)
parm:           Node:set the starting node to allocate memory on, default -1 (array of int)
parm:           LLIPort:Low Latency Interrupt TCP Port (0-65535), default 0=off (array of int)
parm:           LLIPush:Low Latency Interrupt on TCP Push flag (0,1), default 0=off (array of int)
parm:           LLISize:Low Latency Interrupt on Packet Size (0-1500), default 0=off (array of int)
parm:           RSS:Number of Receive-Side Scaling Descriptor Queues (0-8), default 1, 0=number of cpus (array of int)
parm:           VMDQ:Number of Virtual Machine Device Queues: 0-1 = disable, 2-8 enable, default 0 (array of int)
parm:           max_vfs:Number of Virtual Functions: 0 = disable, 1-7 enable, default 0 (array of int)
parm:           MDD:Malicious Driver Detection (0/1), default 1 = enabled. Only available when max_vfs is greater than 0 (array of int)
parm:           QueuePairs:Enable Tx/Rx queue pairs for interrupt handling (0,1), default 1=on (array of int)
parm:           EEE:Enable/disable on parts that support the feature (array of int)
parm:           DMAC:Disable or set latency for DMA Coalescing ((0=off, 1000-10000(msec), 250, 500 (usec)) (array of int)
parm:           LRO:Large Receive Offload (0,1), default 0=off (array of int)
parm:           debug:Debug level (0=none, ..., 16=all) (int)
&lt;/pre&gt;
&lt;p&gt;通过调整IntMode, RSS, /etc/modules.conf or /etc/modprobe.conf&lt;/p&gt;
&lt;pre class="literal-block"&gt;
alias eth0 igb
alias eth1 igb
options igb IntMode=2,1 RSS=4,4
&lt;/pre&gt;
&lt;p&gt;On some kernels a reboot is required to switch between a single queue mode and multiqueue modes, or vice-versa.&lt;/p&gt;
&lt;p&gt;可以看这里的intel驱动文档:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://downloadmirror.intel.com/20927/eng/e1000.htm

IntMode:
    0-2 (0 = Legacy Int, 1 = MSI and 2 = MSI-X)
    IntMode controls allow load time control over the type of interrupt registered for by the driver. MSI-X is required for multiple queue support, and some kernels and combinations of kernel .config options will force a lower level of interrupt support. 'cat /proc/interrupts' will show different values for each type of interrupt.

RSS
    0-8:

    0 - Assign up to whichever is less, number of CPUS or number of queues
    X - Assign X queues where X is less than the maximum number of queues
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="proc-softirqs"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id128"&gt;4.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;/proc/softirqs&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ cat /proc/softirqs
                CPU0       CPU1       CPU2       CPU3
      HI:     185922     155733     322202     415150
   TIMER:  116015047  115689110  116242953  114220601
  NET_TX:  145507222    2411961    2579050    2645211
  NET_RX:   91563132   62827666   54938487   56726882
   BLOCK:   12582678     387007     389099     477301
BLOCK_IOPOLL:         39          0         14          1
 TASKLET:  268807160    8526283   10469002    7812433
   SCHED:   85717988   81576238   76344646   74394437
 HRTIMER:      38106      42778      28602      28957
     RCU:  110562375  107074305  102180377   98345842
&lt;/pre&gt;
&lt;div class="section" id="mpstat"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id129"&gt;4.5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mpstat&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
mpstat [ -P { cpu | ALL } ] [ -V ] [ interval [ count ] ]

 CPU
        Processor number. The keyword all indicates that statistics  are
        calculated as averages among all processors.

 ...
 %iowait
        Show  the percentage of time that the CPU or CPUs were idle dur-
        ing which the system had an outstanding disk I/O request.
 %irq (有多少时间花在处理中断)
        Show the percentage of time spent by the CPU or CPUs to  service
        interrupts.
 %soft
        Show  the percentage of time spent by the CPU or CPUs to service
        softirqs.  A softirq (software interrupt) is one  of  up  to  32
        enumerated software interrupts which can run on multiple CPUs at
        once.
 %idle
        Show the percentage of time that the CPU or CPUs were  idle  and
        the system did not have an outstanding disk I/O request.
 intr/s
        Show  the  total number of interrupts received per second by the
        CPU or CPUs.
&lt;/pre&gt;
&lt;p&gt;两种用法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#看总体情况
mpstat 1
#看每个CPU情况.
mpstat -P ALL 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="vmstat"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id130"&gt;4.5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;vmstat&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
$ vmstat  1
procs -----------memory---------- ---swap-- -----io----    --system--    ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo        in    cs  us sy id wa
 5  0 975864 3730960 237268 30782988    0    0     1   110      0     0  13  7 80  0
 1  0 975864 3731720 237268 30783940    0    0     0   412 111381 93381  5 10 85  0
 3  0 975864 3731780 237268 30784904    0    0     0   356 110127 92617  5 10 86  0
 5  0 975864 3729672 237268 30785796    0    0     0   324 109500 90538  5  9 86  0

 system的in这一列, 就是说每秒多少中断.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="softirqs-and-tasklets"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id131"&gt;4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Softirqs and Tasklets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;TODO: SoftIRQ(软中断) 和中断/异常是什么关系??&lt;/p&gt;
&lt;p&gt;ksoftirqd/n 内核线程:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
for(;;) {
    set_current_state(TASK_INTERRUPTIBLE);
    schedule();
    /* now in TASK_RUNNING state */
    while (local_softirq_pending()) {
        preempt_disable();
        do_softirq();
        preempt_enable();
        cond_resched();
    }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="work-queues"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id132"&gt;4.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Work Queues&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;工作队列实际上是这样一种概念:
硬件中断发生时, 把中断对应的处理函数加到一个队列里面, 再由一个 &lt;tt class="docutils literal"&gt;内核线程&lt;/tt&gt; 来对这个队列里面的每个函数, 逐一调用, 可以简化中断处理例程.&lt;/p&gt;
&lt;p&gt;这种方法和lighttpd对请求有事件来时的处理很像.&lt;/p&gt;
&lt;p&gt;预定义的Work Queue: &lt;tt class="docutils literal"&gt;events&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;内核线程:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;keventd(通用)&lt;/li&gt;
&lt;li&gt;kblockd(块设备层使用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="returning-from-interrupts-and-exceptions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id133"&gt;4.8&amp;nbsp;&amp;nbsp;&amp;nbsp;Returning from Interrupts and Exceptions&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ret_from_intr():        中断处理结束时&lt;/li&gt;
&lt;li&gt;ret_from_exception():   异常处理结束时&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c5-kernel-synchronization"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id134"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 Kernel Synchronization&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="how-the-kernel-services-requests"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id135"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;How the Kernel Services Requests&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以把内核看作不断对请求进行响应的服务器, 这些请求可能来自CPU上执行的进程, 也可能来自发出中断请求的外部设备.&lt;/p&gt;
&lt;div class="section" id="id31"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id136"&gt;5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核抢占&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;抢占内核的主要特点是: 一个在内核台运行的进程, 可能在执行内核函数期间被另一个进程取代.&lt;/li&gt;
&lt;li&gt;比如一个执行异常处理程序的进程, 用完了它的时间片, 如果内核是抢占的, 进程会立即被取代.
如果内核不是抢占的, 进程继续执行直到它执行完异常处理程序或主动放弃CPU.&lt;/li&gt;
&lt;li&gt;使内核可抢占的目的是: 减少用户态进程的分派延迟.&lt;/li&gt;
&lt;li&gt;内核抢占会引起不容忽视的开销, 所以2.6内核允许用户在编译的时候设置是否开启内核抢占.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个界定其实不严格.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronization-primitives"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id137"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronization Primitives(同步原语)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Table 5-2. Various types of synchronization techniques used by the kernel&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="21%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="47%" /&gt;
&lt;col width="18%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Technique&lt;/th&gt;
&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;Description&lt;/th&gt;
&lt;th class="head"&gt;Scope&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Per-CPU variables&lt;/td&gt;
&lt;td&gt;每CPU变量&lt;/td&gt;
&lt;td&gt;Duplicate a data Structure among the CPUs&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Atomic operation&lt;/td&gt;
&lt;td&gt;原子操作&lt;/td&gt;
&lt;td&gt;Atomic read-modify-write instruction to a counter&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Memory barrier&lt;/td&gt;
&lt;td&gt;内存屏障&lt;/td&gt;
&lt;td&gt;Avoid instruction reordering(避免指令重排)&lt;/td&gt;
&lt;td&gt;Local CPU or All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Spin lock&lt;/td&gt;
&lt;td&gt;自旋锁&lt;/td&gt;
&lt;td&gt;Lock with busy wait&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Semaphore&lt;/td&gt;
&lt;td&gt;信号量&lt;/td&gt;
&lt;td&gt;Lock with blocking wait (sleep)&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Seqlocks&lt;/td&gt;
&lt;td&gt;顺序锁&lt;/td&gt;
&lt;td&gt;Lock based on an access counter&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Local interrupt disabling&lt;/td&gt;
&lt;td&gt;本地中断禁止&lt;/td&gt;
&lt;td&gt;Forbid interrupt handling on a single CPU&lt;/td&gt;
&lt;td&gt;Local CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Local softirq disabling&lt;/td&gt;
&lt;td&gt;本地软中断禁止&lt;/td&gt;
&lt;td&gt;Forbid deferrable function handling on a single CPU&lt;/td&gt;
&lt;td&gt;Local CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Read-copy-update (RCU)&lt;/td&gt;
&lt;td&gt;通过指针而不是锁&lt;/td&gt;
&lt;td&gt;Lock-free access to shared data structures through pointers&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RCU 应该是指一些无锁数据结构操作方式,&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Read-copy-update&lt;/span&gt;&lt;/tt&gt; 这个术语是针对 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;读-修改-写(read-modify-write)&lt;/span&gt;&lt;/tt&gt; 这种常见的操作模式来说的.&lt;/p&gt;
&lt;div class="section" id="cpu"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id138"&gt;5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;每CPU变量&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;各个CPU的数据在硬件Cache中, 保证不会存放在同一个 &lt;tt class="docutils literal"&gt;Cache Line&lt;/tt&gt;, 对每CPU数组的并发访问不会导致Cache Line的窃用和失效.&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEFINE_PER_CPU(type, name) Statically allocates a per-CPU array called name of type data structures
per_cpu(name, cpu) Selects the element for CPU cpu of the per-CPU array name
&lt;/pre&gt;
&lt;p&gt;每个CPU的运行队列就是 &lt;tt class="docutils literal"&gt;每CPU变量&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id32"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id139"&gt;5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;原子操作&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;哪些操作是原子的&lt;/strong&gt; :&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;进行0次或1次 &lt;strong&gt;对齐&lt;/strong&gt; 内存访问的汇编指令(如int/指针赋值)
但是要注意, &lt;strong&gt;对齐&lt;/strong&gt; 很重要, 一个结构体中, 很容易不对齐, 静态堆/栈/malloc是否对齐 依赖编译器.&lt;/li&gt;
&lt;li&gt;如果读操作后, 写操作前没有其它处理器占用内存总线(如 &lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;dec&lt;/tt&gt; )&lt;/li&gt;
&lt;li&gt;操作码有lock前缀(控制单元此时锁定内存总线, 直到这条指令执行完成)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; : C代码中, 不能保证编译器会将 &lt;tt class="docutils literal"&gt;a=a+1&lt;/tt&gt; 甚至 &lt;tt class="docutils literal"&gt;a++&lt;/tt&gt; 这样的操作使用一个原子指令 (但是赋值是)&lt;/p&gt;
&lt;p&gt;原子操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
atomic_read(v)
atomic_set(v)
atomic_add(v)
atomic_add_return(v)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id33"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id140"&gt;5.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障&amp;amp;内存屏障&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;CPU的多发射会导致指令重排, 如果放在同步原语之后的一条指令在同步原语之前执行, 就悲剧了.&lt;/p&gt;
&lt;div class="section" id="optimization-barrier"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id141"&gt;5.2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障(optimization barrier) 原语保证编译程序不会混淆原语前后的汇编指令.&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Linux中, 优化屏障:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
barrier()
&lt;/pre&gt;
&lt;p&gt;展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
asm volatile(&amp;quot;&amp;quot;:::&amp;quot;memory&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;优化屏障&lt;/tt&gt; 并不保证不使当前CPU把汇编指令混在一起执行. -- 这是 &lt;tt class="docutils literal"&gt;内存屏障&lt;/tt&gt; 的作用&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id34"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id142"&gt;5.2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;内存屏障确保原语之后的操作开始执行之前, 原语之前的操作已完成.&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;在80x86处理器中, 下列种类的汇编指令是串行的, 他们起到 &lt;tt class="docutils literal"&gt;内存屏障&lt;/tt&gt; 的作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;对I/O端口操作的所有指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;lock前缀的所有指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;写控制寄存器, 系统寄存器或调试寄存器的指令(cli, sti)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Pentium 4中引入的&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;lfence: 读内存屏障, 仅作用于读内存的指令&lt;/li&gt;
&lt;li&gt;sfence: 写内存屏障, 仅作用于写内存的指令&lt;/li&gt;
&lt;li&gt;mfence: 读-写内存屏障.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;少数汇编指令, 如iret.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux使用6个内存屏障原语, 它们同时也被作为优化屏障:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
mb()        Memory barrier for MP and UP
rmb()       Read memory barrier for MP and UP
wmb()       Write memory barrier for MP and UP
smp_mb()    Memory barrier for MP only
smp_rmb()   Read memory barrier for MP only
smp_wmb()   Write memory barrier for MP only
&lt;/pre&gt;
&lt;p&gt;rmb 可能展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
asm volatile(&amp;quot;lfence&amp;quot;)
asm volatile(&amp;quot;lock;addl $0,0(%%esp)&amp;quot;:::&amp;quot;memory&amp;quot;)
lock; addl $0,0(%%esp)
&lt;/pre&gt;
&lt;p&gt;wmb可能展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
barrier()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id35"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id143"&gt;5.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;自旋锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;锁里面最简单的一种, 忙等锁.&lt;/p&gt;
&lt;p&gt;很多自旋锁只会锁1ms时间, 所以, 自旋锁不会造成很大的浪费.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
spin_lock_init() Set the spin lock to 1 (unlocked)
spin_lock() Cycle until spin lock becomes 1 (unlocked), then set it to 0 (locked)
spin_unlock() Set the spin lock to 1 (unlocked)
spin_unlock_wait() Wait until the spin lock becomes 1 (unlocked)
spin_is_locked() Return 0 if the spin lock is set to 1 (unlocked); 1 otherwise
spin_trylock() Set the spin lock to 0 (locked), and return 1 if the previous value of the lock was 1; 0 oth- erwise
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id36"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id144"&gt;5.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;读/写自旋锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;目的是提高内核的并行能力.&lt;/p&gt;
&lt;p&gt;允许多个读并发.&lt;/p&gt;
&lt;p&gt;原来:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    读  写
读   0   0
写   0   0
&lt;/pre&gt;
&lt;p&gt;现在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    读  写
读   1   0
写   0   0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id37"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id145"&gt;5.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;顺序锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;SeqLock, 它和读写自旋锁很像, 只是它赋予写者更高的优先级,&lt;/p&gt;
&lt;p&gt;即使有读者正在读, 也允许写者继续写,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这种策略的好处是写者永远不会等待(除非有另一个写者正在写),&lt;/li&gt;
&lt;li&gt;缺点是读者必须反复读相同的数据, 直到它获得有效的副本.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个读者在读前后两次读 &lt;tt class="docutils literal"&gt;顺序计数器&lt;/tt&gt; , 如果两次读到的值不相同, 说明新的写者已经开始写并增加了 &lt;tt class="docutils literal"&gt;顺序计数器&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;p237, 在内核更新Time的时候使用了顺序锁, 这时读者其实可以只读一次, 因为取到旧时间关系不大.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rcu"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id146"&gt;5.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;读-拷贝-更新 (RCU通过指针而不是锁)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不用锁:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RCU只保护被动态分配 通过指针引用的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读者几乎不做任何事情来防止竞争条件, 得靠写者.&lt;/p&gt;
&lt;p&gt;写着要更新数据结构时, 生成整个数据结构的副本, 写者修改这个副本, 修改完成后改变指针.&lt;/p&gt;
&lt;p&gt;改变指针是一个原子操作(我们在cruiser中需要动态加载配置的时候就是这样做的)&lt;/p&gt;
&lt;p&gt;写着修改指针后, 不能马上释放数据结构的旧副本, 因为写着修改时, 可能有读者拿着老指针呢.!!! &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--从前自己改这个模块的时候根本没意识到,&lt;/span&gt; 只是模仿了浩哥的代码&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id38"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id147"&gt;5.2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;信号量&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;类似于自旋锁, 但是在锁的时候不是自旋, 而是挂起.&lt;/p&gt;
&lt;p&gt;信号量结构:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct semphore{
    atomic_t count;
    wait: 等待队列
    sleepers: 是否有进程在信号量上睡眠
}
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;__up&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;__down&lt;/tt&gt;&lt;/p&gt;
&lt;div class="section" id="completion"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id148"&gt;5.2.8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;补充原语(completion)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;类似信号量,&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id39"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id149"&gt;5.2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;本地中断禁止&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id40"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id150"&gt;5.2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;本地软中断禁止&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronizing-accesses-to-kernel-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id151"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronizing Accesses to Kernel Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;链表例子.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="examples-of-race-condition-prevention"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id152"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Examples of Race Condition Prevention&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;大内核锁.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c6-timing-measurements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id153"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;c6 Timing Measurements&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="clock-and-timer-circuits"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id154"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Clock and Timer Circuits (几种硬件计时器)&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;实时时钟 RTC (CMOS时间 )&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;和CMOS在一个芯片上, 自带电池&lt;/li&gt;
&lt;li&gt;频率在2-8192Hz之间.&lt;/li&gt;
&lt;li&gt;IRQ8&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;时间戳计数器 TSC&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;64位&lt;/li&gt;
&lt;li&gt;每个时钟信号来加1&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;可编程间隔定时器 PIT (8254芯片)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Linux编程为 &lt;tt class="docutils literal"&gt;大约&lt;/tt&gt; 1000Hz, 向IRQ0发中断.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;CPU本地定时器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;高精度事件定时器 HPET&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;8个32/64位独立计数器, 硬件中还不普遍.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;PCPI电源管理定时器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核启动时会选择最好的一个计时器&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-linux-timekeeping-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id155"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Linux Timekeeping Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核使用两个函数:&lt;/p&gt;
&lt;p&gt;time()
gettimeofday()&lt;/p&gt;
&lt;p&gt;数据结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;timer_opts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;描述硬件定时器(每种硬件一个这个结构)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;jiffies&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;每个时钟中断加一, &lt;strong&gt;内核就是设置为1000Hz&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;80x86中是32位, (2**32/80000*1000)大约50天回绕到0, 内核处理了溢出.&lt;/li&gt;
&lt;li&gt;jiffies 被初始化为0xfffb6c20(-300,000) 系统启动5分钟后回到0(使得哪些不对jiffies做校验的bug及早发现)&lt;/li&gt;
&lt;li&gt;jiffies通过连接器被转换为一个64为计数器的低32位, 这个64位计数器: jiffies_64&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;xtime (timespec类型 )&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;tv_sec (timestamp的秒数)&lt;/li&gt;
&lt;li&gt;tv_nsec (纳秒)&lt;/li&gt;
&lt;li&gt;初始化时用get_coms_time() 函数从 实时时钟读取.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id41"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id156"&gt;6.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;时钟中断时处理&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;需要判断是否丢失时钟中断.&lt;/li&gt;
&lt;li&gt;计算当前系统的负载(Load)&lt;/li&gt;
&lt;li&gt;更新xtime&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id42"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id157"&gt;6.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;系统负载&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;单处理器: 0意味着没有活跃的进程(除了idle), 1意味着一个单独的进程100%占有cpu.&lt;/p&gt;
&lt;p&gt;大于1说明有几个进程处于running, 共享CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id43"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id158"&gt;6.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;监管内核代码&lt;/a&gt;&lt;/h5&gt;
&lt;div class="section" id="readprofiler-hot-spot"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id159"&gt;6.2.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;readprofiler, 用于确定内核热点(hot spot).&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;监管器基于非常简单的 &lt;tt class="docutils literal"&gt;蒙特卡洛算法&lt;/tt&gt;, 每次时钟中断发生时, 内核确定中断是否发生在内核态, 如果是, 内核从堆栈取出eip寄存器值, 从而确定中断发生前内核正在做什么. 形成采样数据.&lt;/p&gt;
&lt;p&gt;启动内核时需要用 profile=N来开启prifile&lt;/p&gt;
&lt;p&gt;数据可以从 &lt;tt class="docutils literal"&gt;/proc/profile&lt;/tt&gt; 读取, 用 &lt;tt class="docutils literal"&gt;readprofile&lt;/tt&gt; 命令更方便&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="oprofile"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id160"&gt;6.2.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;oprofile&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;此外, 内核提供另一个监管器: &lt;tt class="docutils literal"&gt;oprofile&lt;/tt&gt;, 还可一监控用户态程序热点.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id44"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id161"&gt;6.2.1.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;检测死锁&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;通过非屏蔽中断NMI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id45"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id162"&gt;6.2.1.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;蒙特卡洛:&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;蒙特卡罗方法又称统计模拟法、随机抽样技术，是一种随机模拟方法，以概率和统计理论方法为基础的一种计算方法，是使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。&lt;/p&gt;
&lt;p&gt;这个词构忽悠,其实就是随机采样的意思.&lt;/p&gt;
&lt;p&gt;提出：&lt;/p&gt;
&lt;p&gt;蒙特卡罗方法于20世纪40年代美国在第二次世界大战中研制原子弹的“曼哈顿计划”计划的成员S.M.乌拉姆和J.冯·诺伊曼首先提出。数学家冯·诺伊曼用驰名世界的赌城—摩纳哥的Monte Carlo—来命名这种方法，为它蒙上了一层神秘色彩。在这之前，蒙特卡罗方法就已经存在。1777年，法国数学家布丰（Georges Louis Leclere de Buffon，1707—1788）提出用投针实验的方法求圆周率π。这被认为是蒙特卡罗方法的起源。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-the-time-and-date"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id163"&gt;6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating the Time and Date&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-system-statistics"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id164"&gt;6.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating System Statistics&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="software-timers-and-delay-functions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id165"&gt;6.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Software Timers and Delay Functions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-timing-measurements"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id166"&gt;6.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Timing Measurements&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
time()
gettimeofday()
adjtimex()
settimer() / alarm()
&lt;/pre&gt;
&lt;p&gt;posix 相关系统调用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
clock_gettime()
...
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c7-process-scheduling"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id167"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;c7 Process Scheduling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;亲和性:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sched_setaffinity()
sched_getaffinity()
&lt;/pre&gt;
&lt;div class="section" id="scheduling-policy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id168"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Scheduling Policy&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-scheduling-algorithm"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id169"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Scheduling Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="data-structures-used-by-the-scheduler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id170"&gt;7.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Data Structures Used by the Scheduler&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;140个双向链表, 代表140个优先级,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="functions-used-by-the-scheduler-schedule"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id171"&gt;7.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Functions Used by the Scheduler(schedule)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;schedule 执行的前半部分和后半部分在两个进程中, 中间还有一段时间不属于任何一个进程.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id46"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id172"&gt;7.5&amp;nbsp;&amp;nbsp;&amp;nbsp;多处理器系统中 执行队列的平衡&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 一直使用对称多处理器模型(), 内核不应该对任何一个CPU有偏好(有点分布式系统中无master的意思)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;超线程:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;当前线程在访问内存的间隙, 处理器可以利用机器周期去执行另外一个线程,&lt;/li&gt;
&lt;li&gt;一个超线程的物理CPU可以被linux看作是几个逻辑CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;NUMA&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;把CPU和RAM以本地节点为单位分组(通常一个节点包括一个CPU和几个RAM芯片)&lt;/li&gt;
&lt;li&gt;CPU访问本地RAM非常快, 防伪其它节点就非常慢.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一般来说, 一个进程总是在一个CPU上执行, 但是也会在CPU之间迁移.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;任何一个可运行的进程都不会同时出现在两个或多个CPU的运行队列中, 一个保持可运行状态的进程通常被限制在一个固定的CPU上.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;内核周期性的检查运行队列是否平衡, 必要时迁移.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-scheduling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id173"&gt;7.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Scheduling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c8-memory-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id174"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 Memory Management&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="page-frame-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id175"&gt;8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Frame Management&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;页描述符大小为32字节(放在mem_map中), 用于描述一个4k大小的页, 所以内存的(32/4k=0.8%)  的内存用于存放页描述符(被内核使用)&lt;/p&gt;
&lt;div class="section" id="numa"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id176"&gt;8.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;非一致内存访问(NUMA)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Non-Uniform Memory Access, 对比与80x86体系结构的UMA模型(一致性内存访问)&lt;/p&gt;
&lt;p&gt;NUMA中, 某个CPU对不同内存单元的访问时间可能不一样, 系统中的CPU和内存被划分为几个节点. 一个节点内的cpu访问自己节点的内存很快, 跨节点访问就很慢.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-area-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id177"&gt;8.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Area Management&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;slab分配器: 类似于 预分配/对象池 的概念&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把内存去看作对象, 有构造/析构函数.&lt;/li&gt;
&lt;li&gt;内核反复申请同一类型的内存区.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;slab着色 - 解决高速缓存颠簸的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="noncontiguous-memory-area-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id178"&gt;8.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Noncontiguous Memory Area Management&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c9-process-address-space"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id179"&gt;9&amp;nbsp;&amp;nbsp;&amp;nbsp;c9. Process Address Space&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-processs-address-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id180"&gt;9.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Process’s Address Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-memory-descriptor"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id181"&gt;9.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Memory Descriptor&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-regions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id182"&gt;9.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Regions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault-exception-handler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id183"&gt;9.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Fault Exception Handler&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-and-deleting-a-process-address-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id184"&gt;9.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating and Deleting a Process Address Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-the-heap"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id185"&gt;9.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing the Heap&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c10-system-calls"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id186"&gt;10&amp;nbsp;&amp;nbsp;&amp;nbsp;c10 System Calls&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="posix-apis-and-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id187"&gt;10.1&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX APIs and System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-call-handler-and-service-routines"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id188"&gt;10.2&amp;nbsp;&amp;nbsp;&amp;nbsp;System Call Handler and Service Routines&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="entering-and-exiting-a-system-call"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id189"&gt;10.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Entering and Exiting a System Call&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="parameter-passing"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id190"&gt;10.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Parameter Passing&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel-wrapper-routines"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id191"&gt;10.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Wrapper Routines&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c11-signals"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id192"&gt;11&amp;nbsp;&amp;nbsp;&amp;nbsp;c11. Signals&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-role-of-signals"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id193"&gt;11.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of Signals&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="generating-a-signal"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id194"&gt;11.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Generating a Signal&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="delivering-a-signal"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id195"&gt;11.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Delivering a Signal&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-signal-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id196"&gt;11.4&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Signal Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c12-the-virtual-filesystem"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id197"&gt;12&amp;nbsp;&amp;nbsp;&amp;nbsp;c12 The Virtual Filesystem&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-role-of-the-virtual-filesystem-vfs"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id198"&gt;12.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of the Virtual Filesystem (VFS)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="vfs-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id199"&gt;12.2&amp;nbsp;&amp;nbsp;&amp;nbsp;VFS Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-types"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id200"&gt;12.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Types&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id201"&gt;12.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="pathname-lookup"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id202"&gt;12.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Pathname Lookup&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="implementations-of-vfs-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id203"&gt;12.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementations of VFS System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="file-locking"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id204"&gt;12.7&amp;nbsp;&amp;nbsp;&amp;nbsp;File Locking&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c13-i-o-architecture-and-device-drivers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id205"&gt;13&amp;nbsp;&amp;nbsp;&amp;nbsp;c13. I/O Architecture and Device Drivers&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="i-o-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id206"&gt;13.1&amp;nbsp;&amp;nbsp;&amp;nbsp;I/O Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-device-driver-model"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id207"&gt;13.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Device Driver Model&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="device-files"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id208"&gt;13.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Files&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id209"&gt;13.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="character-device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id210"&gt;13.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Character Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c14-block-device-drivers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id211"&gt;14&amp;nbsp;&amp;nbsp;&amp;nbsp;c14. Block Device Drivers&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="block-devices-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id212"&gt;14.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Devices Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-generic-block-layer"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id213"&gt;14.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Generic Block Layer&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-i-o-scheduler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id214"&gt;14.3&amp;nbsp;&amp;nbsp;&amp;nbsp;The I/O Scheduler&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="block-device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id215"&gt;14.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="opening-a-block-device-file"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id216"&gt;14.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Opening a Block Device File&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c15-the-page-cache"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id217"&gt;15&amp;nbsp;&amp;nbsp;&amp;nbsp;c15. The Page Cache&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-page-cache"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id218"&gt;15.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Cache&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="storing-blocks-in-the-page-cache"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id219"&gt;15.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Storing Blocks in the Page Cache&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-dirty-pages-to-disk"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id220"&gt;15.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Writing Dirty Pages to Disk&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-sync-fsync-and-fdatasync-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id221"&gt;15.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The sync( ), fsync( ), and fdatasync() System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c16-accessing-files"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id222"&gt;16&amp;nbsp;&amp;nbsp;&amp;nbsp;c16. Accessing Files&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="reading-and-writing-a-file"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id223"&gt;16.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Reading and Writing a File&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-mapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id224"&gt;16.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Mapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="direct-i-o-transfers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id225"&gt;16.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Direct I/O Transfers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="asynchronous-i-o"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id226"&gt;16.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Asynchronous I/O&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c17-page-frame-reclaiming"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id227"&gt;17&amp;nbsp;&amp;nbsp;&amp;nbsp;c17. Page Frame Reclaiming&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-page-frame-reclaiming-algorithm"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id228"&gt;17.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Frame Reclaiming Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="reverse-mapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id229"&gt;17.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Reverse Mapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="implementing-the-pfra"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id230"&gt;17.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing the PFRA&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="swapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id231"&gt;17.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Swapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c18-the-ext2-and-ext3-filesystems"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id232"&gt;18&amp;nbsp;&amp;nbsp;&amp;nbsp;c18. The Ext2 and Ext3 Filesystems&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="general-characteristics-of-ext2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id233"&gt;18.1&amp;nbsp;&amp;nbsp;&amp;nbsp;General Characteristics of Ext2&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-disk-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id234"&gt;18.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Disk Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-memory-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id235"&gt;18.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Memory Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-the-ext2-filesystem"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id236"&gt;18.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating the Ext2 Filesystem&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-methods"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id237"&gt;18.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Methods&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-ext2-disk-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id238"&gt;18.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing Ext2 Disk Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-ext3-filesystem"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id239"&gt;18.7&amp;nbsp;&amp;nbsp;&amp;nbsp;The Ext3 Filesystem&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c19-process-communication"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id240"&gt;19&amp;nbsp;&amp;nbsp;&amp;nbsp;c19. Process Communication&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pipes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id241"&gt;19.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Pipes&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="fifos"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id242"&gt;19.2&amp;nbsp;&amp;nbsp;&amp;nbsp;FIFOs&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-v-ipc"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id243"&gt;19.3&amp;nbsp;&amp;nbsp;&amp;nbsp;System V IPC&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="posix-message-queues"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id244"&gt;19.4&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX Message Queues&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c20-program-execution"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id245"&gt;20&amp;nbsp;&amp;nbsp;&amp;nbsp;c20. Program Execution&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="executable-files"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id246"&gt;20.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Files&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="executable-formats"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id247"&gt;20.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Formats&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="execution-domains"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id248"&gt;20.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Execution Domains&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-exec-functions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id249"&gt;20.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The exec Functions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id47"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id250"&gt;21&amp;nbsp;&amp;nbsp;&amp;nbsp;总结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;其实中文版翻译还算可以, 中文看不懂的地方, 去看英文版, 发现一样看不懂.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不过看英文版映像深一些.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;读这本书, 需要和源码一起看&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如c2 内存寻址 里面详细列出了页表操作的宏定义, 读的时候就每必要细究.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;之前一致理解有内核和用户进程这两种东西&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;实际上, 应该是一个进程, 可以运行在用户态, 也可以运行在内核态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;当发起系统调用的时候, 进入内核态, 切换栈为内核栈,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;用户态只能访问本进程的部分线性地址空间.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;进入内核态后, 可以访问全部线性地址空间.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;还有一些进程是只在内核态运行的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;内核在运行中的代码形态(CPU执行内核代码的时候)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;初始化系统&lt;/li&gt;
&lt;li&gt;普通进程调用系统调用, 进入内核态, 用该进程的内核堆栈执行.&lt;/li&gt;
&lt;li&gt;几个内核线程&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;c5 Kernel Synchronization&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;对各种锁的介绍挺全面.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;自旋锁是锁里面最简单的一种,&lt;/li&gt;
&lt;li&gt;信号量是自旋锁的一种改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;对内存屏障的介绍, 看一遍就懂了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>vimcasts笔记</title><link href="/vim-vimcasts.html" rel="alternate"></link><updated>2013-12-05T11:13:53+08:00</updated><author><name>ning</name></author><id>tag:,2013-12-05:vim-vimcasts.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#show-invisibles" id="id8"&gt;#1.Show invisibles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tabs-and-spaces" id="id9"&gt;#2.Tabs and Spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#whitespace-preferences-and-filetypes" id="id10"&gt;#3.Whitespace preferences and filetypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tidying-whitespace" id="id11"&gt;#4.Tidying whitespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#indentation-commands" id="id12"&gt;#5.Indentation commands&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id13"&gt;缩进规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-buffers" id="id14"&gt;#6.Working with buffers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-windows-5-32" id="id15"&gt;#7 Working with windows (5:32)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-tabs-3-17" id="id16"&gt;#8 Working with tabs (3:17)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-to-use-tabs-5-28" id="id17"&gt;#9 How to use tabs (5:28)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-creating-the-vimcasts-logo-as-ascii-art-5-47" id="id18"&gt;#10 &amp;lt;nice-demo&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-the-changelist-and-jumplist-3-21" id="id19"&gt;#11 Using the changelist and jumplist (3:21)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#modal-editing-undo-redo-and-repeat-5-26" id="id20"&gt;#12 Modal editing: undo, redo and repeat (5:26)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cleaning-up-with-vim-0-36" id="id21"&gt;#13 Cleaning up with Vim (0:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-edit-command-3-50" id="id22"&gt;#14 The :edit command (3:50)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-file-explorer-5-36" id="id23"&gt;#15 The file explorer (5:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#soft-wrapping-text-4-54" id="id24"&gt;#16 Soft wrapping text (4:54)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hard-wrapping-text-5-23" id="id25"&gt;#17 Hard wrapping text (5:23)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#formatting-text-with-par-5-12" id="id26"&gt;#18 Formatting text with par (5:12)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#spell-checking-5-42" id="id27"&gt;#19 Spell checking (5:42)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#running-vim-within-irb-4-35" id="id28"&gt;#20 Running Vim within IRB (4:35)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-converting-markdown-to-struct-ured-html-with-a-macro-9-25" id="id29"&gt;#21 &amp;lt;nice-demo&amp;gt;Converting markdown to struct_ured HTML with a macro (9:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-selecting-columns-with-visual-block-mode-4-21" id="id30"&gt;#22 &amp;lt;nice-demo&amp;gt;Selecting columns with visual block mode (4:21)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#converting-haml-to-erb-with-vim-macros-7-36" id="id31"&gt;#23 Converting HAML to ERB with Vim macros (7:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-your-vimrc-file-on-the-fly-2-51" id="id32"&gt;#24 Updating your vimrc file on the fly (2:51)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-colorschemes-for-vim-9-44" id="id33"&gt;#25 Creating colorschemes for Vim (9:44)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bubbling-text-6-23" id="id34"&gt;#26 Bubbling text (6:23)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronizing-plugins-with-git-submodules-and-pathogen-9-24" id="id35"&gt;#27 Synchronizing plugins with git submodules and pathogen (9:24)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#refining-search-patterns-with-the-command-line-window-7-51" id="id36"&gt;#28 Refining search patterns with the command-line window (7:51)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aligning-text-with-tabular-vim-5-11" id="id37"&gt;#29 Aligning text with Tabular.vim (5:11)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#undo-branching-and-gundo-vim-6-30" id="id38"&gt;#30 Undo branching and Gundo.vim (6:30)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id39"&gt;例1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id40"&gt;例2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#undo-branch" id="id41"&gt;undo branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gundo" id="id42"&gt;gundo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-a-complement-to-command-line-git-8-27" id="id43"&gt;#31 Fugitive.vim - a complement to command line git (8:27)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-working-with-the-git-index-11-41" id="id44"&gt;#32 Fugitive.vim - working with the git index (11:41)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-resolving-merge-conflicts-with-vimdiff-11-35" id="id45"&gt;#33 Fugitive.vim - resolving merge conflicts with vimdiff (11:35)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-browsing-the-git-object-database-9-45" id="id46"&gt;#34 Fugitive.vim - browsing the git object database (9:45)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-exploring-the-history-of-a-git-repository-10-04" id="id47"&gt;#35 Fugitive.vim - exploring the history of a git repository (10:04)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vimgolf-prime-numbers-6-53" id="id48"&gt;#36 VimGolf - Prime Numbers (6:53)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-to-fold-8-49" id="id49"&gt;#37 How to fold (8:49)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#writing-a-custom-fold-expression-12-07" id="id50"&gt;#38 Writing a custom fold expression (12:07)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#profiling-vimscript-performance-8-09" id="id51"&gt;#39 Profiling Vimscript performance (8:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#long-range-line-duplication-6-31" id="id52"&gt;#40 Long-range line duplication (6:31)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#meet-the-arglist-4-57" id="id53"&gt;#41 Meet the arglist (4:57)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#populating-the-arglist-5-31" id="id54"&gt;#42 Populating the arglist (5:31)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-argdo-to-change-multiple-files-5-40" id="id55"&gt;#43 Using :argdo to change multiple files (5:40)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#search-multiple-files-with-vimgrep-7-25" id="id56"&gt;#44 Search multiple files with :vimgrep (7:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#project-wide-find-and-replace-6-25" id="id57"&gt;#45 Project-wide find and replace (6:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#search-for-the-selected-text-4-39" id="id58"&gt;#46 Search for the selected text (4:39)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#smart-search-with-subvert-5-33" id="id59"&gt;&amp;#64;47 Smart search with :Subvert (5:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#supercharged-substitution-with-subvert-7-09" id="id60"&gt;&amp;#64;48 Supercharged substitution with :Subvert (7:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#enhanced-abbreviations-with-abolish-3-09" id="id61"&gt;&amp;#64;49 Enhanced abbreviations with :Abolish (3:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#an-introduction-to-vspec-7-15" id="id62"&gt;#50 An introduction to vspec (7:15)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#simple-operations-using-the-default-register-4-07" id="id63"&gt;#51 Simple operations using the default register (4:07)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#meet-the-yank-register-4-29" id="id64"&gt;#52 Meet the yank register (4:29)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-vim-s-named-registers-3-29" id="id65"&gt;#53 Using Vim's named registers (3:29)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pasting-from-visual-mode-3-33" id="id66"&gt;#54 Pasting from Visual mode (3:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pasting-from-insert-mode-4-15" id="id67"&gt;#55 Pasting from Insert mode (4:15)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#simple-calculations-with-vim-s-expression-register-4-02" id="id68"&gt;#56 Simple calculations with Vim's expression register (4:02)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#evaluating-scripts-with-vim-s-expression-register-3-56" id="id69"&gt;#57 Evaluating scripts with Vim's expression register (3:56)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#accessing-the-system-clipboard-from-vim-4-48" id="id70"&gt;#58 Accessing the system clipboard from Vim (4:48)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-vim-s-paste-mode-with-the-system-paste-command-4-25" id="id71"&gt;#59 Using Vim's paste mode with the system paste command (4:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#comparing-buffers-with-vimdiff-4-16" id="id72"&gt;#60 Comparing buffers with vimdiff (4:16)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-repeatable-mappings-with-repeat-vim-4-33" id="id73"&gt;#61 Creating repeatable mappings with repeat.vim (4:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id74"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ning-vim-modline" id="id75"&gt;ning: vim modline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id76"&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;关于&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个系列视频来自:
&lt;a class="reference external" href="http://vimcasts.org/episodes/archive"&gt;http://vimcasts.org/episodes/archive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者每个月会录1-5个视频放出来.从2010年坚持到现在.&lt;/p&gt;
&lt;p&gt;这个网站的作者经常进行 vim 课程, $250 每次.(4小时)
他也是 &amp;lt;Practical Vim&amp;gt; 的作者(&lt;strong&gt;豆瓣8.9分&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;对tabstop 不熟悉的, 建议观看1,2,4&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="show-invisibles"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;#1.Show invisibles&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;显示不可见字符:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set list
set nolist
&lt;/pre&gt;
&lt;p&gt;修改使用的不可见字符样式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tabs-and-spaces"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;#2.Tabs and Spaces&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;tabstop:&lt;/th&gt;&lt;td class="field-body"&gt;tab符宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;softtabstop:&lt;/th&gt;&lt;td class="field-body"&gt;使用&amp;lt;-键删除的时候, 删除多少宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;shiftwidth:&lt;/th&gt;&lt;td class="field-body"&gt;用&amp;gt;, &amp;lt;缩进的时候, 插入多宽.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;expandtab:&lt;/th&gt;&lt;td class="field-body"&gt;输入的tab, shift 时, 都替换为空格.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;默认值:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tabstop = 8
softtabstop = 0
shiftwidth = 8
no expandtab
&lt;/pre&gt;
&lt;p&gt;不一样会很混乱&lt;/p&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;保证 tabstop == softtabstop == shiftwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;retab&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="whitespace-preferences-and-filetypes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;#3.Whitespace preferences and filetypes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用autocommand实现对python 和Makefile 不同的缩进设置.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tidying-whitespace"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;#4.Tidying whitespace&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;convert between tabs and spaces.&lt;/li&gt;
&lt;li&gt;strip trailing whitespace,&lt;/li&gt;
&lt;li&gt;how to remove blank lines from a file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;noexpandtab 的时候, &lt;cite&gt;retab&lt;/cite&gt; 把space 变成tab,
expandtab 的时候  &lt;cite&gt;retab&lt;/cite&gt; 把tab变成space.&lt;/p&gt;
&lt;p&gt;不错的函数例子, 保存当前位置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! &amp;lt;SID&amp;gt;StripTrailingWhitespaces()
    &amp;quot; Preparation: save last search, and cursor position.
    let _s=&amp;#64;/
    let l = line(&amp;quot;.&amp;quot;)
    let c = col(&amp;quot;.&amp;quot;)
    &amp;quot; Do the business:
    %s/\s\+$//e
    &amp;quot; Clean up: restore previous search history, and cursor position
    let &amp;#64;/=_s
    call cursor(l, c)
endfunction
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除空白行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:g/^$/d
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;g命令&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;:g 表示范围 &lt;tt class="docutils literal"&gt;global command&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;d 是一个Ex command&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="indentation-commands"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;#5.Indentation commands&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;就是讲&amp;gt;&amp;gt; 和 &amp;lt;&amp;lt;
还有:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vmap &amp;lt;D-[&amp;gt; &amp;lt;gv (我用tab和shift-tab)
vmap &amp;lt;D-]&amp;gt; &amp;gt;gv
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;N模式下用 &lt;tt class="docutils literal"&gt;==&lt;/tt&gt;, V模式下用 &lt;tt class="docutils literal"&gt;=&lt;/tt&gt; 格式化,&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;vi}&lt;/tt&gt; 选择{}中的代码.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;=i}&lt;/tt&gt; 格式化{}中的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;缩进规则&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;~/.vim/indent/python.vim&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-buffers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;#6.Working with buffers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;讲的不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:buffers
1 #    &amp;quot;.recent&amp;quot;                      line 2        # 是上一个活跃buffer
2      &amp;quot;./notes/misc/vim_usage.rst&amp;quot;   line 217
3 %a   &amp;quot;./notes/misc/vim-vimcasts.rst&amp;quot; line 123     %a是active buffer
&lt;/pre&gt;
&lt;p&gt;如果修改了一下 .recent. 就需要 bn! 才能切到下一个buffer:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:ls
1 #h + &amp;quot;.recent&amp;quot;                      line 3            +表示有modify,  h 表示hidden
2 %a   &amp;quot;./notes/misc/vim_usage.rst&amp;quot;   line 217
3  a   &amp;quot;./notes/misc/vim-vimcasts.rst&amp;quot; line 0
&lt;/pre&gt;
&lt;p&gt;bn时不要求buffer 一定要写入:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set hidden
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:ls&lt;/tt&gt;     show the buffer list&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:bn&lt;/tt&gt;     open the next buffer in t        he current window (cycles from the end of the list to the beginning).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:bp&lt;/tt&gt;     open the previous buffer in the current window (cycles from the start of the  list to the end).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CTRL-^&lt;/span&gt;&lt;/tt&gt;   switch to the alternate file&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-windows-5-32"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;#7 Working with windows (5:32)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;知识通过读 &lt;tt class="docutils literal"&gt;window&lt;/tt&gt; 一节, 已经知道, 演示的例子不错.&lt;/p&gt;
&lt;p&gt;移动焦点:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ctrl-w hjkl
&lt;/pre&gt;
&lt;p&gt;移动窗口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ctrl-w HJKL
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-tabs-3-17"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;#8 Working with tabs (3:17)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:tabedit xxx.txt

:tabonly

:3gt, 直接到第几个tab.
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
map &amp;lt;C-1&amp;gt; 1gt
map &amp;lt;C-2&amp;gt; 2gt
map &amp;lt;C-3&amp;gt; 3gt
map &amp;lt;C-4&amp;gt; 4gt
map &amp;lt;C-5&amp;gt; 5gt
map &amp;lt;C-6&amp;gt; 6gt
map &amp;lt;C-7&amp;gt; 7gt
map &amp;lt;C-8&amp;gt; 8gt
map &amp;lt;C-9&amp;gt; 9gt
map &amp;lt;C-0&amp;gt; :tablast&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;可惜在我这用不了&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tabmove
tabmove 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-use-tabs-5-28"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;#9 How to use tabs (5:28)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一节基本没有什么内容..&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-creating-the-vimcasts-logo-as-ascii-art-5-47"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;#10 &amp;lt;nice-demo&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ASCII art&lt;/p&gt;
&lt;p&gt;在线工具: &lt;a class="reference external" href="http://patorjk.com/software/taag/#p=display&amp;amp;v=0&amp;amp;f=Bulbhead&amp;amp;t=hello"&gt;http://patorjk.com/software/taag/#p=display&amp;amp;v=0&amp;amp;f=Bulbhead&amp;amp;t=hello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;宏:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
qavwr_jq
q      q  两个q作为起始和结束
 a        表示放在a这个寄存器.
&lt;/pre&gt;
&lt;p&gt;这一节对vim 的:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;V模式,&lt;/li&gt;
&lt;li&gt;ctrl+v 模式,&lt;/li&gt;
&lt;li&gt;拷贝,&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;宏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等的介绍, 对初学者是 &lt;strong&gt;很好的例子&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用hint&lt;/strong&gt;, 如何在ctrl+v (C-V)模式下, 只替换选中的内容:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
&lt;/pre&gt;
&lt;p&gt;选中后 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;'&amp;lt;,'&amp;gt;s/./x/g&lt;/span&gt;&lt;/tt&gt;, 替换是在整个行上的. 会把ab都替换&lt;/p&gt;
&lt;p&gt;需要加上 &lt;tt class="docutils literal"&gt;\%V&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:'&amp;lt;,'&amp;gt;s/\%V./x/g
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="using-the-changelist-and-jumplist-3-21"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;#11 Using the changelist and jumplist (3:21)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;changelist:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:changes
g;  到上一个编辑点.
g,
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
10g;  到倒数第10个编辑点.

   10   269    0 ============================
    9   197    8 #10 &amp;lt;nice&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)
    8   269    0 ============================
    7   232    0
    6   269    0 ============================
    5   235    0
    4   269    0 ============================
    3   269    0 ============================
    2   238    4 :changes
    1   242    0
&amp;gt;   0   250    0
    1   247    9 ctrl+I
    2   269    0 ============================
    3   248    0
    4   269    0 ============================
    5   239   29 g;  到上一个编辑点.
    6   269    0 ============================
    7   269    0 ============================
    8   240   36 10g;  到倒数第10个编辑点.
    9   269    0 ============================
   10   269    0 ============================
&lt;/pre&gt;
&lt;p&gt;jumplist, 比较熟悉了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:jumps
ctrl+O
ctrl+I
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="modal-editing-undo-redo-and-repeat-5-26"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;#12 Modal editing: undo, redo and repeat (5:26)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;.是对编辑命令重复, 不会对移动命令.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt; :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;cw&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;dwi&lt;/tt&gt;  (之后进入insert模式)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;I&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;^i&lt;/tt&gt;    (到行首insert)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;A&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;$i&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o&lt;/tt&gt;  想当于 &lt;tt class="docutils literal"&gt;$a&amp;lt;CR&amp;gt;&lt;/tt&gt; (这个习惯了)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cleaning-up-with-vim-0-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;#13 Cleaning up with Vim (0:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;搞笑的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-edit-command-3-50"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;#14 The :edit command (3:50)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;:e&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;:help expand&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
map &amp;lt;leader&amp;gt;ew :e &amp;lt;C-R&amp;gt;=expand(&amp;quot;%:p:h&amp;quot;) . &amp;quot;/&amp;quot; &amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;后, 通过,ew, 就可以:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
e /home/ning/idning/blog_and_notes/notes/misc/
&lt;/pre&gt;
&lt;p&gt;有点用处, 不过不大, 下面这个更有用些:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Thanks to Gary Bernhardt, here is a less horrible way of creating the same mappings:

cnoremap %% &amp;lt;C-R&amp;gt;=fnameescape(expand('%:h')).'/'&amp;lt;cr&amp;gt;

this allows you to expand the directory of the current file anywhere at the command line by pressing %%. A top tip from Max Cantor!
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cmap&lt;/strong&gt;  是命令行的map, 可以在命令行里面, 用%%表示当前文件路径, &lt;strong&gt;这个收入我的.vimrc&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-file-explorer-5-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;#15 The file explorer (5:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用 &lt;tt class="docutils literal"&gt;:E&lt;/tt&gt;, 用原生的目录管理器打开 一个目录, 支持排序，创建文件/目录, 删除, 重命名等:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Netrw Directory Listing                                        (netrw v149)
&amp;quot;   /home/ning/idning/blog_and_notes
&amp;quot;   Sorted by time
&amp;quot;   Quick Help: &amp;lt;F1&amp;gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec

%   create a new file
d   create a new directory
R   rename the file/directory under the cursor
D   Delete the file/directory under the cursor
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="soft-wrapping-text-4-54"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;#16 Soft wrapping text (4:54)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;关于:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set wrap
set linebreak
set showbreak=◀  (在被wrap的行前面加个符号)
&lt;/pre&gt;
&lt;p&gt;关闭wrap:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set nowrap (此时可以用zl来向右滚动)
&lt;/pre&gt;
&lt;p&gt;开启wrap:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set wrap
&lt;/pre&gt;
&lt;p&gt;此时默认是会断开单词的, 可以用 &lt;tt class="docutils literal"&gt;:set linebreak&lt;/tt&gt;, 设置为不断开单词, (这和 &lt;tt class="docutils literal"&gt;:set list&lt;/tt&gt; 是冲突的)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用: 有wrap时候的移动&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;$&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;j&lt;/tt&gt;  等前面加上 &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; , 就是按照break后的行来移动了(按照显示行移动)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hard-wrapping-text-5-23"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id25"&gt;#17 Hard wrapping text (5:23)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;未看&lt;/p&gt;
&lt;p&gt;强制断行.&lt;/p&gt;
&lt;p&gt;选中一段``gq``就是按照80列格式化,&lt;/p&gt;
&lt;p&gt;the textwidth setting is a number representing the maximum allowed width of a
line. when set to zero, which is the default, vim will use the full width of
the window up to a maximum of 80 characters. when set to a value above zero,
vim will format lines of text so as not to exceed the value of textwidth.&lt;/p&gt;
&lt;p&gt;相关设置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set textwidth=xx &amp;quot; 一行最多多宽
默认 textwidth=0, 表示按照当前窗口宽度(但是得小于80)来做断行.

set wrapmargin=xx &amp;quot; 断行的时候, 右边空多少个字符(set nu后就需要这个了) 如果设置了textwidth, 则这个选项没有用
默认wrapmargin=0,
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
::set formatoptions=tcq
默认: formatoptions=tcroql

:set formatoptions+=a &amp;quot; 在输入的时候自动断行. 会比较奇怪. 不要设
&lt;/pre&gt;
&lt;p&gt;两个format engine: formatexpr vs formatprg.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="formatting-text-with-par-5-12"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id26"&gt;#18 Formatting text with par (5:12)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;设置外部fromat engine:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set formatprg=par
&lt;/pre&gt;
&lt;p&gt;par 输出更好看, 能处理注释格式.&lt;/p&gt;
&lt;p&gt;太复杂, 木有必要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="spell-checking-5-42"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id27"&gt;#19 Spell checking (5:42)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:set spell
对txt文件有用, 写代码用不着.

~/.vim/spell/LL.EEE.add
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="running-vim-within-irb-4-35"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id28"&gt;#20 Running Vim within IRB (4:35)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;IRB: interactive ruby shell&lt;/p&gt;
&lt;p&gt;在irb解释器里面调用vim来编辑代码(比如定义一个多行的函数),  &lt;strong&gt;确实不错的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;python 要有这个多好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-converting-markdown-to-struct-ured-html-with-a-macro-9-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id29"&gt;#21 &amp;lt;nice-demo&amp;gt;Converting markdown to struct_ured HTML with a macro (9:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;surround.vim 插件&lt;/p&gt;
&lt;p&gt;用例子讲解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非常好的例子, 应该再看一遍&lt;/strong&gt; , 虽然不是很常用, 而且可以用脚本实现, 但是用的多了, 还是很有效率!!&lt;/p&gt;
&lt;p&gt;比如 &lt;tt class="docutils literal"&gt;&amp;quot;zdw&lt;/tt&gt;  剪切到 &lt;tt class="docutils literal"&gt;z&lt;/tt&gt; 寄存器 &lt;tt class="docutils literal"&gt;&amp;quot;zP&lt;/tt&gt; 粘贴出来, 这样的寄存器, 一般多用在宏里面.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-selecting-columns-with-visual-block-mode-4-21"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id30"&gt;#22 &amp;lt;nice-demo&amp;gt;Selecting columns with visual block mode (4:21)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对 &lt;tt class="docutils literal"&gt;ctrl+v&lt;/tt&gt; 非常好的例子, 自己已经用习惯了:)&lt;/p&gt;
&lt;p&gt;textmate 也有这个功能.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;ctrl+v&lt;/tt&gt;
可以用&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;I&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;A&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;r&lt;/tt&gt; 替换&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;d&lt;/tt&gt; 删&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;p&lt;/tt&gt; 粘贴&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;c&lt;/tt&gt; &lt;strong&gt;这个有用&lt;/strong&gt; , 删掉选中的, 再进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;C&lt;/tt&gt; 这相当于按了 &lt;tt class="docutils literal"&gt;$&lt;/tt&gt; .&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o&lt;/tt&gt; &lt;strong&gt;有用&lt;/strong&gt; 到选中方块的对角.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o9&lt;/tt&gt; 固定到块尾,(对V模式都一样)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
############################
# nihao ,wo hao            #
#                          #
############################
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="converting-haml-to-erb-with-vim-macros-7-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id31"&gt;#23 Converting HAML to ERB with Vim macros (7:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;也是例子, 没有特别的东东, 例子需要对ruby 熟悉才比较好懂.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-your-vimrc-file-on-the-fly-2-51"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id32"&gt;#24 Updating your vimrc file on the fly (2:51)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:source $MYVIMRC
autocmd bufwritepost .vimrc source $MYVIMRC
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-colorschemes-for-vim-9-44"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id33"&gt;#25 Creating colorschemes for Vim (9:44)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认放在~/.vim/colors/下面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
highlight Todo guifg=#990000 guibg=NONE gui=NONE
highlight link Comment Todo
&lt;/pre&gt;
&lt;p&gt;对颜色没有特殊癖好.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bubbling-text-6-23"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id34"&gt;#26 Bubbling text (6:23)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;类似Eclise &amp;lt;ctrl+up&amp;gt; &amp;lt;ctrl-down&amp;gt; 之类的功能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Bubble single lines
nmap &amp;lt;C-Up&amp;gt; ddkP
nmap &amp;lt;C-Down&amp;gt; ddp
&amp;quot; Bubble multiple lines
vmap &amp;lt;C-Up&amp;gt; xkP`[V`]
vmap &amp;lt;C-Down&amp;gt; xp`[V`]
&lt;/pre&gt;
&lt;p&gt;虽然自己基本不用, 不过还是 &lt;strong&gt;不错的tip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面这个很有用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;gV&lt;/tt&gt; 选择刚编辑的地方:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Visually select the text that was last edited/pasted
nmap gV `[v`]
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronizing-plugins-with-git-submodules-and-pathogen-9-24"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id35"&gt;#27 Synchronizing plugins with git submodules and pathogen (9:24)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用这种方法管理模块:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Installation:

    git clone git://github.com/nelstrom/dotvim.git ~/.vim

Create symlinks:

    ln -s ~/.vim/vimrc ~/.vimrc
    ln -s ~/.vim/gvimrc ~/.gvimrc

Switch to the `~/.vim` directory, and fetch submodules:

    cd ~/.vim
    git submodule init
    git submodule update
&lt;/pre&gt;
&lt;p&gt;附带了一个简单的github用法介绍.&lt;/p&gt;
&lt;p&gt;Pathgon: 10年10月就有了的, 现在已然3年过去了.&lt;/p&gt;
&lt;p&gt;我用svn+vundle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refining-search-patterns-with-the-command-line-window-7-51"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id36"&gt;#28 Refining search patterns with the command-line window (7:51)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Refining 是提炼的意思&lt;/p&gt;
&lt;p&gt;When you press : or / in Vim, you go into commandline mode. 此时:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-p:&lt;/th&gt;&lt;td class="field-body"&gt;Show previous historical command/search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-n:&lt;/th&gt;&lt;td class="field-body"&gt;Show next         historical command/search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-f:&lt;/th&gt;&lt;td class="field-body"&gt;Switch from commandline mode to the co    mmandline window&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在normal模式下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;q/&lt;/tt&gt;:  Open the commandline window with history of searches&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;q:&lt;/tt&gt;:  Open the commandline window with history of commands&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;command-line window, 需要练习, 对正则式来说也是不错的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在写command的时候, 可以用 &lt;tt class="docutils literal"&gt;ctrl+n&lt;/tt&gt; 自动提示.&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
\v'.+'
\v'[^']+'
\v'('\w|[^'])+'
\v'(('\w|[^'])+)'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="aligning-text-with-tabular-vim-5-11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id37"&gt;#29 Aligning text with Tabular.vim (5:11)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Tab /=
:Tab /:
&lt;/pre&gt;
&lt;p&gt;下面这个如果用在输入等号的时候格式化应该不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
inoremap &amp;lt;silent&amp;gt; &amp;lt;Bar&amp;gt;   &amp;lt;Bar&amp;gt;&amp;lt;Esc&amp;gt;:call &amp;lt;SID&amp;gt;align()&amp;lt;CR&amp;gt;a

function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') &amp;amp;&amp;amp; getline('.') =~# '^\s*|' &amp;amp;&amp;amp; (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="undo-branching-and-gundo-vim-6-30"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;#30 Undo branching and Gundo.vim (6:30)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;每次回到normal 状态的时候, 记录一个undo record, 这很重要!!&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;例1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在riv.vim插件里面, 如果设置了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
let s:default.buf_imaps = {
    \'&amp;lt;BS&amp;gt;'         : 'riv#action#ins_backspace()',
    \'&amp;lt;CR&amp;gt;'         : 'riv#action#ins_enter()'   ,
    \'&amp;lt;KEnter&amp;gt;'     : 'riv#action#ins_enter()'   ,
    ...
}
&lt;/pre&gt;
&lt;p&gt;这里粘贴一段多行文字的时候, 每次遇到&amp;lt;CR&amp;gt;都会切入normal模式, 造成多个undo history&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;例2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;自己的修改LastModified 字段的插件, 每次保存的时候, 都会生成两个undo history, undo 的时候会跳到文件头.&lt;/p&gt;
&lt;p&gt;不少人遇到这个问题:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/12741977/prevent-vim-from-updating-its-undo-tree"&gt;http://stackoverflow.com/questions/12741977/prevent-vim-from-updating-its-undo-tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/17969784/vim-temporary-disable-undo"&gt;http://stackoverflow.com/questions/17969784/vim-temporary-disable-undo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都没有很好解决.&lt;/p&gt;
&lt;p&gt;我通过在python里面判断, 如果last modify 正好是当天, 就不做update, 来减少undo history&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="undo-branch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id41"&gt;undo branch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;vim 7.0的特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里讲解非常好!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为undo, redo 只能在一个分支上走, 不能到一个已经被丢弃的分支,
但是可以通过 &lt;tt class="docutils literal"&gt;g+&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;g-&lt;/tt&gt; 回到上一个状态(可以在undo branch之间切换!) 类似时光机.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:earlier {count}    Go to older text state {count} times.
:earlier {N}s       Go to older text state about {N} seconds before.
:earlier {N}m       Go to older text state about {N} minutes before.
:earlier {N}h       Go to older text state about {N} hours before.
:earlier {N}d       Go to older text state about {N} days before.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="gundo"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id42"&gt;gundo&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个插件, 可以展示undo branch的分支, 还能显示两次变换之间的diff.&lt;/p&gt;
&lt;p&gt;也是用python做的!&lt;/p&gt;
&lt;p&gt;很赞: &lt;a class="reference external" href="https://github.com/sjl/gundo.vim"&gt;https://github.com/sjl/gundo.vim&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-a-complement-to-command-line-git-8-27"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id43"&gt;#31 Fugitive.vim - a complement to command line git (8:27)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git run任何git命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Git log
:Git lg

:Gwrite
:Gread
:Gremove
:Gmove
&lt;/pre&gt;
&lt;p&gt;感觉没有必要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-working-with-the-git-index-11-41"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id44"&gt;#32 Fugitive.vim - working with the git index (11:41)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Gstatus&lt;/tt&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;之后用 &lt;tt class="docutils literal"&gt;-&lt;/tt&gt; 来修改是否要stage 一个文件, 很赞&lt;/li&gt;
&lt;li&gt;之后用 &lt;tt class="docutils literal"&gt;C&lt;/tt&gt; 来开始commit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Gblame&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;Gdiff&lt;/tt&gt; 是有点用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-resolving-merge-conflicts-with-vimdiff-11-35"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id45"&gt;#33 Fugitive.vim - resolving merge conflicts with vimdiff (11:35)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gdiff 3路merge , 太复杂.&lt;/p&gt;
&lt;p&gt;diffput, diffget 太夫在, &lt;tt class="docutils literal"&gt;dp&lt;/tt&gt; 还好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-browsing-the-git-object-database-9-45"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id46"&gt;#34 Fugitive.vim - browsing the git object database (9:45)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gbrowser挺强大和方便, &lt;em&gt;但是少用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;statusline显示git branch:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set statusline=%&amp;lt;%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-exploring-the-history-of-a-git-repository-10-04"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id47"&gt;#35 Fugitive.vim - exploring the history of a git repository (10:04)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Fugitive.vim这个插件挺强大和方便, 但是这些功能太少用了 -- 很多人几乎一年浏览一下某个项目的历史项目, 就不错了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vimgolf-prime-numbers-6-53"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id48"&gt;#36 VimGolf - Prime Numbers (6:53)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VimGolf是一个Vim挑战网站, 从获得Prime Numbers这个例子上, 可以学习宏/正则式.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-fold-8-49"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id49"&gt;#37 How to fold (8:49)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;:help fold-methods&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zi&lt;/tt&gt; switch folding on or off&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;za&lt;/tt&gt; toggle current fold open/closed&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zc&lt;/tt&gt;          close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zR&lt;/tt&gt; open all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zM&lt;/tt&gt; close all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zv&lt;/tt&gt; expand folds           to reveal cursor&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zo&lt;/tt&gt;  open current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zO&lt;/tt&gt;  recursively open current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zc&lt;/tt&gt;  close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zC&lt;/tt&gt;  recursively close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;za&lt;/tt&gt;  toggle current fold                           有用, 可以换掉zc, zo&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zA&lt;/tt&gt;  recursively open/close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zm&lt;/tt&gt;  reduce &lt;cite&gt;foldlevel&lt;/cite&gt; by one&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zM&lt;/tt&gt;  close all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zr&lt;/tt&gt;  increase &lt;cite&gt;foldlevel&lt;/cite&gt; by one&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zR&lt;/tt&gt;  open all folds&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;nnoremap &amp;lt;Space&amp;gt; za&lt;/tt&gt; 不错, 很方便.&lt;/p&gt;
&lt;p&gt;知识点不多, 基本都用惯了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-a-custom-fold-expression-12-07"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id50"&gt;#38 Writing a custom fold expression (12:07)&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;foldcolumn&lt;/tt&gt; 是说左边有几个列是放fold标记的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用foldmethod=marker 时, 可以用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{{{
{{{1  这里1表示级别
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s the boilerplate fold expression that we used to begin with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! MarkdownFolds()
  return &amp;quot;0&amp;quot;
endfunction
setlocal foldmethod=expr
setlocal foldexpr=MarkdownFolds()
&lt;/pre&gt;
&lt;p&gt;返回值:&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;0&amp;quot; the line is not in a fold
&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, ...   the line is in a fold with this level
&amp;quot;=&amp;quot; use fold level from the previous line
&amp;quot;&amp;gt;1&amp;quot;, &amp;quot;&amp;gt;2&amp;quot;  a fold with this level starts at this line&lt;/blockquote&gt;
&lt;p&gt;可以通过这个函数, 设置fold的区域显示什么:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! MarkdownFoldText()
  return getline(v:foldstart)
endfunction
setlocal foldtext=MarkdownFoldText()
&lt;/pre&gt;
&lt;p&gt;有用但是不重要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="profiling-vimscript-performance-8-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id51"&gt;#39 Profiling Vimscript performance (8:09)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vim --cmd 'profile start vimrc.profile' --cmd 'profile! file ~/.vimrc'&lt;/p&gt;
&lt;p&gt;会把profile结果记录在vimrc.profile 里面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赞&lt;/strong&gt; , 有用技巧&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="long-range-line-duplication-6-31"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id52"&gt;#40 Long-range line duplication (6:31)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;没用, 不方便, 把第9行拷贝到16行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:9copy16
&lt;/pre&gt;
&lt;p&gt;拷贝到当前行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:9t.
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
set relativenumber, 显示相对行号

:-7t.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="meet-the-arglist-4-57"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id53"&gt;#41 Meet the arglist (4:57)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:args
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.&lt;/tt&gt; 是重复上一个编辑命令
&lt;tt class="docutils literal"&gt;&amp;#64;:&lt;/tt&gt; 是重复上一个命令模式的命令&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;buffer list&lt;/tt&gt; 包含 &lt;tt class="docutils literal"&gt;argument list&lt;/tt&gt;, 比如我用 &lt;tt class="docutils literal"&gt;lsrecent&lt;/tt&gt; 打开一个文件后, &lt;tt class="docutils literal"&gt;:args&lt;/tt&gt; 显示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[.recent]
&lt;/pre&gt;
&lt;p&gt;并不显示当前文件.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="populating-the-arglist-5-31"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id54"&gt;#42 Populating the arglist (5:31)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;how to set the contents of the arglist using the :args command, which can receive filepaths, globs, or even backtick expressions.&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:args notes/misc/vim-ctags-vs-cscope.rst
&lt;/pre&gt;
&lt;p&gt;会打开这个文件.&lt;/p&gt;
&lt;p&gt;args 有点像用 &lt;tt class="docutils literal"&gt;vim *.rst&lt;/tt&gt; 这样的命令打开多个文件的时候, 带的参数 &lt;tt class="docutils literal"&gt;*.rst&lt;/tt&gt;, 可以传shell 命令给args:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
args `cat a.txt`
&lt;/pre&gt;
&lt;img alt="" src="/imgs/vim_buffer_list_vs_arglist.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="using-argdo-to-change-multiple-files-5-40"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id55"&gt;#43 Using :argdo to change multiple files (5:40)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个没啥可说的&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="search-multiple-files-with-vimgrep-7-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id56"&gt;#44 Search multiple files with :vimgrep (7:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vimgrep is Vim’s built-in command for searching across multiple files. It’s not so fast as external tools like ack and git-grep, but it has its uses. vimgrep uses Vim’s built-in regex engine, so you can reuse the patterns that work with Vim’s standard search command.&lt;/p&gt;
&lt;p&gt;不如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ack
git-grep
ag
&lt;/pre&gt;
&lt;p&gt;快.&lt;/p&gt;
&lt;p&gt;grep 一个东西:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Ack ensureIndex
:grep ensureIndex * -r  会把svn 之类的grep出来.

在当前文件中找:
:vimgrep /ensureIndex/g %

:vimgrep /ensureIndex/g *

:vimgrep /ensureIndex/g `find . -type f`

在arglist 里面搜索
:vimgrep /ensureIndex/g ##
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
:vim /pattern1/ `find . -type f`
:vim /pattern2/ `find . -type f`
:vim /pattern3/ `find . -type f`
&lt;/pre&gt;
&lt;p&gt;可以换成:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:args `find . -type f`
:vim /pattern1/ ##
:vim /pattern2/ ##
:vim /pattern3/ ##
&lt;/pre&gt;
&lt;p&gt;vimgrep 的优势只有: 和vim使用同样的正则.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-wide-find-and-replace-6-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id57"&gt;#45 Project-wide find and replace (6:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;把quickfix 窗口里面的文件名, 放到arglist里面去, &lt;strong&gt;非常有用&lt;/strong&gt;, 但是用到这种全局替换的case不多:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  &amp;quot; Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
&lt;/pre&gt;
&lt;p&gt;这样, 流程变为:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;vimgrep 找出需要替换的单词&lt;/li&gt;
&lt;li&gt;Qargs&lt;/li&gt;
&lt;li&gt;:argdo %s/xxx/xxxxx/ge&lt;/li&gt;
&lt;li&gt;:argdo w&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="search-for-the-selected-text-4-39"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id58"&gt;#46 Search for the selected text (4:39)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用内置功能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:vmap X y/&amp;lt;C-R&amp;gt;&amp;quot;&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;用插件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
visual-star-search plugin from github,
&lt;/pre&gt;
&lt;p&gt;非常有用, 效果比之前用的 &lt;tt class="docutils literal"&gt;UtilVisualSelection&lt;/tt&gt; 好.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;某些时候可以替代ack&lt;/strong&gt; 也不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; recursively vimgrep for word under cursor or selection if you hit leader-star
nnoremap &amp;lt;leader&amp;gt;* :execute 'noautocmd vimgrep /\V' . substitute(escape(expand(&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;), '\'), '\n', '\\n', 'g') . '/ **'&amp;lt;CR&amp;gt;
vnoremap &amp;lt;leader&amp;gt;* :&amp;lt;C-u&amp;gt;call &amp;lt;SID&amp;gt;VSetSearch()&amp;lt;CR&amp;gt;:execute 'noautocmd vimgrep /' . &amp;#64;/ . '/ **'&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;,*&lt;/tt&gt; 这个map比 &lt;tt class="docutils literal"&gt;F3&lt;/tt&gt; 也更好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="smart-search-with-subvert-5-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id59"&gt;&amp;#64;47 Smart search with :Subvert (5:33)&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="supercharged-substitution-with-subvert-7-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id60"&gt;&amp;#64;48 Supercharged substitution with :Subvert (7:09)&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="enhanced-abbreviations-with-abolish-3-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id61"&gt;&amp;#64;49 Enhanced abbreviations with :Abolish (3:09)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;abolish插件对我应该不太有用.&lt;/p&gt;
&lt;p&gt;Abolish's killer feature is that it handles the fight between logical names &amp;amp; the English language.
在替换的时候能自动处理单复数, 大小写, 前后缀:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:%s/Notes/Entries/g
:%s/Note/Entry/g
:%s/notes/entries/g
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="an-introduction-to-vspec-7-15"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id62"&gt;#50 An introduction to vspec (7:15)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Vspec&lt;/tt&gt; is a library that allows you to test-drive your Vimscript code. In this tutorial, we’ll cover the basics: how to inspect the contents of a buffer, how to simulate the actions of a user, and how to invoke user-defined mappings.&lt;/p&gt;
&lt;p&gt;可以给vim 插件写测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nnoremap x daw

describe 'vspec'

  before
    new
    put! = 'Welcome to Vimcasts'
  end

  after
    close!
  end

  it 'can read the contents of the buffer'                  #一个case
    Expect getline(1) == &amp;quot;Welcome to Vimcasts&amp;quot;
  end

  it 'feels just like operating Vim!'                       #一个case
    normal gg$
    normal daw
    Expect getline(1) == 'Welcome to'
    Expect getreg('&amp;quot;') == ' Vimcasts'
  end

  it 'can exercise user-defined mappings'                   #一个case
    normal gg$
    normal x
    Expect getline(1) == 'Welcome to'
    Expect getreg('&amp;quot;') == ' Vimcasts'
  end

end
&lt;/pre&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;把如上脚本转换为vimscrip (excommand)&lt;/li&gt;
&lt;li&gt;用Ex模式调用vim(不会出现gui), 并执行excommand&lt;/li&gt;
&lt;li&gt;可以用excommand &lt;tt class="docutils literal"&gt;normal d&lt;/tt&gt; 模拟normal 模式下按一下 &lt;tt class="docutils literal"&gt;d&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;非常赞&lt;/strong&gt; .&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-operations-using-the-default-register-4-07"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id63"&gt;#51 Simple operations using the default register (4:07)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;讲ddp交换两行.&lt;/p&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="meet-the-yank-register-4-29"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id64"&gt;#52 Meet the yank register (4:29)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;已知, 比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-vim-s-named-registers-3-29"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id65"&gt;#53 Using Vim's named registers (3:29)&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;quot;ayy&lt;/tt&gt; 是把当前行放入 &lt;tt class="docutils literal"&gt;寄存器a&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;quot;Ayy&lt;/tt&gt; 是把当前行append 到 &lt;tt class="docutils literal"&gt;寄存器a&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pasting-from-visual-mode-3-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id66"&gt;#54 Pasting from Visual mode (3:33)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pasting-from-insert-mode-4-15"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id67"&gt;#55 Pasting from Insert mode (4:15)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;insert下/命令模式下, 按 &lt;tt class="docutils literal"&gt;crtl+r 0&lt;/tt&gt;, 粘贴0号寄存器.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-calculations-with-vim-s-expression-register-4-02"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id68"&gt;#56 Simple calculations with Vim's expression register (4:02)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;表达式寄存器: &lt;tt class="docutils literal"&gt;&amp;quot;=&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt; : 编辑模式下: &lt;tt class="docutils literal"&gt;ctrl+r =&lt;/tt&gt; 输入 &lt;tt class="docutils literal"&gt;3*5&lt;/tt&gt; , 插入结果&lt;/p&gt;
&lt;p&gt;用下面这个map:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nnoremap Q 0yt=A&amp;lt;C-r&amp;gt;=&amp;lt;C-r&amp;gt;&amp;quot;&amp;lt;CR&amp;gt;&amp;lt;Esc&amp;gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
3*2 =
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="evaluating-scripts-with-vim-s-expression-register-3-56"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id69"&gt;#57 Evaluating scripts with Vim's expression register (3:56)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;system()&lt;/tt&gt; 函数&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;quot;=&lt;/tt&gt; 下可以用 abs(), round(), system()之类函数&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:help function-list
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
:put = 3+3
:put =system('echo $RANDOM')
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="accessing-the-system-clipboard-from-vim-4-48"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id70"&gt;#58 Accessing the system clipboard from Vim (4:48)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;+y
粘贴, 不需要设置set paste:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;+gp
:put +
&lt;/pre&gt;
&lt;p&gt;If you’d like to make it easier to interact with the system clipboard, try out this setting,&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set clipboard=unnamed,unnamedplus
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt;, 但是会破坏我在 &lt;tt class="docutils literal"&gt;rst_bold_it&lt;/tt&gt; 的ctrl+c, ctrl+b, 因为这里我用了默认寄存器 &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt; , 我换成命名寄存器 &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 就好了&lt;/p&gt;
&lt;p&gt;上面这个行为想当于 在d, x, y, p 命令前都加了&amp;quot;*&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-vim-s-paste-mode-with-the-system-paste-command-4-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id71"&gt;#59 Using Vim's paste mode with the system paste command (4:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;set paste 之后 ， imap都失效了.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;unimpaired&lt;/tt&gt; 这个插件, 可以在我想要粘贴的时候, 按 &lt;tt class="docutils literal"&gt;yo&lt;/tt&gt; , 此时会自动 &lt;tt class="docutils literal"&gt;set paste&lt;/tt&gt; 贴完之后, 会自动 &lt;tt class="docutils literal"&gt;set nopaste&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;-对我基本没用&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="comparing-buffers-with-vimdiff-4-16"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id72"&gt;#60 Comparing buffers with vimdiff (4:16)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:windo diffthis 比较两个win.
:windo diffoff
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-repeatable-mappings-with-repeat-vim-4-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id73"&gt;#61 Creating repeatable mappings with repeat.vim (4:33)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基本没用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id74"&gt;关于&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;作者:&lt;a class="reference external" href="https://github.com/nelstrom/"&gt;https://github.com/nelstrom/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ning-vim-modline"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id75"&gt;ning: vim modline&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比如写在文件头:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;vim: foldmethod=marker
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id76"&gt;总结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前30个非常好, 后面知识较少.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry></feed>