<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>ning</title><link href="/" rel="alternate"></link><link href="http://idning.github.io/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2014-11-02T11:41:38+08:00</updated><entry><title>redis-data-migrate</title><link href="/redis-data-migrate.html" rel="alternate"></link><updated>2014-11-02T11:41:38+08:00</updated><author><name>ning</name></author><id>tag:,2014-11-02:redis-data-migrate.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么要设计这样的扩容方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id8"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;怎么实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id9"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aof" id="id10"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;aof不是幂等的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id11"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;切流量时的不一致&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id12"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;实现&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-mgr" id="id13"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-mgr 集成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id14"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在 &lt;a class="reference external" href="/redis-instance-migrate.html"&gt;这篇blog&lt;/a&gt; 里面提到2种扩容:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;一个是 redis-mgr 中redis实例的迁移, 迁到一个内存大的机器&lt;/li&gt;
&lt;li&gt;另外一个是新搭建集群, 把数据迁移过去.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里考虑第二种思路.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么要设计这样的扩容方式&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;简单可依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;从架构上, 这不需要像redis-cluster那样复杂的重新设计, 用现有的redis就可以完成扩容,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不需要升级redis服务端, 也不需要升级client端(redis-cluster需要client支持)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;这套方案可以用于:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;从单机redis迁移到 redis-mgr / twemproxy 管理的 集群.&lt;/li&gt;
&lt;li&gt;从一种集群架构迁移到另一种, 比如迁移到官方redis3.0 集群&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之, 就算redis3.0 的cluster 成熟以后, 还是需要这样的一套迁移方案.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;怎么实现&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;mysql 的主从同步是基于binlog, redis主从是一个op buf, mongo主从同步是oplog.&lt;/p&gt;
&lt;p&gt;redis里的aof就是类似binlog, 记录每个操作的log&lt;/p&gt;
&lt;p&gt;所以, 我们可以利用aof, 把它当作binlog, 用于做迁移, 具体的迁移我们在mysql, mongo里面都多次用过了, 分三步:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;迁移基准数据&lt;/li&gt;
&lt;li&gt;追增量&lt;/li&gt;
&lt;li&gt;追上后, 上层切流量.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;redis的aof包含了基准数据和增量, 所以我们只需要把旧集群中redis实例上的aof重放到新集群, 重放追上时修改上层, 把入口换为新集群即可.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="aof"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;aof不是幂等的&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;aof不像binlog那样可以重做 &lt;tt class="docutils literal"&gt;redolog&lt;/tt&gt;, binlog 记录的操作是 &lt;tt class="docutils literal"&gt;幂等(idempotent)&lt;/tt&gt; 的, 意味着如果失败了, 可以重做一次.&lt;/p&gt;
&lt;p&gt;这是因为binlog记录的是操作的结果, 比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
op                  log
---------------------------
set x 0             x = 0
incr x              x = 1
incr x              x = 2
&lt;/pre&gt;
&lt;p&gt;但是redis的aof记录的是操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
op                  log
---------------------------
set x 0             x = 0
incr x              incr x
incr x              incr x
&lt;/pre&gt;
&lt;p&gt;这就是说, 如果我们在重放aof的过程中出错(比如网络中断):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;不能继续(不好找到上次同步到哪),&lt;/li&gt;
&lt;li&gt;也不能重新重放一次, (incr两次, 值就错了)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只能清除目标集群的数据重新迁移一次 ( &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-mgr&lt;/span&gt;&lt;/tt&gt; 里面有 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clean-keys&lt;/span&gt;&lt;/tt&gt; 命令按照前缀清除)&lt;/p&gt;
&lt;p&gt;不过, 好在redis单实例的afo数据都不大, 一般10G左右, 重放大约20min就能完成, 出错的概率也很小. (这也是redis可以这样做, 而其他持久存储比如mysql, mongo必须支持断点同步的原因)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;切流量时的不一致&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前面说的步骤是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;追aof&lt;/li&gt;
&lt;li&gt;追上后, 切流量.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;追aof是一个动态的过程, 追上后, 新的写操作马上就来, 所以这里追上的意思是说, 新的写入马上会被消化掉.&lt;/p&gt;
&lt;p&gt;但是考虑这样一种场景:&lt;/p&gt;
&lt;p&gt;假设client上做对x做两次set(一个机器上做两次, 或者两个app-server上分别做):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
client          old_cluster         new_cluster
-----------------------------------------------
set x 1(a)      set x 1(客户操作)
-----------------------------------------------&amp;gt; 切流量到new_cluster
set x 2(b)                          set x 2 (客户操作)
                                    set x 1 (b 操作被重放到 new_cluster)
&lt;/pre&gt;
&lt;p&gt;a操作还没同步到new_cluster, 流量就已经切到了new_cluster, 这时候对同一个key的更新, 会被老集群上的操作覆盖掉.&lt;/p&gt;
&lt;p&gt;解决:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这个短暂的不一致, 对多数业务, 是能容忍的(很少有业务会高速更新同一个key)&lt;/li&gt;
&lt;li&gt;如果非要达到一致, 当追aof追上后, app-server停写, 等待彻底追上(此时老集群的aof不会有更新了), 然后再切流量.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;实现&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有两份代码:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;推荐 &lt;a class="reference external" href="https://github.com/cen-li/redis/blob/redis-2.8.3_replay-aof/src/redis-replay-aof.c"&gt;https://github.com/cen-li/redis/blob/redis-2.8.3_replay-aof/src/redis-replay-aof.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;写着玩: &lt;a class="reference external" href="https://github.com/idning/redis/blob/replay/src/redis-cli.c"&gt;https://github.com/idning/redis/blob/replay/src/redis-cli.c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原理就是不断的看aof文件是否有更新, 有更新的话写到目标集群, 支持 按前缀过滤, 加前缀, 换前缀之类的操作.&lt;/p&gt;
&lt;div class="section" id="redis-mgr"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-mgr 集成&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-mgr&lt;/span&gt;&lt;/tt&gt; 里面集成了一个命令来方便操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#从cluster1迁移到cluster5
./bin/deploy.py cluster1 replay_aof cluster5 'prefix_'
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文档: &lt;a class="reference external" href="https://github.com/idning/redis-mgr/blob/master/doc/scalablity.rst"&gt;https://github.com/idning/redis-mgr/blob/master/doc/scalablity.rst&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>我们应该检查malloc的返回值么?</title><link href="/should-we-check-malloc.html" rel="alternate"></link><updated>2014-10-14T18:53:04+08:00</updated><author><name>ning</name></author><id>tag:,2014-10-14:should-we-check-malloc.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;我们想要什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;现有程序做法&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mysql" id="id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis" id="id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nginx" id="id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lighttpd" id="id10"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;lighttpd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#twemproxy" id="id11"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id13"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;我们经常纠结这种代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
some_small_struct *ptr=(some_small_struct *) malloc(sizeof(some_small_struct));
ptr-&amp;gt;some_member= ...;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;正方: 检查有用:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如果不检查, 没内存时会出现非预期行为.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;反方: 检查没用:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;因为这是一个小程序, 基本不可能超内存, 我们还需要检查malloc是否成功么?&lt;/li&gt;
&lt;li&gt;linux 上, 如果打开了 &lt;tt class="docutils literal"&gt;overcommit&lt;/tt&gt;, 基本上所有的alloc都会返回说有内存,
等到真正写到这片的时候才可能通过oom-killer 杀掉某个(也许是其它)进程.&lt;/li&gt;
&lt;li&gt;linux上, 如果打开了部分swap, alloc通常也会返回有内存,&lt;/li&gt;
&lt;li&gt;就算我们检查, 我们也不能避免栈空间不够之类的错误.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overcommit参考 man malloc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://linux.die.net/man/3/malloc

By default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. This is a really bad bug. In case it turns out that the system is out of memory, one or more processes will be killed by the infamous OOM killer.
&lt;/pre&gt;
&lt;p&gt;但是这时候malloc也是可能返回NULL的, 比如 address space is full.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;我们想要什么&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们的期望分成4级:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 程序依然能够正常工作, 比如http服务器能拒绝掉部分请求而保证另一部分请求正常.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 优雅退出, 防止:
- 因为文件未关闭造成数据丢失   (如果我们写了文件, 未关闭, 操作系统会保证sync到磁盘么  -- 应该是不能保证)
- socket未关闭导致对端长等待.
- 比如是一个文件编辑器, 需要保存用户的工作先.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没内存时, 通过ASSERT显示core掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;发生非预期异常(可能core).&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如alloc了一个NULL, 但是不是alloc的时候报错, 而是往里面写东西的时候报错, 就很难追查了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很显然, 1是最好的情况, 是一个有尊严的程序员所期望的, 4是一定不能发生的. 2,3是需要权衡的.&lt;/p&gt;
&lt;p&gt;3 是基线, 做到3可能保证出错时知道原因.&lt;/p&gt;
&lt;p&gt;其它:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对嵌入式系统: 内存有限, 所以应该总是检查&lt;/li&gt;
&lt;li&gt;对c++: 尽量使用new, 这样有exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;现有程序做法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们看看一些有名程序的做法&lt;/p&gt;
&lt;div class="section" id="mysql"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;多数地方都做到1:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
HP_INFO *heap_open_from_share(HP_SHARE *share, int mode)
{
  HP_INFO *info;
  DBUG_ENTER(&amp;quot;heap_open_from_share&amp;quot;);

  if (!(info= (HP_INFO*) my_malloc((uint) sizeof(HP_INFO) +
                  2 * share-&amp;gt;max_key_length,
                  MYF(MY_ZEROFILL))))
  {
    DBUG_RETURN(0);
  }
&lt;/pre&gt;
&lt;p&gt;有的地方只能做到4:&lt;/p&gt;
&lt;p&gt;storage/innobase/handler/ha_innodb.cc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
    field_lengths = (ulint*) my_malloc(sizeof(ulint) * n_fields,
            MYF(MY_FAE));

    namebuf = (char*) my_malloc((uint) len + 2, MYF(0));
    memcpy(namebuf, ptr, len);

innobase_rename_table(
    ...
    norm_to = (char*) my_malloc(strlen(to) + 64, MYF(0));
    norm_from = (char*) my_malloc(strlen(from) + 64, MYF(0));
&lt;/pre&gt;
&lt;p&gt;storage/myisam/myisampack.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static my_bool open_isam_files(PACK_MRG_INFO *mrg, char **names, uint count)
{
  mrg-&amp;gt;file=(MI_INFO**) my_malloc(sizeof(MI_INFO*)*count,MYF(MY_FAE));
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="redis"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;做到3:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
    block = zmalloc(sizeof(*block));
    block-&amp;gt;free = AOF_RW_BUF_BLOCK_SIZE;
&lt;/pre&gt;
&lt;p&gt;不过在zmalloc里面做到了assert:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void zmalloc_default_oom(size_t size) {
    fprintf(stderr, &amp;quot;zmalloc: Out of memory trying to allocate %zu bytes\n&amp;quot;,
        size);
    fflush(stderr);
    abort();
}

static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;

void *zmalloc(size_t size) {
    void *ptr = malloc(size+PREFIX_SIZE);

    if (!ptr) zmalloc_oom_handler(size);
&lt;/pre&gt;
&lt;p&gt;但是在cli等不重要代码里面做到4:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void cliInitHelp() {
    tmp.argv = malloc(sizeof(sds));
    tmp.argv[0] = sdscatprintf(sdsempty(),&amp;quot;&amp;#64;%s&amp;quot;,commandGroups[i]);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;alloc 里面打日志, 不是ASSERT (不过ngx_log_error里面应该还会malloc):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void *
ngx_alloc(size_t size, ngx_log_t *log)
{
    void  *p;

    p = malloc(size);
    if (p == NULL) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                      &amp;quot;malloc(%uz) failed&amp;quot;, size);
    }

    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, &amp;quot;malloc: %p:%uz&amp;quot;, p, size);

    return p;
}
&lt;/pre&gt;
&lt;p&gt;使用时检查(90%的地方都有检查):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
env = ngx_palloc(cycle-&amp;gt;pool, (n + 1) * sizeof(char *));
if (env == NULL) {
    return NULL;
}

overflow_list = ngx_alloc(sizeof(struct pollfd) * rtscf-&amp;gt;overflow_events,
                          cycle-&amp;gt;log);
if (overflow_list == NULL) {
    return NGX_ERROR;
}
&lt;/pre&gt;
&lt;p&gt;也有不检查:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)
    var = ngx_alloc(sizeof(NGINX_VAR)
                    + cycle-&amp;gt;listening.nelts * (NGX_INT32_LEN + 1) + 2,
                    cycle-&amp;gt;log);

    p = ngx_cpymem(var, NGINX_VAR &amp;quot;=&amp;quot;, sizeof(NGINX_VAR));
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="lighttpd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;lighttpd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ASSERT&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="twemproxy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;和nginx一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void *
_nc_alloc(size_t size, const char *name, int line)
{
    void *p;

    ASSERT(size != 0);

    p = malloc(size);
    if (p == NULL) {
        log_error(&amp;quot;malloc(%zu) failed &amp;#64; %s:%d&amp;quot;, size, name, line);
    } else {
        log_verb(&amp;quot;malloc(%zu) at %p &amp;#64; %s:%d&amp;quot;, size, p, name, line);
    }

    return p;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;nginx 和mysql, redis 做的差不多, 尽量检查.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;推荐的做法:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;alloc里面如果有NULL打日志, 上层每次检查, 发现NULL处理错误&lt;/li&gt;
&lt;li&gt;对小的alloc, alloc 后写ASSERT.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;讨论: &lt;a class="reference external" href="http://stackoverflow.com/questions/1941323/always-check-malloced-memory"&gt;http://stackoverflow.com/questions/1941323/always-check-malloced-memory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>hyperloglog</title><link href="/hyperloglog.html" rel="alternate"></link><updated>2014-10-11T13:55:22+08:00</updated><author><name>ning</name></author><id>tag:,2014-10-11:hyperloglog.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;what&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how" id="id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;how&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis" id="id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;redis实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ref" id="id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;ref&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id8"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id9"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;其它算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id10"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;典型问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lossy-counting" id="id11"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Lossy Counting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#sticky-counting" id="id12"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Sticky Counting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="what"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;what&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Hyperloglog是 counting 算法&lt;/li&gt;
&lt;li&gt;Hyperloglog is an approximate technique for computing the number of distinct entries in a set, It does this while using a small amount of memory. For instance, to achieve 99% accuracy, it needs only 16 KB.&lt;/li&gt;
&lt;li&gt;It is derived from the LogLog counting technique&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是, 不就是需要一个计数么?  i++ 不就行了么?&lt;/p&gt;
&lt;p&gt;需求:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;计算每天访问某个网站的 &lt;tt class="docutils literal"&gt;uniq&lt;/tt&gt; ips&lt;/li&gt;
&lt;li&gt;计算google 每天 &lt;tt class="docutils literal"&gt;uniq&lt;/tt&gt; query 个数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们怎么处理呢:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
脚本:           sort | uniq | wc -l
map-reduce:     sort | uniq | wc -l
程序:           通过一个大字典去重.
&lt;/pre&gt;
&lt;p&gt;它们的特点是:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sort方法时间复杂度O(n log N)&lt;/li&gt;
&lt;li&gt;去重方法 需要很大内存来去重, 空间复杂度O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="how"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;how&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here I’ll cover only the basic idea using a very clever example found at [3]. Imagine you tell me you spent your day flipping a coin, counting how many times you encountered a non interrupted run of heads. If you tell me that the maximum run was of 3 heads, I can imagine that you did not really flipped the coin a lot of times. If instead your longest run was 13, you probably spent a lot of time flipping the coin.&lt;/p&gt;
&lt;p&gt;Long story short this is what HyperLogLog does: it hashes every new element you observe. Part of the hash is used to index a register,
The other part of the hash is used to count the longest run of leading zeroes in the hash (our run of heads).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="redis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;redis实现&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
PFADD var element element … element
PFCOUNT var
PFMERGE dst src src src … src
&lt;/pre&gt;
&lt;p&gt;The commands prefix is “PF” in honor of Philippe Flajolet [4].&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ref"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;ref&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;很有意思.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这个算法大致是2007年发明出来的, google 做了改进.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://antirez.com/news/75"&gt;http://antirez.com/news/75&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"&gt;http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf"&gt;http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这里做了模拟展示: &lt;a class="reference external" href="http://content.research.neustar.biz/blog/hll.html"&gt;http://content.research.neustar.biz/blog/hll.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Lossy Counting ppt(很赞): &lt;a class="reference external" href="http://www.cse.ust.hk/vldb2002/VLDB2002-proceedings/slides/S10P03slides.pdf"&gt;http://www.cse.ust.hk/vldb2002/VLDB2002-proceedings/slides/S10P03slides.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;同上: &lt;a class="reference external" href="http://www.cs.utah.edu/~lifeifei/cis5930/lecture8.pdf"&gt;http://www.cs.utah.edu/~lifeifei/cis5930/lecture8.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;思考&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如何动态维护top10&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;redis的简单kv做计数, 再加个zset.&lt;/li&gt;
&lt;li&gt;zset里面放当前最大的N个, 每次来一个query, 更新hash中的value, 同时看, 如果当前value &amp;gt; zset.min 把zset最后一个踢掉, 把当前这个插入到zset.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;其它算法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一类算法可以叫做: Streaming_algorithm&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Streaming_algorithm"&gt;http://en.wikipedia.org/wiki/Streaming_algorithm&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Streams can be denoted as an ordered sequence of points (or &amp;quot;updates&amp;quot;)&lt;/li&gt;
&lt;li&gt;但是通常 too large to be stored&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模型:
- cash register
- turnstile model
- sliding window&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;典型问题&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Frequency moments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Heavy hitters (&lt;strong&gt;top 10&lt;/strong&gt;)
Find the most frequent (popular) elements in a data stream. Some notable algorithms are:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Karp-Papadimitriou-Shenker algorithm&lt;/li&gt;
&lt;li&gt;Count-Min sketch&lt;/li&gt;
&lt;li&gt;Sticky sampling&lt;/li&gt;
&lt;li&gt;Lossy counting&lt;/li&gt;
&lt;li&gt;Multi-stage Bloom filters&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Trend detection[edit]
Detecting trends in data streams is often done using an heavy hitters algorithm as listed above&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Counting distinct elements&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;hyperloglog&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Entropy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Online learning&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="lossy-counting"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Lossy Counting&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you're looking at the traffic for facebook profiles. You have billions of hits. You want to find which profiles are accessed the most often. You could keep a count for each profile, but then you'd have a very large number of counts to keep track of, the vast majority of which would be meaningless.&lt;/p&gt;
&lt;p&gt;With lossy counting, you periodically remove very low count elements from the table. The most-frequently accessed profiles would almost never have low counts anyway, and if they did, they wouldn't be likely to stay there for long.&lt;/p&gt;
&lt;p&gt;-- 其实就相当于用redis做count, expire调的比较小(比如1 day)&lt;/p&gt;
&lt;p&gt;There are a large number of refinements to the algorithm. But the basic idea is this -- to find the heavy hitters without having to track every element, periodically purge your counts of any elements that don't seem likely to be heavy hitters based on the data so far.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sticky-counting"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Sticky Counting&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;抽样计算counting.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>redis设计与实现 笔记</title><link href="/book-redis-implement.html" rel="alternate"></link><updated>2014-09-29T17:39:16+08:00</updated><author><name>ning</name></author><id>tag:,2014-09-29:book-redis-implement.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c4-hash" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 hash&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rehash" id="id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;rehash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;渐进式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c5-skiplist" id="id7"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 跳表(skiplist)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c8-object" id="id8"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 object(类型和编码)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c9" id="id9"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c9 数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c16-sentinel" id="id10"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c16 sentinel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;事物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lua" id="id12"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id13"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;读的比较粗, 部分笔记:&lt;/p&gt;
&lt;div class="section" id="c4-hash"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 hash&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="rehash"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;rehash&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;扩展与收缩(rehash) 下面条件满足时:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;没有在进行bgsave或bgrewriteaof, 并且hash表的负载因子大于1&lt;/li&gt;
&lt;li&gt;在进行bgsave或bgrewriteaof, 并且hash表的负载因子大于5&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为在bgsave或bgrewriteaof的时候, 有子进程存在, redis会尽量避免进行rehash, 从而避免不必要的内存写入, 节约内存  - 这个分析很赞.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;渐进式&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;每次操作一个桶.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c5-skiplist"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 跳表(skiplist)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;sorted set 的实现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
方法1: skip list
方法2: skiplist + hash
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="c8-object"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 object(类型和编码)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;几种编码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
REDIS_ENCODING_RAW 0            // 编码为字符串
REDIS_ENCODING_INT 1            // 编码为整数
REDIS_ENCODING_HT 2             // 编码为哈希表
REDIS_ENCODING_ZIPMAP 3         // 编码为 zipmap
REDIS_ENCODING_LINKEDLIST 4     // 编码为双端链表
REDIS_ENCODING_ZIPLIST 5        // 编码为压缩列表
REDIS_ENCODING_INTSET 6         // 编码为整数集合
REDIS_ENCODING_SKIPLIST 7       // 编码为跳跃表
&lt;/pre&gt;
&lt;p&gt;不同类型可能的编码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
string      REDIS_ENCODING_INT
string      REDIS_ENCODING_EMBSTR
string      REDIS_ENCODING_RAW
list        REDIS_ENCODING_ZIPLIST
list        REDIS_ENCODING_LINKEDLIST
hash        REDIS_ENCODING_INTSET
hash        REDIS_ENCODING_HT
set         REDIS_ENCODING_INTSET
set         REDIS_ENCODING_HT
zset        REDIS_ENCODING_ZIPLIST
zset        REDIS_ENCODING_SKIPLIST
&lt;/pre&gt;
&lt;p&gt;object 命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
object encoding numberso
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="c9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c9 数据库&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;expire 保存在一个单独的dict里面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-----------------------------------------------------------------------

                        +------+
             ---------&amp;gt; |dict  |
             |          +======+
             |          |a     |  -&amp;gt; string val
             |          +------+
+---------+  |          |b     |  -&amp;gt; string val
|redisDB  |  |          +------+
+=========+  |          |c     |  -&amp;gt; string val
|dict     | --          +------+
+---------+
|expires  | --          +------+
+---------+  |--------&amp;gt; |dict  |
                        +======+
                        |a     |  -&amp;gt; longlong 1411987363000
                        +------+
                        |b     |  -&amp;gt; longlong 1411987363000
                        +------+
&lt;/pre&gt;
&lt;p&gt;p113 主从在复制问题上可能出现不一致:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;从上不会主动淘汰key,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不会在cron上尝试删除key&lt;/li&gt;
&lt;li&gt;就算访问到一个已经过期的key, 也不会删除, 而是返回它&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;从库只会从主同步 del命令.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="c16-sentinel"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c16 sentinel&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;p229讲的很细致, 不过还是太复杂.&lt;/p&gt;
&lt;p&gt;INFO: 发现slave
publish: 发现其它sentinel&lt;/p&gt;
&lt;p&gt;p244, sentinel选举是 &lt;strong&gt;raft&lt;/strong&gt; 算法 (得看下论文)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;事物&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;watch 其实是一种cas概念(总算懂了)&lt;/li&gt;
&lt;li&gt;redis事物满足ACID&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="lua"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;lua&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;对于有些lua中执行的命令, 会对输出做一个排序:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如 smember, keys等, 为了保证每次在lua中调用顺序一致.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;如果执行lua超时阻塞, 那么redis 只会接受 shutdown nosave / script kill 命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;有的地方比较罗嗦, 比如一个set操作完了之后内存是怎么样的, 不过换句话说, 就是细致.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;很多之前不知道的知识点(不过确实很少用到)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如: info/shutdown/publish 这几个命令可以在loading 状态下调用.&lt;/li&gt;
&lt;li&gt;p187, qps的计算: 16个取样, 取平均值.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;关于淘汰: redis 记录访问时间, 从而可以做近似lru&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;v1 链接: &lt;a class="reference external" href="https://github.com/huangz1990/redisbook/"&gt;https://github.com/huangz1990/redisbook/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>hhvm-redis-bug</title><link href="/hhvm-redis-bug.html" rel="alternate"></link><updated>2014-09-09T21:29:40+08:00</updated><author><name>ning</name></author><id>tag:,2014-09-09:hhvm-redis-bug.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id13"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试问题复现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fake-redis" id="id14"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;fake-redis 复现&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id15"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;测试1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id16"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis" id="id17"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;Redis库的问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mock" id="id18"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Mock 测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id19"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;修复&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fgets" id="id20"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id21"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Mock 测试&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id22"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;情况1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id23"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;情况2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fgets-bug" id="id24"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets bug&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id25"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;看实现&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id26"&gt;4.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#readimpl" id="id27"&gt;4.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;readImpl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id28"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hang" id="id29"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;模拟hang住的情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id30"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id31"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;更新&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;最近发现hhvm和redis的交互偶尔hang住(这里连接没有设置超时), 分析有三种可能性:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;server端返回错误的response.
比如返回一个超大的 length:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$10240000\r\nabcd\4\n
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
客户端读到这个大数, 但是发现没有这么多字节要读, 于是就一直等着读&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;client解析的时候出错, 如果读到正确的 &lt;tt class="docutils literal"&gt;$12\r\n&lt;/tt&gt; , 解析出错溢出, 被解析成一个超大的数, 也会一直等.&lt;/li&gt;
&lt;li&gt;由于网络问题造成hang住(比如FIN包丢失)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然, 要绕过这个问题最简单的办法是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;请求加读写超时&lt;/li&gt;
&lt;li&gt;给每个线程加个超时重启机制 (php就可以这么干).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;鉴于其它client很少发现类似问题(不过其它client通常都是连接超时, hhvm没有设置), 而且hhvm redis库代码质量较低(之前已经发现了bug), 首先怀疑是client解析出错.&lt;/p&gt;
&lt;p&gt;这篇分析做下面几个事情:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;尝试复现hang住的问题&lt;/li&gt;
&lt;li&gt;通过一个fake-redis稳定复现解析错误.&lt;/li&gt;
&lt;li&gt;检查hhvm Redis/fgets中的bug&lt;/li&gt;
&lt;li&gt;构造hang住的case.&lt;/li&gt;
&lt;li&gt;如何fix.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试问题复现&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;由于之前发现 hgetall比较容易hang住, 写了这样一个php来测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;?php
set_time_limit(0);

$r = new Redis();
$r-&amp;gt;setOption('OPT_READ_TIMEOUT', 0.0);
$conn = $r-&amp;gt;connect('10.81.19.14', 4000, 0.1 );

$key = 'kkkkkkkkk';
for ($i=0; $i&amp;lt;3000; $i++) {
    $value = str_pad( $i, $i%100, &amp;quot;\r\n&amp;quot; );

    $r-&amp;gt;hMset($key, array(&amp;quot;field-$i&amp;quot; =&amp;gt; $value));
}

for($i=0; $i&amp;lt;10000000; $i++) {
    $v = $r-&amp;gt;hgetall($key);
    $len = count($v);

    if ($i%100 == 0) {
        echo &amp;quot;$i: $len\n&amp;quot;;
    }
}

hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf a.php
&lt;/pre&gt;
&lt;p&gt;发现不会hang住, 但是经常报错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[Tue Sep  9 12:58:00 2014] [hphp] [54093:7f598d376340:0:000955] []
Fatal error: Uncaught exception 'RedisException' with Message 'protocol error, got 'o' as reply type byte' in :
Stack trace:
#0 (): Redis-&amp;gt;sockReadData()
#1 (): Redis-&amp;gt;processMapResponse()
#2 /home/ning/hhvm/a.php(26): Redis-&amp;gt;__call()
#3 {main}
&lt;/pre&gt;
&lt;p&gt;这个应该是解析过程中发生的某种错误, 我们先研究这个问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fake-redis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;fake-redis 复现&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;粗略看了hhvm Redis库的代码, 发现读response的地方处理不好, 所以我们构造一个fake-redis用于测试, fake-redis在response的时候, 每次写一个字节, sleep &lt;tt class="docutils literal"&gt;100ms&lt;/tt&gt; .&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/idning/fake-redis/blob/master/fake-redis.py"&gt;https://github.com/idning/fake-redis/blob/master/fake-redis.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(这个测试估计可以让多数网络程序出bug, 包括lighttpd, openssl等)&lt;/p&gt;
&lt;p&gt;应用这个 fake-redis, 做了下面测试&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;测试1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;c.php:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$r = new Redis();

$conn = $r-&amp;gt;connect('127.1', 9999, 0.1 );

echo &amp;quot;set\n&amp;quot;;
echo $r-&amp;gt;set('k', 'abc');
echo &amp;quot;get\n&amp;quot;;
echo $r-&amp;gt;Get('k');
echo &amp;quot;done\n&amp;quot;;
&lt;/pre&gt;
&lt;p&gt;会出问题:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
set
get
[Tue Sep  9 22:10:57 2014] [hphp] [54178:7f539ac6f340:0:000001] []
Fatal error: Uncaught exception 'RedisException' with Message 'protocol error, got 'K' as reply type byte' in :
Stack trace:
#0 (): Redis-&amp;gt;sockReadData()
#1 (): Redis-&amp;gt;processSerializedResponse()
#2 hhvm/c.php(11): Redis-&amp;gt;__call()
#3 {main}
&lt;/pre&gt;
&lt;p&gt;加了strace打算看下原因, 发现ok了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
set
1get
abcdone
&lt;/pre&gt;
&lt;p&gt;后来仔细分析了strace, 发现客户端会经常用100ms 去poll(更详细的分析参考后面):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
recvfrom(7, &amp;quot;O&amp;quot;, 1, MSG_PEEK|MSG_DONTWAIT, NULL, NULL) = 1
fcntl(7, F_GETFL)                       = 0x2 (flags O_RDWR)
poll([{fd=7, events=POLLIN|POLLERR|POLLHUP, revents=POLLIN}], 1, 100) = 1
getsockopt(7, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
recvfrom(7, &amp;quot;O&amp;quot;, 8192, MSG_DONTWAIT, NULL, NULL) = 1
&lt;/pre&gt;
&lt;p&gt;因为server端也是sleep 100ms, 所以用了strace后, cliet慢了一点, server端的response已经来了, 正好就ok了.&lt;/p&gt;
&lt;p&gt;修改 sleep 为150ms, 这时候就能稳定复现, 每次结果都一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
set
NRedis: type=+, resp=
get
[Wed Sep 10 10:43:44 2014] [hphp] [14966:7f42e70f4340:0:000001] []
Fatal error: Uncaught exception 'RedisException' with Message 'protocol error, got 'O' as reply type byte' in :
Stack trace:
#0 (): Redis-&amp;gt;sockReadData()
#1 (): Redis-&amp;gt;processSerializedResponse()
#2 /home/ning/hhvm/c.php(56): Redis-&amp;gt;__call()
#3 {main}
&lt;/pre&gt;
&lt;p&gt;strace如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
recvfrom(7, &amp;quot;O&amp;quot;, 1, MSG_PEEK|MSG_DONTWAIT, NULL, NULL) = 1
fcntl(7, F_GETFL)                       = 0x2 (flags O_RDWR)
poll([{fd=7, events=POLLIN|POLLERR|POLLHUP, revents=POLLIN}], 1, 100) = 1
getsockopt(7, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
recvfrom(7, &amp;quot;O&amp;quot;, 8192, MSG_DONTWAIT, NULL, NULL) = 1
recvfrom(7, 0x7fff6c432e40, 1, 66, 0, 0) = -1 EAGAIN (Resource temporarily unavailable)
fcntl(7, F_GETFL)                       = 0x2 (flags O_RDWR)
poll([{fd=7, events=POLLIN|POLLERR|POLLHUP}], 1, 100) = 0
recvfrom(7, 0x7fa647bf5000, 8192, 64, 0, 0) = -1 EAGAIN (Resource temporarily unavailable)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;到了这里, 我们很容易模拟fgets不符合预期的情况了, 通过读代码, 发现主要是fgets的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="redis"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;Redis库的问题&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="mock"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Mock 测试&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们通过继承Redis，来看看到底发生了什么(这个php被编译在二进制里面了, 每次修改都要重新编译, 不如继承, 方便调试):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class NRedis extends Redis{

  protected function processBooleanResponse() {
    if ($this-&amp;gt;mode === self::ATOMIC) {
      $resp = $this-&amp;gt;sockReadData($type);
      echo &amp;quot;NRedis: type=$type, resp=$resp\r\n&amp;quot;;

      return ($type === self::TYPE_LINE) AND ($resp === 'OK');
    }
    $this-&amp;gt;multiHandler[] = [ 'cb' =&amp;gt; [$this,'processBooleanResponse'] ];
    if (($this-&amp;gt;mode === self::MULTI) &amp;amp;&amp;amp; !$this-&amp;gt;processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  public function hMSet($key, array $pairs) {
    $args = [$this-&amp;gt;prefix($key)];
    foreach ($pairs as $k =&amp;gt; $v) {
      $args[] = $k;
      $args[] = $this-&amp;gt;serialize($v);
    }
    $this-&amp;gt;processArrayCommand('HMSET', $args);
    return $this-&amp;gt;processBooleanResponse();
  }
}


$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
set
NRedis: type=+, resp=
get
[Wed Sep 10 10:43:44 2014] [hphp] [14966:7f42e70f4340:0:000001] []
Fatal error: Uncaught exception 'RedisException' with Message 'protocol error, got 'O' as reply type byte' in :
Stack trace:
#0 (): Redis-&amp;gt;sockReadData()
#1 (): Redis-&amp;gt;processSerializedResponse()
#2 /home/ning/hhvm/c.php(56): Redis-&amp;gt;__call()
#3 {main}
&lt;/pre&gt;
&lt;p&gt;发现第一个set请求, server 端的返回是 &lt;tt class="docutils literal"&gt;+OK\r\n&lt;/tt&gt;, 但是客户端读到 &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; 就返回了, 此时返回的type是 &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; , resp为空, 所以接下来读get请求的response的时候, 就读到了 'O', 这就是上面这个异常的原因.&lt;/p&gt;
&lt;p&gt;这里 &lt;tt class="docutils literal"&gt;fgets&lt;/tt&gt; 返回了 &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; , 还没遇到 &lt;tt class="docutils literal"&gt;\n&lt;/tt&gt; 就返回, 这是 &lt;tt class="docutils literal"&gt;fgets&lt;/tt&gt; 的问题, 我们后面再分析&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;修复&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;既然fgets有问题, 我们可以换一个比较保守的readLine实现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class NRedis extends Redis{
  ...
  protected function sockReadLine() {
   if (!$this-&amp;gt;checkConnection()) {
     return false;
   }

   $line = '';
   while(1) {
     $c = fgetc($this-&amp;gt;connection);
     $line .= $c;
     if (substr($line, -2) == &amp;quot;\r\n&amp;quot;) {
       $line = substr($line, 0, -2);
       return $line;
     }
   }

   return false;
  }
}
&lt;/pre&gt;
&lt;p&gt;使用修复版的NRedis, 测试OK:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
set
NRedis: type=+, resp=OK
1get
abcdone
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fgets"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets问题&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Mock 测试&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;利用前面的fake-redis server, 写了这样一个测试代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat d.php
&amp;lt;?php

$conn = fsockopen('127.1', 9999, $errno, $errstr, 0.1);

fwrite($conn, &amp;quot;*3\r\n$3\r\nSET\r\n$1\r\nk\r\n$1\r\nv\r\n&amp;quot;);
$r = fgets($conn);
var_dump($r);

fwrite($conn, &amp;quot;*2\r\n$3\r\nGET\r\n$1\r\nk\r\n&amp;quot;);

$r = fgets($conn);
var_dump($r);

$r = fgets($conn);
var_dump($r);
&lt;/pre&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id22"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;情况1&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;server端不sleep时, 返回一切正常:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf d.php
string(5) &amp;quot;+OK
&amp;quot;
string(4) &amp;quot;$1
&amp;quot;
string(3) &amp;quot;v
&amp;quot;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;情况2&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;server端每发送1个byte sleep 150ms:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf d.php
string(1) &amp;quot;+&amp;quot;
string(1) &amp;quot;O&amp;quot;
string(1) &amp;quot;K&amp;quot;
&lt;/pre&gt;
&lt;p&gt;每次 &lt;tt class="docutils literal"&gt;fgets&lt;/tt&gt; 只能读到一个字节.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fgets-bug"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets bug&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://php.net/manual/en/function.fgets.php"&gt;http://php.net/manual/en/function.fgets.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;php.net上fgets 的文档:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Reading ends when length - 1 bytes have been read, or a newline (which is included in the return value), or an EOF (whichever comes first). If no length is specified, it will keep reading from the stream until it reaches the end of the line.
&lt;/pre&gt;
&lt;p&gt;有三种情况这个函数返回:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;读到1行&lt;/li&gt;
&lt;li&gt;读到eof&lt;/li&gt;
&lt;li&gt;读到(length-1) 字节&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="id8"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;看实现&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id9"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id26"&gt;4.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;fgets&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;implement of fgets hphp/runtime/ext/ext_file.cpp&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Variant f_fgets(const Resource&amp;amp; handle, int64_t length /* = 0 */) {
  if (length &amp;lt; 0) {
    throw_invalid_argument(&amp;quot;length (negative): %&amp;quot; PRId64, length);
    return false;
  }
  CHECK_HANDLE(handle, f);
  String line = f-&amp;gt;readLine(length);
  if (!line.isNull()) {
    return line;
  }
  return false;
}
&lt;/pre&gt;
&lt;p&gt;hphp/runtime/base/file.cpp:readLine:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1   String File::readLine(int64_t maxlen /* = 0 */) {
2     size_t current_buf_size = 0;
3     size_t total_copied = 0;
4     char *ret = nullptr;
5     for (;;) {
6       int64_t avail = bufferedLen();
7       if (avail &amp;gt; 0) {
8         int64_t cpysz = 0;
9         bool done = false;
10
11        char *readptr = m_buffer + m_readpos;
12        const char *eol;
13        const char *cr;
14        const char *lf;
15        cr = (const char *)memchr(readptr, '\r', avail);
16        lf = (const char *)memchr(readptr, '\n', avail);
17        if (cr &amp;amp;&amp;amp; lf != cr + 1 &amp;amp;&amp;amp; !(lf &amp;amp;&amp;amp; lf &amp;lt; cr)) {
18          /* mac */
19          eol = cr;
20        } else if ((cr &amp;amp;&amp;amp; lf &amp;amp;&amp;amp; cr == lf - 1) || (lf)) {
21          /* dos or unix endings */
22          eol = lf;
23        } else {
24          eol = cr;
25        }
26
27        if (eol) {
28          cpysz = eol - readptr + 1;
29          done = true;
30        } else {
31          cpysz = avail;
32        }
33        if (maxlen &amp;gt; 0 &amp;amp;&amp;amp; maxlen &amp;lt;= cpysz) {
34          cpysz = maxlen;
35          done = true;
36        }
37
38        current_buf_size += cpysz + 1;
39        if (ret) {
40          ret = (char *)realloc(ret, current_buf_size);
41        } else {
42          ret = (char *)malloc(current_buf_size);
43        }
44        memcpy(ret + total_copied, readptr, cpysz);
45
46        m_position += cpysz;
47        m_readpos += cpysz;
48        maxlen -= cpysz;
49        total_copied += cpysz;
50
51        if (done) {
52          break;                              ////////////////////////// 1: eol 或者读到了maxlen
53        }
54      } else if (eof()) {
55        break;                                /////////////////////////  2: eof
56      } else {
57        if (m_buffer == nullptr) {
58          m_buffer = (char *)malloc(CHUNK_SIZE);
59          m_bufferSize = CHUNK_SIZE;
60        }
61        m_writepos = filteredReadToBuffer();
62        m_readpos = 0;
63        if (bufferedLen() == 0) {
64          break;                              /////////////////////////  3: 一次读返回空.
65        }
66      }
67    }
68
69    if (total_copied == 0) {
70      assert(ret == nullptr);
71      return String();
72    }
73
74    ret[total_copied] = '\0';
75    return String(ret, total_copied, AttachString);
76  }
&lt;/pre&gt;
&lt;p&gt;看这个长函数, 有几个情况会返回, 我在代码中标了1, 2, 3. 根据fgets的定义, 1,2两处返回是合理的, 3不应该返回, 而应该继续读, 这就是 &lt;strong&gt;fgets的bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个函数的另一个问题是, 如果一个socket上发来 &lt;tt class="docutils literal"&gt;abc\r\n&lt;/tt&gt;, 但是一次读只读到 &lt;tt class="docutils literal"&gt;abc\r&lt;/tt&gt; 的时候, 它就会返回以 &lt;tt class="docutils literal"&gt;\r&lt;/tt&gt; 结尾的一行, 这个问题, Redis.php已经针对它做了专门的适配, 这里不讨论:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
protected function sockReadLine() {
  if (!$this-&amp;gt;checkConnection()) {
    return false;
  }
  $line = fgets($this-&amp;gt;connection);
  if (substr($line, -2) == &amp;quot;\r\n&amp;quot;) {
    $line = substr($line, 0, -2);
  } else if (substr($line, -1) == &amp;quot;\r&amp;quot;) {             //就是这里.
    $line = substr($line, 0, -1);
    $lf = fgetc($this-&amp;gt;connection);
    if ($lf === false) {
      // A response must terminate with both CR and LF. Refuse to guess.
      return false;
    } else if ($lf !== &amp;quot;\n&amp;quot;) {
      throw new RedisException(&amp;quot;Protocol error: CR not followed by LF&amp;quot;);
    }
  }

  return $line;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="readimpl"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id27"&gt;4.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;readImpl&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;上面的readLine会调用filteredReadToBuffer 来read more bytes, 实际上就是调用readImpl(), 下面我们分析readImpl可能返回空的情况:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int64_t File::filteredReadToBuffer() {
  int64_t bytes_read = readImpl(m_buffer, CHUNK_SIZE);
  if (LIKELY(m_readFilters.empty())) {
    return bytes_read;
  }
&lt;/pre&gt;
&lt;p&gt;readImpl for Socket: hphp/runtime/base/socket.cpp::readImpl:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1   int64_t Socket::readImpl(char *buffer, int64_t length) {
2     assert(m_fd);
3     assert(length &amp;gt; 0);
4
5     IOStatusHelper io(&amp;quot;socket::recv&amp;quot;, m_address.c_str(), m_port);
6
7     int recvFlags = 0;
8     if (m_timeout &amp;gt; 0) {
9       int flags = fcntl(m_fd, F_GETFL, 0);  // ning: we will get into this.
10      if ((flags &amp;amp; O_NONBLOCK) == 0) {
11        if (!waitForData()) {
12          m_eof = true;
13          return 0;
14        }
15        recvFlags = MSG_DONTWAIT; // polled, so no need to wait any more
16      }
17    }
18
19    int64_t ret = recv(m_fd, buffer, length, recvFlags);
20    if (ret == 0 || (ret == -1 &amp;amp;&amp;amp; errno != EWOULDBLOCK)) {
21      m_eof = true;
22    }
23    return (ret &amp;lt; 0) ? 0 : ret;
24  }
25
26  bool Socket::waitForData() {
27    m_timedOut = false;
28    while (true) {
29      struct pollfd fds[1];
30      fds[0].fd = m_fd;
31      fds[0].events = POLLIN|POLLERR|POLLHUP;
32      if (poll(fds, 1, m_timeout / 1000)) {
33        socklen_t lon = sizeof(int);
34        int valopt;
35        getsockopt(m_fd, SOL_SOCKET, SO_ERROR, (void*)(&amp;amp;valopt), &amp;amp;lon);
36        if (valopt == EINTR) continue;
37        return valopt == 0;
38      } else {
39        m_timedOut = true;
40        return true;
41      }
42    }
43    return false;
44  }
&lt;/pre&gt;
&lt;p&gt;Socket::readImpl 会进入11行的waitForData函数(从strace结果看, 这里m_timeout是设为100*1000的):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
recvfrom(7, 0x7fff5be32f00, 1, 66, 0, 0) = -1 EAGAIN (Resource temporarily unavailable)
fcntl(7, F_GETFL)                       = 0x2 (flags O_RDWR)
poll([{fd=7, events=POLLIN|POLLERR|POLLHUP, revents=POLLIN}], 1, 100) = 1
&lt;/pre&gt;
&lt;p&gt;我们可以先不管m_timeout怎么设置的, 这个值设为多大, 或者设为0, 都不影响分析, 看waitForData函数, 如果poll超时后没有收到事件, 就会设置m_timedOut=true, 并且return true.&lt;/p&gt;
&lt;p&gt;所以此时 readImpl 进入 19行recv, 明显是返回 EAGAIN 的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
poll([{fd=7, events=POLLIN|POLLERR|POLLHUP}], 1, 100) = 0
recvfrom(7, 0x7f3a3d9e2000, 8192, 64, 0, 0) = -1 EAGAIN (Resource temporarily unavailable)
&lt;/pre&gt;
&lt;p&gt;EAGAIN就是EWOULDBLOCK, 所以这里没有进入21行, 而是进入23行, 返回 &lt;tt class="docutils literal"&gt;ret = 0&lt;/tt&gt; .&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id28"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;所以, 这应该认为是 &lt;a class="reference external" href="File::readLine"&gt;File::readLine&lt;/a&gt; 的一个bug, 建议的修改是这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git diff
diff --git a/hphp/runtime/base/file.cpp b/hphp/runtime/base/file.cpp
index b180301..3d216bd 100644
--- a/hphp/runtime/base/file.cpp
+++ b/hphp/runtime/base/file.cpp
&amp;#64;&amp;#64; -611,9 +611,9 &amp;#64;&amp;#64; String File::readLine(int64_t maxlen /* = 0 */) {
       }
       m_writepos = filteredReadToBuffer();
       m_readpos = 0;
-      if (bufferedLen() == 0) {
-        break;
-      }
+      //if (bufferedLen() == 0) {
+        //break;
+      //}
     }
   }
&lt;/pre&gt;
&lt;p&gt;这需要重新编译hhvm, 所以我没有测试.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="hang"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id29"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;模拟hang住的情况&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最后, 知道bug的原因, 怎么模拟hang住呢, 我们需要构造合法的返回, 被这个bug的解析代码解析认为符合协议, 同时又解析出错。&lt;/p&gt;
&lt;p&gt;因为fgets在server端sleep 200ms 的时候就会返回当前已经读到的 部分, 构造如下response:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$10\r\n$123456789\r\n
  ^
  |
  返回 '$1' 后sleep, 此时client读到 '$1' 认为是读到了一行, 并且认为这个response的阵阵大小是1, 接下来读到 '0\r\n', 所以client 会认为服务器返回了 '0' 这个长度为1的字符串.
  接下来, 下一个get请求来的时候, 会读到 ``$123456789\r\n`` 这一行, 它会认为这个response有123456789这么多字节, 就会一致尝试去读, 当然就一直hang住了.
&lt;/pre&gt;
&lt;p&gt;模拟这个响应的代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def handle_get(self, argv):
    key = argv[1]
    if key == 'special-key-for-hhvm':

        # $10\r\n$123456789\r\n
        self.request.sendall('$1')
        time.sleep(.15)
        self.request.sendall('0\r\n$123456789\r\n')

    elif key in store:
        self.reply_bulk(store[key])
    else:
        self.reply_bulk(None)
&lt;/pre&gt;
&lt;p&gt;这是一个完全合法的get请求的response, 表达的值为 '$123456789', 客户端测试代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$r = new Redis();

$conn = $r-&amp;gt;connect('127.1', 9999, 0.1 );

$t = $r-&amp;gt;get('special-key-for-hhvm');
var_dump($t);
$t = $r-&amp;gt;get('special-key-for-hhvm');
var_dump($t);

$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
string(1) &amp;quot;0&amp;quot;
--- 这里hang住
[Wed Sep 10 11:37:39 2014] [hphp] [52895:7ffc15e5c340:0:000001] []
Fatal error: Maximum execution time of 30 seconds exceeded
&lt;/pre&gt;
&lt;p&gt;使用修改了 &lt;tt class="docutils literal"&gt;sockReadLine&lt;/tt&gt; 后的NRedis代码, 就ok:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace -oa.txt hhvm_backend/bin/hhvm_backend -c hhvm_backend/conf/hhvm.conf c.php
string(10) &amp;quot;$123456789&amp;quot;
string(10) &amp;quot;$123456789&amp;quot;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id30"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;fgets有bug, 修复方法参考正文&lt;/li&gt;
&lt;li&gt;Redis类最好不要用有bug的fgets代码, 自己实现一个sockReadLine即可.&lt;/li&gt;
&lt;li&gt;不排除server端(redis/twemproxy) 也有类似bug的可能性.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id31"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;更新&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;fgets其实没有bug, hhvm在这里的行为和php是一致的, 就是:&lt;/p&gt;
&lt;p&gt;超时后返回已读到的部分, 实际上, 这时候应该通过stream_get_meta_data() 获取是否超时信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$conn = fsockopen('127.1', 9999, $errno, $errstr, 0.1);
//$conn = fsockopen('127.1', 9999);

fwrite($conn, &amp;quot;*3\r\n$3\r\nSET\r\n$1\r\nk\r\n$1\r\nv\r\n&amp;quot;);
$r = fgets($conn);
var_dump($r);

fwrite($conn, &amp;quot;*2\r\n$3\r\nGET\r\n$1\r\nk\r\n&amp;quot;);

$r = fgets($conn);
var_dump($r);
$info = stream_get_meta_data($conn);
var_dump($info);


$r = fgets($conn);
var_dump($r);
$info = stream_get_meta_data($conn);
var_dump($info);
&lt;/pre&gt;
&lt;p&gt;输出如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
string(1) &amp;quot;+&amp;quot;
string(1) &amp;quot;O&amp;quot;
array(10) {
  ...
  [&amp;quot;timed_out&amp;quot;]=&amp;gt;
  bool(true)
  [&amp;quot;eof&amp;quot;]=&amp;gt;
  bool(false)
  [&amp;quot;wrapper_data&amp;quot;]=&amp;gt;
  NULL
}
string(1) &amp;quot;K&amp;quot;
array(10) {
  [&amp;quot;timed_out&amp;quot;]=&amp;gt;
  bool(true)
  [&amp;quot;blocked&amp;quot;]=&amp;gt;
  bool(false)
  [&amp;quot;eof&amp;quot;]=&amp;gt;
  bool(false)
  [&amp;quot;wrapper_data&amp;quot;]=&amp;gt;
  NULL
}
&lt;/pre&gt;
&lt;p&gt;接口会输出timeout.&lt;/p&gt;
&lt;p&gt;所以fgets应该认为没bug, 修改Redis库即可.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>ssdb-benchmark</title><link href="/ssdb-benchmark.html" rel="alternate"></link><updated>2014-08-13T14:48:03+08:00</updated><author><name>ning</name></author><id>tag:,2014-08-13:ssdb-benchmark.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hdd" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;hdd 测试结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ssd" id="id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 测试结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#leveldb" id="id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;LevelDB的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;关于读性能&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id8"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;改进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id9"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;因为小规模benchmark时文件都被cache, IO访问其实只有内存操作而已, 所以测试数据只能说明系统在基本无IO操作时的处理能力.&lt;/p&gt;
&lt;p&gt;为了避免文件被cache, 可以减少机器空闲内存, 或者使操作的数据集远大于内存, 我们的测试机内存64G, 所以测试时, 我们使用大约100G的数据集来进行测试.&lt;/p&gt;
&lt;p&gt;benchmark场景:&lt;/p&gt;
&lt;p&gt;先写, 后读, 采集的数据包括:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;qps随时间的变化&lt;/li&gt;
&lt;li&gt;进程内存, cpu占用,&lt;/li&gt;
&lt;li&gt;磁盘读写带宽, r/s, w/s, await, %util,&lt;/li&gt;
&lt;li&gt;磁盘占用量.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为此, 写了这样一个程序用于benchmark和记录结果:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
...
class LoadThread(threading.Thread):
    def run(self):
        global g_qps
        num = 1000000000
        #num = 100000
        cmd = 'redis-benchmark  -p 8888 -t set -n %s -r 100000000000 -d 100' % num
        p = Popen(cmd, shell=True, stdout=PIPE, bufsize=1024)

        for line in iter(lambda: p.stdout.readline(), ''):
            line = str(line).strip()
            #print(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot; + line)
            if line.startswith('SET'):
                g_qps = line.split()[1]

        cmd = 'redis-benchmark  -p 8888 -t get -n %s -r 100000000000 -d 100' % num
        p = Popen(cmd, shell=True, stdout=PIPE, bufsize=1024)
        for line in iter(lambda: p.stdout.readline(), ''):
            line = str(line).strip()
            #print(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot; + line)
            if line.startswith('GET'):
                g_qps = line.split()[1]
...
&lt;/pre&gt;
&lt;p&gt;代码在此: &lt;a class="reference external" href="https://github.com/idning/iostat-py/blob/master/ssdb-bench/ssdb-bench.py"&gt;https://github.com/idning/iostat-py/blob/master/ssdb-bench/ssdb-bench.py&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="hdd"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;hdd 测试结果&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个测试是手工完成和记录的, 没有图.&lt;/p&gt;
&lt;p&gt;写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ redis-benchmark  -p 8888 -t set -n 1000000000 -r 100000000000 -d 100
38000
&lt;/pre&gt;
&lt;p&gt;持续写1000000000条, (93G)&lt;/p&gt;
&lt;p&gt;磁盘写带宽持续70M/s左右, 内存使用会上升到10G左右, 低峰会回落, 12核cpu上, cpu占用约30%(4个核占满)&lt;/p&gt;
&lt;p&gt;qps稳定在3.8w/s, 不会随着写数据增多而变差.&lt;/p&gt;
&lt;p&gt;写完之后, 读:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ redis-benchmark  -p 8888 -t get -n 1000000000 -r 100000000000 -d 100
60~400
&lt;/pre&gt;
&lt;p&gt;如果能命中热点:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ redis-benchmark  -p 8888 -t get -n 1000000000 -r 100000 -d 100
23803.46
&lt;/pre&gt;
&lt;p&gt;初始qps只能达到60/s, 逐渐上升到400/s趋于稳定.&lt;/p&gt;
&lt;p&gt;此时磁盘每秒读请求达到150-300r/s (达到磁盘IOPS极限):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.00     0.00  137.00    0.00 12940.00     0.00   188.91     1.08    7.86   6.86  94.00
&lt;/pre&gt;
&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;ssdb在hdd上的表现:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;写性能稳定在40000/s左右. 不随着数据集的增大而变差.&lt;/li&gt;
&lt;li&gt;读性能在不能命中热点的情况下, 受限于磁盘的IOPS (400/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;hdd上, ssdb适合写多读少的场景.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ssd"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 测试结果&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/dev/sdb1 on /ssd type ext4 (rw,noatime)
mem: 48G
cpu: 12
ssd: Intel SSD 530 480GB, 2.5in SATA  参数: http://ark.intel.com/products/75336/Intel-SSD-530-Series-480GB-2_5in-SATA-6Gbs-20nm-MLC
&lt;/pre&gt;
&lt;p&gt;这块SSD 的性能参数:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Random Read : 48000 IOPS&lt;/li&gt;
&lt;li&gt;Random Write : 80000 IOPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们实际上是3块ssd做RAID0, fio测试结果:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo fio -filename=/dev/sdb -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=1k -size=200G -numjobs=30 -runtime=1000 -group_repor
5.7w/s

$rw=randread
7.3w/s
&lt;/pre&gt;
&lt;p&gt;ssdb测试结果:&lt;/p&gt;
&lt;img alt="" src="/imgs/stat.log.ssdb.0.png" style="width: 800px;" /&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ssd上写性能稳定在3.8wqps, 不会随着写数据增多而变差, 和hdd差不多,&lt;/li&gt;
&lt;li&gt;读性能稳定在5000qps, 明显好与hdd.&lt;/li&gt;
&lt;li&gt;读性能不够, 只能到5000qps, 而此时ssd上的iops大约 5000-7000/s, 此时util%只能到50%, cpu利用率也上不去, 这里可以优化.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="leveldb"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;LevelDB的问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;LevelDB只有block级别的cache, 所有Key集合是记录在磁盘上, 内存中并没有一个记录key是否存在的hash表或树结构, 所以每次查询, 不管key是否存在, LevelDB都需要到磁盘上去找, 如果block不在缓存中, 就要一层层去找, 是非常耗时的,&lt;/p&gt;
&lt;p&gt;为此, LevelDB增加了bloomfilter支持, 可以过滤掉一些key不存在的情况, 减少对磁盘的访问:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssdb-&amp;gt;options.filter_policy = leveldb::NewBloomFilterPolicy(10);
ssdb-&amp;gt;options.block_cache = leveldb::NewLRUCache(cache_size * 1048576);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;关于读性能&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;benchmark显示 &lt;strong&gt;100G数据&lt;/strong&gt; 时, 读性能稳定在大约5000 qps&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自己实现了一个单线程的服务ndb对比, 发现读qps存在和SSDB一样的低效问题, 而且更低(2000), 如下图:&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="" src="/imgs/stat.log.ndbv0.0.png" style="width: 800px;" /&gt;
&lt;p&gt;原因:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;ssdb读的时候并未判断expire, 一个读操作只需要一次LevelDB查询, 所以性能较ndb高.&lt;/li&gt;
&lt;li&gt;ssdb是使用单线程去读(并且没有加锁), IO队列上一次只有一个IO请求, 此时avgqu-sz是0.5,
这样想当于把IO操作串行化了, 根据ssd的基本数据, 平均读延迟是90us左右, 也就是说串行使用最多之能支持 1w/s的读操作, 这和我们测的数据比较接近了.
多线程的读操作应该有利于更好的利用io调度器(几个io请求可以排队, 一起发给磁盘控制器)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;改进&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;修改:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static Command commands[] = {
-       PROC(get, &amp;quot;r&amp;quot;),
+       PROC(get, &amp;quot;rt&amp;quot;),
&lt;/pre&gt;
&lt;p&gt;把读放到多线程里面去做, &lt;strong&gt;性能从5000提到15000&lt;/strong&gt; , 磁盘r/s 达到23000左右, 日志级别改为error后可以达到16000/s&lt;/p&gt;
&lt;p&gt;读没有用Transaction加锁, 所以这时候已经能同时向IO系统发多个IO请求了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int SSDB::get(const Bytes &amp;amp;key, std::string *val) const{
    std::string buf = encode_kv_key(key);
    leveldb::Status s = db-&amp;gt;Get(leveldb::ReadOptions(), buf, val);
    ...
    return 1;
}
&lt;/pre&gt;
&lt;p&gt;调整 &lt;tt class="docutils literal"&gt;READER_THREADS = 10&lt;/tt&gt; 为5, 20, 50, 发现在我的机器上10貌似是个最佳值,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;coding for ssd 系列 关于多线程read的观点:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;concurrent read threads can impair the readahead (prefetching buffer) capabilities of SSDs&lt;/li&gt;
&lt;li&gt;A single large read is better than many small concurrent reads
Concurrent random reads cannot fully make use of the readahead mechanism. In addition, multiple Logical Block Addresses may end up on the same chip, not taking advantage or of the internal parallelism.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class="reference external" href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-5-access-patterns-and-system-optimizations/"&gt;http://codecapsule.com/2014/02/12/coding-for-ssds-part-5-access-patterns-and-system-optimizations/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>reading: coding-for-ssd &amp; implement a kv</title><link href="/coding-for-ssd.html" rel="alternate"></link><updated>2014-07-30T16:58:07+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-30:coding-for-ssd.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#coding-for-ssds" id="id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Coding for SSDs&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-1-introduction-and-table-of-contents" id="id8"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 1: Introduction and Table of Contents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-2-architecture-of-an-ssd-and-benchmarking" id="id9"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 2: Architecture of an SSD and Benchmarking&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ssd" id="id10"&gt;1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#benchmark" id="id11"&gt;1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何做benchmark:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-3-pages-blocks-and-the-flash-translation-layer" id="id12"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 3: Pages, Blocks, and the Flash Translation Layer&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id13"&gt;1.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id14"&gt;1.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;写放大&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#wear-leveling" id="id15"&gt;1.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;wear leveling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#flash-translation-layer-ftl" id="id16"&gt;1.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Flash Translation Layer (FTL)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-4-advanced-functionalities-and-internal-parallelism" id="id17"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 4: Advanced Functionalities and Internal Parallelism&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#trim" id="id18"&gt;1.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;TRIM 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#over-provisioning" id="id19"&gt;1.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;over-provisioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#secure-erase" id="id20"&gt;1.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Secure Erase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#internal-parallelism-in-ssds" id="id21"&gt;1.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Internal Parallelism in SSDs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-5-access-patterns-and-system-optimizations" id="id22"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 5: Access Patterns and System Optimizations&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id23"&gt;1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;访问模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#part-6-a-summary-what-every-programmer-should-know-about-solid-state-drives" id="id24"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 6: A Summary – What every programmer should know about solid-state drives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id25"&gt;1.7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementing-a-key-value-store-felixdb" id="id26"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing a Key-Value Store(FelixDB)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what-are-key-value-stores-and-why-implement-one" id="id27"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1 What are key-value stores, and why implement one?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-existing-key-value-stores-as-models" id="id28"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;2 Using existing key-value stores as models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb" id="id29"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;3 Comparative Analysis of the Architectures of Kyoto Cabinet and LevelDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#api-design" id="id30"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;4 API Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hash-table-implementations" id="id31"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;5 Hash table implementations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementing-a-memory-efficient-hash-table-stored-on-the-file-system" id="id32"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;-6 Implementing a memory-efficient hash table stored on the file system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-management" id="id33"&gt;2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;7 Memory Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#networking" id="id34"&gt;2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;8 Networking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interfaces-rest-memcached-etc" id="id35"&gt;2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;9 Interfaces: REST, memcached, etc.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#going-further" id="id36"&gt;2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;10 Going further&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id37"&gt;2.11&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id38"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="coding-for-ssds"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Coding for SSDs&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/"&gt;http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="part-1-introduction-and-table-of-contents"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 1: Introduction and Table of Contents&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="part-2-architecture-of-an-ssd-and-benchmarking"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 2: Architecture of an SSD and Benchmarking&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;两种flash:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NOR flash&lt;/li&gt;
&lt;li&gt;NAND flash (主流)&lt;/li&gt;
&lt;li&gt;寿命有限, Each cell has a maximum number of P/E cycles (Program/Erase)&lt;/li&gt;
&lt;li&gt;高温会导致数据清除.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储单元类型:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1 bit per cell (single level cell, &lt;strong&gt;SLC&lt;/strong&gt; ),   &lt;tt class="docutils literal"&gt;寿命相对较长&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;2 bits per cell (multiple level cell, &lt;strong&gt;MLC&lt;/strong&gt; ),  &lt;tt class="docutils literal"&gt;成本低&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;3 bits per cell (triple-level cell, &lt;strong&gt;TLC&lt;/strong&gt; ).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MLC/TLC成本较低  目前多数是MLC或TLC, 如果update很多的话, 还是SLC好.&lt;/p&gt;
&lt;div class="section" id="ssd"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id10"&gt;1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 架构&lt;/a&gt;&lt;/h4&gt;
&lt;img alt="" src="/imgs/ssd_architecture.jpg" style="width: 360px; height: 207px;" /&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;接口主要是  Serial ATA (SATA), PCI Express (PCIe), 现在还有新的SAS.&lt;/li&gt;
&lt;li&gt;通常都有RAM存储(256M+), 用作buffer/cache/map关系等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;厂商给的数字通常是在某种条件下测得的, 不见得能表示真实性能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
In his articles about common flaws in SSD benchmarking [66], Marc Bevand mentioned that for instance it is common for the IOPS of random write workloads to be reported without any mention of the span of the LBA, and that many IOPS are also reported for queue depth of 1 instead of the maximum value for the drive being tested. There are also many cases of bugs and misuses of the benchmarking tools.

Correctly assessing the performance of SSDs is not an easy task.
&lt;/pre&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;span&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;queue-depth很重要.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;测试时间, 和SSD的size有很大关系:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
the performance of SSDs only drops under a sustained workload of random writes, which depending on the total size of the SSD can take just 30 minutes or up to three hours
&lt;/pre&gt;
&lt;p&gt;如下图, 30min后性能有明显下降:&lt;/p&gt;
&lt;img alt="" src="/imgs/writes_preconditioning.jpg" style="width: 360px; height: 414px;" /&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;原因:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;garbage collection must erase blocks as write commands arrive, therefore competing with the foreground operations from the host,&lt;/li&gt;
&lt;li&gt;GC影响正常流量.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里: &lt;a class="reference external" href="http://www.storagereview.com/samsung_ssd_840_pro_review"&gt;http://www.storagereview.com/samsung_ssd_840_pro_review&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="benchmark"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id11"&gt;1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何做benchmark:&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The parameters used are generally the following:
- The type of workload: can be a specific benchmark based on data collected from users, or just only sequential or random accesses of the same type (ex: only random writes)
- The percentages of reads and writes performed concurrently (ex: 30% reads and 70% writes)
- The queue length: this is the number of concurrent execution threads running commands on a drive
- The size of the data chunks being accessed (4 KB, 8 KB, etc.)&lt;/p&gt;
&lt;p&gt;结果:
- Throughput (对顺序读写)
- ipos (对随机读写)
- Latancy&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="part-3-pages-blocks-and-the-flash-translation-layer"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 3: Pages, Blocks, and the Flash Translation Layer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;不少概念:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;how writes are handled at the page and block level,&lt;/li&gt;
&lt;li&gt;write amplification&lt;/li&gt;
&lt;li&gt;wear leveling&lt;/li&gt;
&lt;li&gt;Flash Translation Layer (FTL),&lt;/li&gt;
&lt;li&gt;logical block mapping&lt;/li&gt;
&lt;li&gt;garbage collection&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id1"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;1.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;基本操作&lt;/a&gt;&lt;/h4&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Reads are aligned on page size (It is not possible to read less than one page at once.)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;和hdd其实一样.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Writes are aligned on page size&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;每次读一个page比较好理解, 每次怎么写一个page??&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;write amplification(写放大)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;写操作不是直接覆盖原来的page, 而是 拷贝这个page到ssd的RAM中, 在RAM中修改, 最后写到一个新的page里面去.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;When data is changed, the content of the page is copied into an internal register, the data is updated, and the new version is stored in a “free” page,  an operation called “read-modify-write”. The data is not updated in-place, as the “free” page is a different page than the page that originally contained the data. Once the data is persisted to the drive, the original page is marked as being “stale”, and will remain as such until it is erased.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Erases are aligned on block size&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;对于write造成的 &lt;tt class="docutils literal"&gt;stale&lt;/tt&gt; 状态的page, 需要一个erase操作, 变成 &lt;tt class="docutils literal"&gt;free&lt;/tt&gt; 状态.&lt;/li&gt;
&lt;li&gt;但是, 又不能Erase单独的一个Page, 只能Erase整个block.&lt;/li&gt;
&lt;li&gt;这些都是由ssd控制器的garbage collection process来处理的, 所以这里有很多各种算法(因为寿命有限, 所以寿命管理也需要复杂算法)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;img alt="" src="/imgs/ssd_writing_data.jpg" style="width: 360px; height: 380px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt;1.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;写放大&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;写一个字节也会导致整个page的read-modify-write&lt;/p&gt;
&lt;p&gt;应该尽量避免 small write.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wear-leveling"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id15"&gt;1.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;wear leveling&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;写均衡. 避免总是写同一个page.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="flash-translation-layer-ftl"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id16"&gt;1.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Flash Translation Layer (FTL)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Flash Translation Layer 是一个地址映射机制, 提供像磁盘一样的逻辑地址.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;logical block mapping&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;一个逻辑地址到page的有映射表.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;This mapping table is stored in the RAM of the SSD for speed of access, and is persisted in flash memory in case of power failure.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;When the SSD powers up, the table is read from the persisted version and reconstructed into the RAM of the SSD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;block-level&lt;/span&gt; mapping&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;page-level&lt;/span&gt; mapping&lt;/tt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;page-level 太费内存. Let’s assume that an SSD drive has 256 pages per block. This means that block-level mapping requires 256 times less memory than page-level mapping&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;block-level 让写放大更加明显&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;which uses an approach similar to log-structured file systems. Incoming write operations are written sequentially to log blocks. When a log block is full, it is merged with the data block associated to the same logical block number (LBN) into a free block&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt; 应该是现在ssd写能达到和读一样性能的关键点.&lt;/li&gt;
&lt;li&gt;This allows random writes to be handled like sequential writes.&lt;/li&gt;
&lt;li&gt;但是read requests need to check both the log-block mapping table and the data-block mapping table, 性能损耗应该很小.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;garbage collection.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;做ssd控制器的厂商比较少:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
seven companies are providing controllers for 90% of the solid-state drive market(做ssd的厂商很多, 但是做控制芯片/算法的很少)
&lt;/pre&gt;
&lt;p&gt;Erase: 1500-3500 μs
Write: 250-1500 μs&lt;/p&gt;
&lt;p&gt;A less important reason for blocks to be moved is the read disturb. Reading can change the state of nearby cells, thus blocks need to be moved around after a certain number of reads have been reached [14].&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="part-4-advanced-functionalities-and-internal-parallelism"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 4: Advanced Functionalities and Internal Parallelism&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="trim"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;1.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;TRIM 命令&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;which can be sent by the operating system to notify the SSD controller that pages are no longer in use in the logical space&lt;/p&gt;
&lt;p&gt;帮助控制器更好的GC.&lt;/p&gt;
&lt;p&gt;The TRIM command will only work if the SSD controller, the operating system, and the filesystem are supporting it.&lt;/p&gt;
&lt;p&gt;Under Linux, support for the ATA TRIM was added in version &lt;tt class="docutils literal"&gt;2.6.33&lt;/tt&gt; .
ext2 and ext3 filesystems do not support TRIM,
&lt;tt class="docutils literal"&gt;ext4&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;XFS&lt;/tt&gt; , among others, do support it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="over-provisioning"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id19"&gt;1.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;over-provisioning&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Over-provisioning is simply having more physical blocks than logical blocks, by keeping a ratio of the physical blocks reserved for the controller and not visible to the user. Most manufacturers of professional SSDs already include some over-provisioning, generally in the order of 7 to 25%&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secure-erase"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id20"&gt;1.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Secure Erase&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Some SSD controllers offer the ATA Secure Erase functionality&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="internal-parallelism-in-ssds"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id21"&gt;1.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Internal Parallelism in SSDs&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Due to physical limitations, an asynchronous NAND-flash I/O bus cannot provide more than 32-40 MB/s of bandwidth [5].&lt;/p&gt;
&lt;p&gt;所以实际上, ssd控制器内部有多个芯片, 类似raid那样.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="part-5-access-patterns-and-system-optimizations"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 5: Access Patterns and System Optimizations&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;访问模式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在ssd里面, 因为映射关系是动态的, contiguous addresses in the logical space may refer to addresses that are not contiguous in the physical space.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;避免随机small write.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;amall write 实际上需要写整个block. 所以写一个小数据和一个大数据都需要同样的copy-erase-write操作&lt;/li&gt;
&lt;li&gt;需要大量操作映射关系表.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Reads are faster than writes&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;顺序读比随机读throughput好.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;其它优化&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;对齐读写(有比较小的提升)&lt;/li&gt;
&lt;li&gt;打开 TRIM&lt;/li&gt;
&lt;li&gt;IO scheduler, (默认是CFQ,  NOOP or Deadline 会好一些)&lt;/li&gt;
&lt;li&gt;尽量不要用ssd存临时文件或做swap (写次数有限)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="part-6-a-summary-what-every-programmer-should-know-about-solid-state-drives"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Part 6: A Summary – What every programmer should know about solid-state drives&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;1.7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ssd在大量写压力下, 性能可能恶化到8000iops.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;因为很多update, GC可能跟不上, 如果每次写操作需要做一次erase整个block, 就悲剧了.&lt;/li&gt;
&lt;li&gt;正常情况下, GC利用后台的时间, 可以完成erase工作.&lt;/li&gt;
&lt;li&gt;The TRIM command and over-provisioning are two great ways to reduce this effect, and are covered in more details in Sections 6.1 and 6.2.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;写放大, 写一个字节也会导致整个page的read-modify-write&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;应该尽量避免 small write.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;很多ssd会通过hybrid log-block mapping来做写merge. 从而减轻写放大.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ssd 适合写少, 读多的情况&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们到底要不要避免用small write 呢?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;如果没用 &lt;tt class="docutils literal"&gt;hybrid &lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt; , 明显是要避免small-write.&lt;/li&gt;
&lt;li&gt;如果有 &lt;tt class="docutils literal"&gt;hybrid &lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt; 呢? 小的写操作还是没有大的写操作效率高.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="implementing-a-key-value-store-felixdb"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id26"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing a Key-Value Store(FelixDB)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://codecapsule.com/2012/11/07/ikvs-implementing-a-key-value-store-table-of-contents/"&gt;http://codecapsule.com/2012/11/07/ikvs-implementing-a-key-value-store-table-of-contents/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;July 8, 2014: I am currently implementing the key-value store and will write a post about it when it’s done&lt;/p&gt;
&lt;p&gt;1-4: 作者选了半天名字, api形式, 命名风格....&lt;/p&gt;
&lt;div class="section" id="what-are-key-value-stores-and-why-implement-one"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1 What are key-value stores, and why implement one?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;练习目的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;I am starting this project as a way to refresh my knowledge of some fundamentals of hardcore back-end engineering&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Reading books and Wikipedia articles is boring and exempt of practice&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;练习点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;The C++ programming language&lt;/li&gt;
&lt;li&gt;Object-oriented design&lt;/li&gt;
&lt;li&gt;Algorithmics and data structures&lt;/li&gt;
&lt;li&gt;Memory management&lt;/li&gt;
&lt;li&gt;Concurrency control with multi-processors or multi-threading&lt;/li&gt;
&lt;li&gt;Networking with a server/client model&lt;/li&gt;
&lt;li&gt;I/O problems with disk access and use of the file system&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;现有的: Redis, MongoDB, memcached, BerkeleyDB, Kyoto Cabinet and LevelDB.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打算提供的特性:
- Adapt to a specific data representation (ex: graphs, geographic data, etc.)
- Adapt to a specific operation (ex: performing very well for reads only, or writes only, etc.)
- Offer more data access options. For instance in LevelDB, data can be accessed forward or backward, with iterators&lt;/p&gt;
&lt;p&gt;貌似没有什么特点..&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I will use a hash table for the underlying data Structure, the data will be persistent on disk, and a network interface will also be implemented.&lt;/li&gt;
&lt;li&gt;不求速度 I will not run for absolute speed&lt;/li&gt;
&lt;li&gt;将基于一个现有c/c++项目(见第2节)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="using-existing-key-value-stores-as-models"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;2 Using existing key-value stores as models&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;One of the most memorable projects is DBM, the initial database manager coded by Kenneth Thompson for Unix version 7 and released in 1979&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要考察:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;DBM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Berkeley DB , 当时作为改进的DBM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Kyoto Cabinet, &lt;strong&gt;主要考察对象&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;(a straightforward implementation of DBM)一般性能7w/s, 在超过某一个buckets值之后有性能问题&lt;/li&gt;
&lt;li&gt;hash 或者B+ tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;LevelDB &lt;strong&gt;主要考察对象&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;LSM structures are allegedly optimized for SSD drives [13].&lt;/li&gt;
&lt;li&gt;有测试, 当条目数从1e6 到1e9的时候, 性能有下降: &lt;tt class="docutils literal"&gt;找不到原始文章了&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;作者认为LevelDB 代码很好: it is just pure beauty. Everything is clear, simple, and logical.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Memcached and MemcacheDB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;MongoDB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;OpenLDAP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;SQLite&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id29"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;3 Comparative Analysis of the Architectures of Kyoto Cabinet and LevelDB&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;分成这些模块:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Interface, Get/Put/Delete&lt;/li&gt;
&lt;li&gt;配置参数&lt;/li&gt;
&lt;li&gt;String库&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;li&gt;Compression&lt;/li&gt;
&lt;li&gt;Checksum&lt;/li&gt;
&lt;li&gt;Data Storage&lt;/li&gt;
&lt;li&gt;Data Structure Hash/B+Tree/LSM-Tree&lt;/li&gt;
&lt;li&gt;Memory Management&lt;/li&gt;
&lt;li&gt;Iteration&lt;/li&gt;
&lt;li&gt;Lock 管理&lt;/li&gt;
&lt;li&gt;Error管理&lt;/li&gt;
&lt;li&gt;Transaction&lt;/li&gt;
&lt;li&gt;Comparators&lt;/li&gt;
&lt;li&gt;Snapshot&lt;/li&gt;
&lt;li&gt;Sharding&lt;/li&gt;
&lt;li&gt;Replication&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;太多了... 后面4个不该考虑.&lt;/p&gt;
&lt;p&gt;作者认为Kyoto Cabinet 代码耦合较重, 比如: such as the definition of the Parametrization module inside the Core.&lt;/p&gt;
&lt;p&gt;String库:
- LevelDB is using a specialized class called “Slice
- Kyoto Cabinet is using std::string&lt;/p&gt;
&lt;p&gt;Memory Management
- Kyoto Cabinet 用mmap()
- LevelDB: 用LSM-tree&lt;/p&gt;
&lt;p&gt;Data Storage&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Kyoto Cabinet, LevelDB, BerkeleyDB, MongoDB and Redis are using the file system to store the data. Memcached, on the contrary, is storing the data in memory (RAM).&lt;/li&gt;
&lt;li&gt;对Redis 说错了.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于代码:&lt;/p&gt;
&lt;p&gt;Kyoto Cabinet 会把实现写在.h里面, Kyoto Cabinet 代码比Tokyo Cabinet好多了(The overall architecture and naming conventions have been greatly improved.) 但是还是很糟糕:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
embcomp, trhard, fmtver(), fpow()
&lt;/pre&gt;
&lt;p&gt;LevelDB 的代码命名就很好.&lt;/p&gt;
&lt;p&gt;Kyoto Cabinet 的代码重复也很严重.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="api-design"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id30"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;4 API Design&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Opening and closing a database&lt;/li&gt;
&lt;li&gt;Reading and writing data to a database&lt;/li&gt;
&lt;li&gt;Iterating over the full collection of keys and values in a database&lt;/li&gt;
&lt;li&gt;Offer a way to tune parameters&lt;/li&gt;
&lt;li&gt;Offer a decent error notification interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者考虑的: Kyoto, LevelDB, BDB, SQLite, 都是库的形式.&lt;/p&gt;
&lt;p&gt;LevelDB 的api有open(). 但是没有close(), 关闭的时候是通过delete 指针做的 -&amp;gt; 不对称.&lt;/p&gt;
&lt;p&gt;Iteration接口, sqlite 是通过一个回调, 不好:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* SQLite3 */
static int callback(void *NotUsed, int argc, char **argv, char **szColName) {
  for(int i = 0; i &amp;lt; argc; i++) {
    printf(&amp;quot;%s = %s\n&amp;quot;, szColName[i], argv[i] ? argv[i] : &amp;quot;NULL&amp;quot;);
  }
  printf(&amp;quot;\n&amp;quot;);
  return 0;
}

char *query = “SELECT * FROM table”;
sqlite3_exec(db, query, callback, 0, &amp;amp;szErrMsg);
&lt;/pre&gt;
&lt;p&gt;it's always interesting to see how different engineers solved the same problems.&lt;/p&gt;
&lt;p&gt;小结: 作者很喜欢LevelDB的api. 除了没有close.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hash-table-implementations"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id31"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;5 Hash table implementations&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这都研究cache line的优化去了, 每必要把.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;gcc4.8中stl 的 hash&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2. sparsehash库, 提供 sparse_hash_map 和 dense_hash_map两个类.
其中dense_hash_map可以scales up or down&lt;/p&gt;
&lt;ol class="arabic" start="3"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Kyoto Cabinet 中的HashDB&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不会自动扩容.&lt;/li&gt;
&lt;li&gt;一旦冲突后, 性能就很差.&lt;/li&gt;
&lt;li&gt;it is very difficult to allow the bucket array to be resized for an on-disk hash table implementation&lt;/li&gt;
&lt;li&gt;把hash表存在磁盘里面, 导致一旦冲突, 就需要在磁盘中访问链表, 这是严重的随机IO&lt;/li&gt;
&lt;li&gt;所以, 基于ssd的cache应该优化: &lt;strong&gt;读操作最多进行多少次IO&lt;/strong&gt; .&lt;/li&gt;
&lt;li&gt;碎片: 有磁盘整理&lt;/li&gt;
&lt;li&gt;一个基于磁盘的存储引擎确实较复杂.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也许我们能设计这样一个引擎:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;hash表放在内存, 对hash的所有操作写aof(像redis一样)&lt;/li&gt;
&lt;li&gt;数据操作直接写磁盘.&lt;/li&gt;
&lt;li&gt;如何解决碎片.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://code.google.com/p/sparsehash/"&gt;https://code.google.com/p/sparsehash/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="implementing-a-memory-efficient-hash-table-stored-on-the-file-system"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id32"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;-6 Implementing a memory-efficient hash table stored on the file system&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id33"&gt;2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;7 Memory Management&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="networking"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id34"&gt;2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;8 Networking&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="interfaces-rest-memcached-etc"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;9 Interfaces: REST, memcached, etc.&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="going-further"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id36"&gt;2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;10 Going further&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id37"&gt;2.11&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里作者考察的一些KV系统, 实际是一些库(KV引擎), 从我的角度看, 有这些引擎:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;BDB&lt;/li&gt;
&lt;li&gt;LevelDB&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这里有很多ssd测试数据: &lt;a class="reference external" href="http://www.storagereview.com/samsung_ssd_840_pro_review"&gt;http://www.storagereview.com/samsung_ssd_840_pro_review&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>cr-ssdb</title><link href="/cr-ssdb.html" rel="alternate"></link><updated>2014-07-24T15:12:18+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-24:cr-ssdb.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id18"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id19"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;代码&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#util" id="id20"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;util&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id21"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;请求处理模型&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#link" id="id22"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redislink" id="id23"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;RedisLink&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id24"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;命令表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id25"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;处理模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#serv-proc" id="id26"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;serv.proc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#workerpool" id="id27"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;WorkerPool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id28"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id29"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;功能&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kv" id="id30"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;kv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hash" id="id31"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;hash&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hscan-hkeys" id="id32"&gt;2.3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;hscan/hkeys的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#queue" id="id33"&gt;2.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#zset" id="id34"&gt;2.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;zset&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#zrank" id="id35"&gt;2.3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;zrank&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id36"&gt;2.3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;名字空间划分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id37"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;主从相关&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#binlog" id="id38"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;binlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#binlogqueue" id="id39"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;BinlogQueue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id40"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Binlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id41"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;主从同步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#slave" id="id42"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;slave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dump" id="id43"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;dump&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id44"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#incr" id="id45"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;incr 如何保证原子性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#expire" id="id46"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何实现expire&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#benchmark" id="id47"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id48"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id49"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;读性能的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#compact" id="id50"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何compact&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#expirekey" id="id51"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;所有expire的key记录在内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id52"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;兼容问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#del" id="id53"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;del 兼容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ttlkey" id="id54"&gt;4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;ttl一个不存在的key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id55"&gt;4.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;没有expire命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#scan" id="id56"&gt;4.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;scan类&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id17" id="id57"&gt;4.4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;scan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-hscan" id="id58"&gt;4.4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;没有redis 的hscan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;style type="text/css"&gt;
      table {
        width: 30%
      }
&lt;/style&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;请求处理模型, 每个线程一个req?&lt;/li&gt;
&lt;li&gt;如何在kv上实现hash/zset/queue&lt;/li&gt;
&lt;li&gt;如何处理expire/ttl&lt;/li&gt;
&lt;li&gt;如何支持事务, binlog?&lt;/li&gt;
&lt;li&gt;如何主从同步.&lt;/li&gt;
&lt;li&gt;LevelDB读有没有缓存, 如果没有缓存, 那么读性能 &amp;lt; iops&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;代码&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;代码量大约9000行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test/ssdb/src$ cat *.cpp *.h | wc -l
7223

ning&amp;#64;ning-laptop:~/test/ssdb/src$ cat util/*.cpp util/*.h | wc -l
2404
&lt;/pre&gt;
&lt;p&gt;协议解析:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
link.cpp
link.h
link_redis.cpp
link_redis.h
&lt;/pre&gt;
&lt;p&gt;数据类型:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
t_hash.cpp
t_hash.h
t_kv.cpp
t_kv.h
t_queue.cpp
t_queue.h
t_zset.cpp
t_zset.h
proc_hash.cpp
proc_kv.cpp
proc_queue.cpp
proc_zset.cpp

#ttl 也相当于是一种数据类型.
ttl.cpp
ttl.h
&lt;/pre&gt;
&lt;p&gt;主从同步:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
binlog.cpp
binlog.h
slave.cpp
slave.h
#backend_dump.cpp
#backend_dump.h
backend_sync.cpp
backend_sync.h
&lt;/pre&gt;
&lt;p&gt;服务框架:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
serv.cpp
serv.h
ssdb.cpp
ssdb.h
ssdb-server.cpp
&lt;/pre&gt;
&lt;p&gt;其它:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
include.h
version.h
iterator.cpp
iterator.h
&lt;/pre&gt;
&lt;div class="section" id="util"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;util&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;和icomet一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
config.cpp
config.h
daemon.h
file.h
ip_filter.h
log.cpp
log.h
strings.h
&lt;/pre&gt;
&lt;p&gt;epoll:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fde.cpp
fde_epoll.cpp
fde.h
fde_select.cpp
&lt;/pre&gt;
&lt;p&gt;bytes.cpp bytes.h Bytes, Buffer 用于实现string的一些操作.&lt;/p&gt;
&lt;p&gt;sorted_set.cpp
sorted_set.h&lt;/p&gt;
&lt;p&gt;SelectableQueue: 提供一个基于管道实现的Queue, 从而使得这个Queue 可以做Select.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;请求处理模型&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="link"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id22"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Link&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
class Link{
    int sock;
    bool noblock_;
    static int min_recv_buf;
    static int min_send_buf;

    std::vector&amp;lt;Bytes&amp;gt; recv_data; //recv_data 是解析后的bulk链表.
    Buffer *input;
    Buffer *output;

    double create_time;
    double active_time;

    int read();                             //从网络读到input
    int write();                            //从output写到网络
    int flush();                            //调用wirte.

    const std::vector&amp;lt;Bytes&amp;gt;* recv();       //从input解析到recv_data

    int send(const Bytes &amp;amp;s1);              //写到output
    int send(const Bytes &amp;amp;s1, const Bytes &amp;amp;s2);
    int send(const Bytes &amp;amp;s1, const Bytes &amp;amp;s2, const Bytes &amp;amp;s3);
    ...

    const std::vector&amp;lt;Bytes&amp;gt;* response();                           //通过read() 和recv() 读取response.

    const std::vector&amp;lt;Bytes&amp;gt;* request(const Bytes &amp;amp;s1);             //铜鼓send() 和flush() 写request.
    const std::vector&amp;lt;Bytes&amp;gt;* request(const Bytes &amp;amp;s1, const Bytes &amp;amp;s2);
    ...
}
&lt;/pre&gt;
&lt;p&gt;这里:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;read/recv 是一样的语义, 很容易混淆, write/send也是类似,
read, write 为内部函数, 如果改为 _read, _write 就好懂些.&lt;/li&gt;
&lt;li&gt;request, response 之类, 使用名词做函数名. 不好.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="redislink"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id23"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;RedisLink&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;两个函数, 处理对象是input, output:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
send_resp(Buffer *output, const std::vector&amp;lt;std::string&amp;gt; &amp;amp;resp)  //发送redis格式的响应, resp是一个 string 构成的vector.
parse_req(Buffer *input)                                         //读redis格式的请求
recv_req(Buffer *input)                                          //调用parse_req 之后调用convert 转为内部cmd格式.
&lt;/pre&gt;
&lt;p&gt;parse_req 对input的处理是, 如果一次没有解析到一个完整的命令, 那么input buffer不动, 下次继续.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id24"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;命令表&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;命令表:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define PROC(c, f) {#c, f, 0, proc_##c, 0, 0, 0}
static Command commands[] = {
    PROC(get, &amp;quot;r&amp;quot;),
    PROC(set, &amp;quot;wt&amp;quot;),        //t表示在线程池里面run
    ...
    PROC(dump, &amp;quot;b&amp;quot;),        //b表示在后台run
}
&lt;/pre&gt;
&lt;p&gt;全局变量:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static proc_map_t proc_map;

//启动时初始化 这个map
for(Command *cmd=commands; cmd-&amp;gt;name; cmd++){
    proc_map[cmd-&amp;gt;name] = cmd;
}
&lt;/pre&gt;
&lt;p&gt;收到请求后, Server::proc函数会在proc_map里面查找&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;处理模型&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ssdb-server.cpp&lt;/p&gt;
&lt;p&gt;全局:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Config *conf = NULL;
SSDB *ssdb = NULL;
Link *serv_link = NULL;
IpFilter *ip_filter = NULL;

typedef std::vector&amp;lt;Link *&amp;gt; ready_list_t;
volatile bool quit = false;
volatile uint32_t g_ticks = 0;
&lt;/pre&gt;
&lt;p&gt;main:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
main(){
    init(); //load cfg, daemon, listen, init ipfilter, init SSDB, signal
    run(argc, argv);
}
&lt;/pre&gt;
&lt;p&gt;run():&lt;/p&gt;
&lt;pre class="literal-block"&gt;
run(){
    Fdevents fdes;
    fdes.set(serv_link-&amp;gt;fd(), FDEVENT_IN, 0, serv_link);            //监听socket
    fdes.set(serv.reader-&amp;gt;fd(), FDEVENT_IN, 0, serv.reader);        //reader.SelectableQueue.fd
    fdes.set(serv.writer-&amp;gt;fd(), FDEVENT_IN, 0, serv.writer);

    while(!quit){
        ready_list.clear();
        ready_list_2.clear();

        events = fdes.wait(50);
        for(int i=0; i&amp;lt;(int)events-&amp;gt;size(); i++){
            if(fde-&amp;gt;data.ptr == serv_link){
                //do accept
            }else if(fde-&amp;gt;data.ptr == serv.reader || fde-&amp;gt;data.ptr == serv.writer){
                //从子进程那里收结果, 这里比较复杂
                proc_result(job, fdes, ready_list_2);
            }else{
                if(fde-&amp;gt;events &amp;amp; FDEVENT_IN){
                    int len = link-&amp;gt;read();                 //用read
                    ready_list.push_back(link);                         //放到ready_list
                }else if(fde-&amp;gt;events &amp;amp; FDEVENT_OUT){
                    int len = link-&amp;gt;write();                //用write
                    ready_list.push_back(link);                         //放到ready_list
                }
            }
        }
        for(it = ready_list.begin(); it != ready_list.end(); it ++){
            Link *link = *it;
            const Request *req = link-&amp;gt;recv();

            ProcJob job;
            job.link = link;
            serv.proc(&amp;amp;job);                        //这里面可能把Job发到一个线程去.
            if(job.result == PROC_THREAD){
                fdes.del(link-&amp;gt;fd());
                continue;
            }
            if(job.result == PROC_BACKEND){
                fdes.del(link-&amp;gt;fd());
                link_count --;
                continue;
            }
            //这里是直接处理的情况.
            if(proc_result(job, fdes, ready_list_2) == PROC_ERROR){
                link_count --;
            }
        }
        ready_list.swap(ready_list_2);
    }
}
&lt;/pre&gt;
&lt;p&gt;所以请求可以在主线程里面处理, 也可能在线程池里面处理, 如果在线程里面处理, 就会返回PROC_THREAD或者PROC_BACKEND, 此时fd被摘掉, 等请求处理完, 发送response后, 再把fd加入epoll.&lt;/p&gt;
&lt;p&gt;TODO: 为什么最后把ready_list_2 里面的元素放到ready_list里面去了, 但是到下一个循环一开始就   &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ready_list.clear();&lt;/span&gt;&lt;/tt&gt;, 这个clear() 是不是不应该有?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="serv-proc"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id26"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;serv.proc&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个函数会根据command_table里的标记, 决定是在主线程处理, 还是在线程池处理, 或者新开一个线程处理:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void Server::proc(ProcJob *job){
    proc_map_t::iterator it = proc_map.find(req-&amp;gt;at(0));
    if(it == proc_map.end()){
        resp.push_back(&amp;quot;client_error&amp;quot;);
    }else{
        Command *cmd = it-&amp;gt;second;
        job-&amp;gt;cmd = cmd;
        if(cmd-&amp;gt;flags &amp;amp; Command::FLAG_THREAD){              //标记为thread的cmd, 会被分到2个线程池里面去跑
            if(cmd-&amp;gt;flags &amp;amp; Command::FLAG_WRITE){
                job-&amp;gt;result = PROC_THREAD;
                writer-&amp;gt;push(*job);
                return; /////
            }else if(cmd-&amp;gt;flags &amp;amp; Command::FLAG_READ){
                job-&amp;gt;result = PROC_THREAD;
                reader-&amp;gt;push(*job);
                return; /////
            }else{
                log_error(&amp;quot;bad command config: %s&amp;quot;, cmd-&amp;gt;name);
            }
        }

        proc_t p = cmd-&amp;gt;proc;
        job-&amp;gt;time_wait = 1000 *(millitime() - job-&amp;gt;stime);
        job-&amp;gt;result = (*p)(this, job-&amp;gt;link, *req, &amp;amp;resp);   //直接在主线程处理.
        job-&amp;gt;time_proc = 1000 *(millitime() - job-&amp;gt;stime);
    }
}
&lt;/pre&gt;
&lt;p&gt;这里调用cmd-&amp;gt;proc, 就是prox_xxx 函数, 它们都是然后调用 &lt;tt class="docutils literal"&gt;SSDB&lt;/tt&gt; 类的相应函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int proc_hdel(Server *serv, Link *link, const Request &amp;amp;req, Response *resp){
    int ret = serv-&amp;gt;ssdb-&amp;gt;hdel(req[1], req[2]);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="workerpool"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id27"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;WorkerPool&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;thread.h 提供线程池(WorkerPool), ssdb里面一个writer 线程池, 一个reader 线程池:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
WorkerPool&amp;lt;ProcWorker, ProcJob&amp;gt; *writer;
WorkerPool&amp;lt;ProcWorker, ProcJob&amp;gt; *reader;

writer = new WorkerPool&amp;lt;ProcWorker, ProcJob&amp;gt;(&amp;quot;writer&amp;quot;);
writer-&amp;gt;start(WRITER_THREADS);                                  //1
reader = new WorkerPool&amp;lt;ProcWorker, ProcJob&amp;gt;(&amp;quot;reader&amp;quot;);
reader-&amp;gt;start(READER_THREADS);                                  //10
&lt;/pre&gt;
&lt;p&gt;每个WorkerPool有两个 Queue:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Queue&amp;lt;JOB&amp;gt; jobs;
SelectableQueue&amp;lt;JOB&amp;gt; results;

template&amp;lt;class W, class JOB&amp;gt;
int WorkerPool&amp;lt;W, JOB&amp;gt;::push(JOB job){
    return this-&amp;gt;jobs.push(job);
}

template&amp;lt;class W, class JOB&amp;gt;
int WorkerPool&amp;lt;W, JOB&amp;gt;::pop(JOB *job){
    return this-&amp;gt;results.pop(job);
}

template&amp;lt;class W, class JOB&amp;gt;
void* WorkerPool&amp;lt;W, JOB&amp;gt;::_run_worker(void *arg){
    while(1){
        JOB job;
        tp-&amp;gt;jobs.pop(&amp;amp;job);
        worker-&amp;gt;proc(&amp;amp;job);
        tp-&amp;gt;results.push(job);
    }
}
&lt;/pre&gt;
&lt;p&gt;SelectableQueue的fd, 在前面epoll_初始化的时候, 已经把这个fd加入监听, 每次一个job处理完成, 就会向SelectableQueue的fd上写一个字节, 这样主线程就能知道这个Job处理完了&lt;/p&gt;
&lt;p&gt;worker-&amp;gt;porc(&amp;amp;job) 的逻辑:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int Server::ProcWorker::proc(ProcJob *job){
    const Request *req = job-&amp;gt;link-&amp;gt;last_recv();
    Response resp;

    double stime = millitime();
    proc_t p = job-&amp;gt;cmd-&amp;gt;proc;
    job-&amp;gt;result = (*p)(job-&amp;gt;serv, job-&amp;gt;link, *req, &amp;amp;resp);
    double etime = millitime();
    job-&amp;gt;time_wait = 1000 * (stime - job-&amp;gt;stime);
    job-&amp;gt;time_proc = 1000 *(etime - stime);

    if(job-&amp;gt;link-&amp;gt;send(resp) == -1){
        job-&amp;gt;result = PROC_ERROR;
    }else{
        log_debug(&amp;quot;w:%.3f,p:%.3f, req: %s, resp: %s&amp;quot;,
            job-&amp;gt;time_wait, job-&amp;gt;time_proc,
            serialize_req(*req).c_str(),
            serialize_req(resp).c_str());
    }
    return 0;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id28"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这种请求处理模型没见过, 觉得很巧妙.&lt;/p&gt;
&lt;p&gt;HERE&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id29"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;功能&lt;/a&gt;&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="30%" /&gt;
&lt;col width="70%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;redis&lt;/th&gt;
&lt;th class="head"&gt;ssdb&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;hash&lt;/td&gt;
&lt;td&gt;hash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;list&lt;/td&gt;
&lt;td&gt;queue(不等于list)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;zset&lt;/td&gt;
&lt;td&gt;zset&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;hash的hset, hget 可以O(n)实现,  list 的rpush/lpop也可以O(n) 实现, 但是list的 LINSERT, LINDEX是O(n), 所以ssdb没有实现, 只是实现了可以保持O(n)操作的queue&lt;/p&gt;
&lt;p&gt;如何在kv上实现hash/zset/queue&lt;/p&gt;
&lt;p&gt;kv:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEF_PROC(get);
DEF_PROC(set);
&lt;/pre&gt;
&lt;p&gt;hash:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEF_PROC(hget);
DEF_PROC(hset);
&lt;/pre&gt;
&lt;p&gt;zset:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEF_PROC(zrank);
DEF_PROC(zrrank);
DEF_PROC(zrange);
&lt;/pre&gt;
&lt;p&gt;queue:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEF_PROC(qsize);
DEF_PROC(qfront);
DEF_PROC(qback);
DEF_PROC(qpush);
&lt;/pre&gt;
&lt;div class="section" id="kv"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id30"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;kv&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;get:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int proc_get(Server *serv, Link *link, const Request &amp;amp;req, Response *resp){
    if(req.size() &amp;lt; 2){
        resp-&amp;gt;push_back(&amp;quot;client_error&amp;quot;);
    }else{
        std::string val;
        int ret = serv-&amp;gt;ssdb-&amp;gt;get(req[1], &amp;amp;val);
        if(ret == 1){
            resp-&amp;gt;push_back(&amp;quot;ok&amp;quot;);      //找到  这里是ok这个字符串, 后面会转为redis协议.
            resp-&amp;gt;push_back(val);
        }else if(ret == 0){
            resp-&amp;gt;push_back(&amp;quot;not_found&amp;quot;);
        }else{
            log_error(&amp;quot;fail&amp;quot;);
            resp-&amp;gt;push_back(&amp;quot;fail&amp;quot;);
        }
    }
    return 0;
}

typedef std::vector&amp;lt;std::string&amp;gt; Response;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="hash"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id31"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;hash&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;实现了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEF_PROC(hsize);        // O(1)
DEF_PROC(hget);         // O(1)
DEF_PROC(hset);         // O(1)
DEF_PROC(hdel);         // O(1)
DEF_PROC(hincr);        // O(1)
DEF_PROC(hdecr);        // O(1)
DEF_PROC(hexists);      //O(1)

DEF_PROC(hclear);       // O(n)
DEF_PROC(hscan);        // O(n)
DEF_PROC(hrscan);       // O(n)
DEF_PROC(hkeys);        // O(n)
DEF_PROC(hvals);        // O(n)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;hkey: {a: b}&lt;/tt&gt; 存储结构:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_hkey : 1           #size = 1
_hkey_a : b         # hkey.a = b
&lt;/pre&gt;
&lt;p&gt;hset_one时, 组一个新的key:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// returns the number of newly added items
static int hset_one(const SSDB *ssdb, const Bytes &amp;amp;name, const Bytes &amp;amp;key, const Bytes &amp;amp;val, char log_type){
    ...
    int ret = 0;
    std::string dbval;
    if(ssdb-&amp;gt;hget(name, key, &amp;amp;dbval) == 0){ // not found
        std::string hkey = encode_hash_key(name, key); ///////////////////////////////组新key.
        ssdb-&amp;gt;binlogs-&amp;gt;Put(hkey, val.Slice());
        ssdb-&amp;gt;binlogs-&amp;gt;add(log_type, BinlogCommand::HSET, hkey);
        ret = 1;
    }
}

inline static
std::string encode_hash_key(const Bytes &amp;amp;name, const Bytes &amp;amp;key){
    std::string buf;
    buf.append(1, DataType::HASH);
    buf.append(1, (uint8_t)name.size());
    buf.append(name.data(), name.size());
    buf.append(1, '=');
    buf.append(key.data(), key.size());
    return buf;
}
&lt;/pre&gt;
&lt;p&gt;专门存size的key, 参考:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int incr_hsize(SSDB *ssdb, const Bytes &amp;amp;name, int64_t incr){
&lt;/pre&gt;
&lt;div class="section" id="hscan-hkeys"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id32"&gt;2.3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;hscan/hkeys的实现&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;需要客户端传来, 从那个key scan到哪个key:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int proc_hscan(Server *serv, Link *link, const Request &amp;amp;req, Response *resp){
    uint64_t limit = req[4].Uint64();
    HIterator *it = serv-&amp;gt;ssdb-&amp;gt;hscan(req[1], req[2], req[3], limit);
    resp-&amp;gt;push_back(&amp;quot;ok&amp;quot;);
    while(it-&amp;gt;next()){
        resp-&amp;gt;push_back(it-&amp;gt;key);
        resp-&amp;gt;push_back(it-&amp;gt;val);
    }
}
&lt;/pre&gt;
&lt;p&gt;用法应该是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hscan hkey a '' 100
&lt;/pre&gt;
&lt;p&gt;只有ssdb协议支持hscan, 不支持redis的hscan.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="queue"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id33"&gt;2.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;queue&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;实现了这些命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{STRATEGY_AUTO,         &amp;quot;lpush&amp;quot;,                &amp;quot;qpush_front&amp;quot;,          REPLY_STATUS},
{STRATEGY_AUTO,         &amp;quot;rpush&amp;quot;,                &amp;quot;qpush_back&amp;quot;,           REPLY_STATUS},
{STRATEGY_AUTO,         &amp;quot;lpop&amp;quot;,                 &amp;quot;qpop_front&amp;quot;,           REPLY_BULK},
{STRATEGY_AUTO,         &amp;quot;rpop&amp;quot;,                 &amp;quot;qpop_back&amp;quot;,            REPLY_BULK},
{STRATEGY_AUTO,         &amp;quot;llen&amp;quot;,                 &amp;quot;qsize&amp;quot;,                        REPLY_INT},
&lt;/pre&gt;
&lt;p&gt;只能在端上操作, 不能在list中间插入/删除等.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static uint64_t QFRONT_SEQ = 2;
static uint64_t QBACK_SEQ  = 3;
static uint64_t QITEM_MIN_SEQ = 10000;
static uint64_t QITEM_MAX_SEQ = 9223372036854775807ULL;
static uint64_t QITEM_SEQ_INIT = QITEM_MAX_SEQ/2;           //4611686018427387903
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;rpush qkey msg&lt;/tt&gt; 后, 存储结构如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
qkey_2: 4611686018427387903             //front下标
qkey_3:  4611686018427387904            //end下标
qkey_4611686018427387904                //msg
&lt;/pre&gt;
&lt;p&gt;这里 &lt;tt class="docutils literal"&gt;qkey_4611686018427387904&lt;/tt&gt; 后面这个数字在leveldb key里面是直接存binary格式, 8个字节.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="zset"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id34"&gt;2.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;zset&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;每个zset中的元素对应2个key: zset_key, zscore_key:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
k2 = encode_zscore_key(name, key, new_score);
k0 = encode_zset_key(name, key);
&lt;/pre&gt;
&lt;p&gt;如下操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
127.0.0.1:8888&amp;gt; Zadd zkey 3 a
(integer) 1
127.0.0.1:8888&amp;gt; ZSCORE zkey a
&amp;quot;3&amp;quot;
&lt;/pre&gt;
&lt;p&gt;存储结构:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
zkey: 1                 #size
zkey_a_3: ''            #zscore_key
zkey_a: 3               #zset_key
&lt;/pre&gt;
&lt;p&gt;每次zset, 先用zset_key 取的score, 构造zscore_key, 删除老记录.&lt;/p&gt;
&lt;p&gt;再写新的zset_key和zscore_key.&lt;/p&gt;
&lt;div class="section" id="zrank"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id35"&gt;2.3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;zrank&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;利用zscore_key, 遍历:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int64_t SSDB::zrank(const Bytes &amp;amp;name, const Bytes &amp;amp;key) const{
    ZIterator *it = ziterator(this, name, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, INT_MAX, Iterator::FORWARD);
    uint64_t ret = 0;
    while(true){
        if(it-&amp;gt;next() == false){
            ret = -1;
            break;
        }
        if(key == it-&amp;gt;key){
            break;
        }
        ret ++;
    }
    delete it;
    return ret;
}
&lt;/pre&gt;
&lt;p&gt;zrange类似&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id36"&gt;2.3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;名字空间划分&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;LevelDB里面, 每种key都有一个前缀:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class DataType{
public:
    static const char SYNCLOG       = 1;
    static const char KV            = 'k';
    static const char HASH          = 'h'; // hashmap(sorted by key)
    static const char HSIZE         = 'H';
    static const char ZSET          = 's'; // key =&amp;gt; score
    static const char ZSCORE        = 'z'; // key|score =&amp;gt; &amp;quot;&amp;quot;
    static const char ZSIZE         = 'Z';
    static const char QUEUE         = 'q';
    static const char QSIZE         = 'Q';
    static const char MIN_PREFIX = HASH;
    static const char MAX_PREFIX = ZSET;
};
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id37"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;主从相关&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="binlog"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id38"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;binlog&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;class Binlog
class BinlogQueue
class Transaction&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class Transaction{
private:
    BinlogQueue *logs;
public:
    Transaction(BinlogQueue *logs){
        this-&amp;gt;logs = logs;
        logs-&amp;gt;mutex.lock();
        logs-&amp;gt;begin();
    }

    ~Transaction(){
        // it is safe to call rollback after commit
        logs-&amp;gt;rollback();
        logs-&amp;gt;mutex.unlock();
    }
};
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="binlogqueue"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id39"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;BinlogQueue&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;整个SSDB只有一个BinlogQueue, 而且和数据存放在同一个leveldb里面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssdb-&amp;gt;binlogs = new BinlogQueue(ssdb-&amp;gt;db);
&lt;/pre&gt;
&lt;p&gt;启动SSDB时, 申请一个BinlogQueue对象, seek 到最后一条binlog, (最后一条是用 encode_seq_key(UINT64_MAX) )
然后启动一个线程, 来删Binlog:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int err = pthread_create(&amp;amp;tid, NULL, &amp;amp;BinlogQueue::log_clean_thread_func, this);
&lt;/pre&gt;
&lt;p&gt;具体写操作的时候:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int SSDB::set(const Bytes &amp;amp;key, const Bytes &amp;amp;val, char log_type){
    Transaction trans(binlogs);                                     //这里开始加锁

    std::string buf = encode_kv_key(key);
    binlogs-&amp;gt;Put(buf, val.Slice());                                 //这里是真正的写操作.
    binlogs-&amp;gt;add(log_type, BinlogCommand::KSET, buf);               //这里是记录一条日志, 说我对这个key, 做了一次set操作 (没记录value, 难道同步的时候再去取value?)
    leveldb::Status s = binlogs-&amp;gt;commit();                          //两个操作一起写
}
&lt;/pre&gt;
&lt;p&gt;其实这里 ssdb-&amp;gt;binlogs 相当于存储层, 所有 set/del leveldb 读写操作都是通过 ssdb-&amp;gt;binlog 进行的, 但是Get操作却不是通过ssdb-&amp;gt;binlog() 操作的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int64_t SSDB::qsize(const Bytes &amp;amp;name){
    std::string key = encode_qsize_key(name);
    std::string val;

    leveldb::Status s;
    s = db-&amp;gt;Get(leveldb::ReadOptions(), key, &amp;amp;val);
}
&lt;/pre&gt;
&lt;p&gt;这就不太统一, 不方便换下面的存储引擎.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id40"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Binlog&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有多种类型:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class BinlogCommand{
public:
    static const char NONE  = 0;
    static const char KSET  = 1;
    static const char KDEL  = 2;
    static const char HSET  = 3;
    static const char HDEL  = 4;
    static const char ZSET  = 5;
    static const char ZDEL  = 6;

    static const char BEGIN  = 7;
    static const char END    = 8;
};
&lt;/pre&gt;
&lt;p&gt;都是只记录key:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssdb-&amp;gt;binlogs-&amp;gt;add(log_type, BinlogCommand::HSET, hkey);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id41"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;主从同步&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;由Master 主动向从数据, 一个Server 有一个BackendSync实例:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Server::Server(SSDB *ssdb){
    this-&amp;gt;ssdb = ssdb;
    backend_sync = new BackendSync(ssdb);
    ...
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="slave"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id42"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;slave&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
void Slave::start(){
    load_status();
    log_debug(&amp;quot;last_seq: %&amp;quot; PRIu64 &amp;quot;, last_key: %s&amp;quot;,
        last_seq, hexmem(last_key.data(), last_key.size()).c_str());

    thread_quit = false;
    int err = pthread_create(&amp;amp;run_thread_tid, NULL, &amp;amp;Slave::_run_thread, this);
    if(err != 0){
        log_error(&amp;quot;can't create thread: %s&amp;quot;, strerror(err));
    }
}
&lt;/pre&gt;
&lt;p&gt;启动时load last_seq , 然后连上master, 发一个 sync140 告诉服务器从哪里开始发binlog:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sprintf(seq_buf, &amp;quot;%&amp;quot; PRIu64 &amp;quot;&amp;quot;, this-&amp;gt;last_seq);
const char *type = is_mirror? &amp;quot;mirror&amp;quot; : &amp;quot;sync&amp;quot;;
link-&amp;gt;send(&amp;quot;sync140&amp;quot;, seq_buf, this-&amp;gt;last_key, type);
&lt;/pre&gt;
&lt;p&gt;当Slave通过sync命令连上来, Master就会从这个socket把最新的更新发给Slave:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int proc_sync140(Server *serv, Link *link, const Request &amp;amp;req, Response *resp){
    serv-&amp;gt;backend_sync-&amp;gt;proc(link);
    return PROC_BACKEND;
}

int BackendSync::Client::sync(BinlogQueue *logs){
    Binlog log;
    ret = logs-&amp;gt;find_next(expect_seq, &amp;amp;log);

    switch(log.cmd()){
        case BinlogCommand::KSET:
        case BinlogCommand::HSET:
        case BinlogCommand::ZSET:
            ret = backend-&amp;gt;ssdb-&amp;gt;raw_get(log.key(), &amp;amp;val);
            if(ret == -1){
                log_error(&amp;quot;fd: %d, raw_get error!&amp;quot;, link-&amp;gt;fd());
            }else if(ret == 0){
                //log_debug(&amp;quot;%s&amp;quot;, hexmem(log.key().data(), log.key().size()).c_str());
                log_trace(&amp;quot;fd: %d, skip not found: %s&amp;quot;, link-&amp;gt;fd(), log.dumps().c_str());
            }else{
                log_trace(&amp;quot;fd: %d, %s&amp;quot;, link-&amp;gt;fd(), log.dumps().c_str());
                link-&amp;gt;send(log.repr(), val);
            }
&lt;/pre&gt;
&lt;p&gt;因为binlog只记录了key, 所以这里会再查一次, 把value查出来一起发过去(需要一次读)&lt;/p&gt;
&lt;p&gt;问题: 基准数据怎么过去呢? =&amp;gt; 可以拷贝.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dump"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id43"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;dump&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
backend_dump.cpp
backend_dump.h
&lt;/pre&gt;
&lt;p&gt;有个dump命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PROC(dump, &amp;quot;b&amp;quot;),
&lt;/pre&gt;
&lt;p&gt;相当于redis 的keys,&lt;/p&gt;
&lt;p&gt;收到这个命令, 服务器新开一个线程, 把所有数据通过一个socket发过来, 问题:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;非redis 协议&lt;/li&gt;
&lt;li&gt;容易断&lt;/li&gt;
&lt;li&gt;有scan, 应该就不需要这个了 (不过这个简单, 简单一个命令就可以做backup了)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-github/ndb$ printf '*1\r\n$4\r\ndump\r\n' | socat - TCP:localhost:8888,shut-close | xxd
0000000: 350a 6265 6769 6e0a 0a33 0a73 6574 0a39  5.begin..3.set.9
0000010: 0a01 0000 0000 001e 953a 0a32 370a 3a95  .........:.27.:.
0000020: 1e00 0000 0000 0101 6b6b 6579 3a30 3030  ........kkey:000
0000030: 3030 3234 3833 3631 320a 0a33 0a73 6574  002483612..3.set
0000040: 0a39 0a01 0000 0000 001e 953b 0a32 370a  .9.........;.27.
0000050: 3b95 1e00 0000 0000 0101 6b6b 6579 3a30  ;.........kkey:0
0000060: 3030 3030 3738 3833 3133 310a 0a33 0a73  00007883131..3.s
0000070: 6574 0a39 0a01 0000 0000 001e 953c 0a32  et.9.........&amp;lt;.2
0000080: 370a 3c95 1e00 0000 0000 0101 6b6b 6579  7.&amp;lt;.........kkey
0000090: 3a30 3030 3030 3236 3435 3335 320a 0a33  :000002645352..3
00000a0: 0a73 6574 0a39 0a01 0000 0000 001e 953d  .set.9.........=
00000b0: 0a32 370a 3d95 1e00 0000 0000 0101 6b6b  .27.=.........kk
00000c0: 6579 3a30 3030 3030 3935 3033 3539 380a  ey:000009503598.
00000d0: 0a33 0a73 6574 0a39 0a01 0000 0000 001e  .3.set.9........
00000e0: 953e 0a32 370a 3e95 1e00 0000 0000 0101  .&amp;gt;.27.&amp;gt;.........
00000f0: 6b6b 6579 3a30 3030 3030 3938 3038 3139  kkey:00000980819
0000100: 360a 0a33 0a73 6574 0a39 0a01 0000 0000  6..3.set.9......
0000110: 001e 953f 0a32 370a 3f95 1e00 0000 0000  ...?.27.?.......
0000120: 0101 6b6b 6579 3a30 3030 3030 3238 3232  ..kkey:000002822
0000130: 3337 360a 0a33 0a73 6574 0a39 0a01 0000  376..3.set.9....
0000140: 0000 001e 9540 0a32 370a 4095 1e00 0000  .....&amp;#64;.27.&amp;#64;.....
0000150: 0000 0101 6b6b 6579 3a30 3030 3030 3134  ....kkey:0000014
0000160: 3936 3935 320a 0a33 0a73 6574 0a39 0a01  96952..3.set.9..
0000170: 0000 0000 001e 9541 0a32 370a 4195 1e00  .......A.27.A...
0000180: 0000 0000 0101 6b6b 6579 3a30 3030 3030  ......kkey:00000
0000190: 3432 3033 3036 370a 0a33 0a73 6574 0a39  4203067..3.set.9
00001a0: 0a01 0000 0000 001e 9542 0a32 370a 4295  .........B.27.B.
00001b0: 1e00 0000 0000 0101 6b6b 6579 3a30 3030  ........kkey:000
00001c0: 3030 3139 3133 3036 320a 0a33 0a73 6574  001913062..3.set
00001d0: 0a39 0a01 0000 0000 001e 9543 0a32 370a  .9.........C.27.
00001e0: 4395 1e00 0000 0000 0101 6b6b 6579 3a30  C.........kkey:0
00001f0: 3030 3030 3637 3432 3136 310a 0a33 0a65  00006742161..3.e
0000200: 6e64 0a32 0a31 300a 0a                   nd.2.10..
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id44"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="incr"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id45"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;incr 如何保证原子性&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;通过Transaction上的锁实现.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="expire"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id46"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何实现expire&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ssdb为每个带有过期设置的key, 保存了2个结构:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;内存里面的一个sorted_set (全量)&lt;/li&gt;
&lt;li&gt;leveldb里面以 EXPIRATION_LIST_KEY 开头的一系列key.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ssdb 里面保留这个key:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define EXPIRATION_LIST_KEY &amp;quot;\xff\xff\xff\xff\xff|EXPIRE_LIST|KV&amp;quot;
&lt;/pre&gt;
&lt;p&gt;用这个key作为一个大zset(基于ssdb在leveldb上提供的zset), 当需要设置一个key的ttl时, 就向这个zset里面设置某个key的超时时间:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int ExpirationHandler::set_ttl(const Bytes &amp;amp;key, int ttl){
    int64_t expired = time_ms() + ttl * 1000;
    char data[30];
    int size = snprintf(data, sizeof(data), &amp;quot;%&amp;quot; PRId64, expired);
    if(size &amp;lt;= 0){
        log_error(&amp;quot;snprintf return error!&amp;quot;);
        return -1;
    }

    Locking l(&amp;amp;mutex);
    int ret = ssdb-&amp;gt;zset(this-&amp;gt;list_name, key, Bytes(data, size));

}
&lt;/pre&gt;
&lt;p&gt;同时还会放到一个内存的sorted_set(expiration_keys)里面去:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
expiration_keys.add(key.String(), expired);
&lt;/pre&gt;
&lt;p&gt;ssdb启动后, 会有一个线程把所有 EXPIRATION_LIST_KEY 这个 zset 里面的所有key扫描出来, 放到内存的 expiration_keys 里.&lt;/p&gt;
&lt;p&gt;回收时, 由一个线程从 expiration_keys 里面取出每个key, 把key和它对应的expire记录删掉:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if(handler-&amp;gt;expiration_keys.front(&amp;amp;key, &amp;amp;score)){
    int64_t now = time_ms();
    if(score &amp;lt;= now){
        log_debug(&amp;quot;expired %s&amp;quot;, key-&amp;gt;c_str());
        ssdb-&amp;gt;del(*key);
        ssdb-&amp;gt;zdel(handler-&amp;gt;list_name, *key);
        handler-&amp;gt;expiration_keys.pop_front();
        continue;
    }
}
&lt;/pre&gt;
&lt;p&gt;问题是: 所有的key都要装到内存, 内存会比较大, 而读的时候又没有利用上这个内存.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="benchmark"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id47"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;benchmark&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请看:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="/ssdb-benchmark.html"&gt;ssdb benchmark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id48"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;读性能的问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;benchmark结果: &lt;strong&gt;100G数据&lt;/strong&gt; 时, 读性能稳定在大约5000qps&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compact"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id50"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;如何compact&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;貌似是一个命令. 需要人工调用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="expirekey"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;所有expire的key记录在内存&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果有10亿条, 每条100字节, 就需要100G+内存.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;兼容问题&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="del"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id53"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;del 兼容&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;因为leveldb 的接口, 删除实际上是一个写操作(写为空串).
所以删除接口不能返回这个key在是真的删了, 还是本来就不存在.&lt;/p&gt;
&lt;p&gt;所以在删除一个不存在的key时 for redis:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-github/redis/src$ redis-cli -p 2000 del xxx
(integer) 0
&lt;/pre&gt;
&lt;p&gt;for ssdb:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-github/redis/src$ redis-cli -p 8888 del xxx
(integer) 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ttlkey"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id54"&gt;4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;ttl一个不存在的key&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
127.0.0.1:8888&amp;gt; ttl k
(error) ERR
&lt;/pre&gt;
&lt;p&gt;redis:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
127.0.0.1:5527&amp;gt; ttl k
(integer) -2
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id55"&gt;4.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;没有expire命令&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;改为通过ttl命令设置expire.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="scan"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id56"&gt;4.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;scan类&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="id17"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id57"&gt;4.4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;scan&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;一次在一个连接上吐回所有key, 而且要全放到内存resp里面再一次吐出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int proc_scan(Server *serv, Link *link, const Request &amp;amp;req, Response *resp){
    if(req.size() &amp;lt; 4){
        resp-&amp;gt;push_back(&amp;quot;client_error&amp;quot;);
    }else{
        uint64_t limit = req[3].Uint64();
        KIterator *it = serv-&amp;gt;ssdb-&amp;gt;scan(req[1], req[2], limit);
        resp-&amp;gt;push_back(&amp;quot;ok&amp;quot;);
        while(it-&amp;gt;next()){
            resp-&amp;gt;push_back(it-&amp;gt;key);
            resp-&amp;gt;push_back(it-&amp;gt;val);
        }
        delete it;
    }
    return 0;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-hscan"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id58"&gt;4.4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;没有redis 的hscan&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;只有ssdb协议支持hscan, 用法是给出范围.&lt;/p&gt;
&lt;p&gt;支持redis的hgetall, hkeys, hvals&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category><category term="redis"></category></entry><entry><title>twemproxy错误处理</title><link href="/twemproxy-error-handler.html" rel="alternate"></link><updated>2014-07-23T09:37:30+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-23:twemproxy-error-handler.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理错误&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#client-close" id="id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;client_close&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#server-close" id="id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;server_close&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id7"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;各个回调中应该怎么返回错误和错误检查&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#a-client-proxy" id="id8"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;(a)client-&amp;gt;proxy 路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#b-proxy-backend" id="id9"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;(b)proxy-&amp;gt;backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c-backend-proxy" id="id10"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;(c)backend-&amp;gt;proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#d-proxy-client" id="id11"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;(d)proxy-&amp;gt;client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conn-err" id="id13"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;可能设置conn-&amp;gt;err的地方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#return" id="id14"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;可能通过return 方式返回错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#msg-err" id="id15"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;可能设置msg-&amp;gt;err的地方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what-i-do" id="id16"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;what i do&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;错误处理是一个系统里面重要而容易忽略的环节, 我们读代码比写代码简单, 很大程度上就是因为读代码时基本不用考虑错误处理逻辑.&lt;/p&gt;
&lt;p&gt;twemproxy中, 主要的错误有:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;超内存 需要处理的地方最多&lt;/li&gt;
&lt;li&gt;连接后端错误&lt;/li&gt;
&lt;li&gt;server/cliet连接断掉&lt;/li&gt;
&lt;li&gt;msg 超时&lt;/li&gt;
&lt;li&gt;后端返回错误(E)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理错误&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;两种错误处理:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;关连接:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如内存不够.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;向客户读返回一个 Err response:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;能识别的逻辑错误, 比如连后端失败.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们先看conn上的几个回调&lt;/p&gt;
&lt;pre class="literal-block"&gt;
client:

    conn-&amp;gt;recv = msg_recv;
    conn-&amp;gt;recv_next = req_recv_next;
    conn-&amp;gt;recv_done = req_recv_done;

    conn-&amp;gt;send = msg_send;
    conn-&amp;gt;send_next = rsp_send_next;
    conn-&amp;gt;send_done = rsp_send_done;
    conn-&amp;gt;close = client_close;
    conn-&amp;gt;active = client_active;

server:

    conn-&amp;gt;recv = msg_recv;
    conn-&amp;gt;recv_next = rsp_recv_next;
    conn-&amp;gt;recv_done = rsp_recv_done;

    conn-&amp;gt;send = msg_send;
    conn-&amp;gt;send_next = req_send_next;
    conn-&amp;gt;send_done = req_send_done;

    conn-&amp;gt;close = server_close;
    conn-&amp;gt;active = server_active;
&lt;/pre&gt;
&lt;p&gt;最外层, 如果core_recv/core_send返回 非NC_Ok, 或者设置了 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;done&lt;/span&gt;&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;err&lt;/span&gt;&lt;/tt&gt; , 直接关连接:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
core_core(void *arg, uint32_t events)
{
    if (events &amp;amp; EVENT_ERR) {
        core_error(ctx, conn);
        return NC_ERROR;
    }

    if (events &amp;amp; EVENT_READ) {
        status = core_recv(ctx, conn);
        if (status != NC_OK || conn-&amp;gt;done || conn-&amp;gt;err) {
            core_close(ctx, conn);
            return NC_ERROR;
        }
    }

    if (events &amp;amp; EVENT_WRITE) {
        status = core_send(ctx, conn);
        if (status != NC_OK || conn-&amp;gt;done || conn-&amp;gt;err) {
            core_close(ctx, conn);
            return NC_ERROR;
        }
    }

    return NC_OK;
}
&lt;/pre&gt;
&lt;p&gt;这里:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;core_recv&lt;/tt&gt; 就是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;recv&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;core_send&lt;/tt&gt; 就是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;send&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;core_close 会调用 &lt;tt class="docutils literal"&gt;server_close&lt;/tt&gt; 或者 &lt;tt class="docutils literal"&gt;client_close&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="client-close"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;client_close&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;client_close_stats&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;conn-&amp;gt;unref (暂时不管)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;如果 conn-&amp;gt;rmsg 存在, 说明连接的读缓冲区有内容未处理,
把这个rmsg 丢掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;smsg&lt;/span&gt;&lt;/tt&gt;,  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;imsg_q&lt;/span&gt;&lt;/tt&gt; 应该是为空的
conn 用rmsg做读缓冲, 读到了就放到server_conn-&amp;gt;omsg_q 里面, 所以clietn_conn-&amp;gt;smsg没用, client_conn-&amp;gt;imsg_q 也是完全没用
参考 &lt;a class="reference external" href="|filename|/notes/redis/twemproxy.rst"&gt;|filename|/notes/redis/twemproxy.rst&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;如果 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;omsg_q&lt;/span&gt;&lt;/tt&gt; 里面有消息, 这些消息已经发给后端了, 正在等待后端响应:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
for (msg = TAILQ_FIRST(&amp;amp;conn-&amp;gt;omsg_q); msg != NULL; msg = nmsg) {
    nmsg = TAILQ_NEXT(msg, c_tqe);

    conn-&amp;gt;dequeue_outq(ctx, conn, msg);

    if (msg-&amp;gt;done) {
        //日志: 这个消息的rsp被我丢了.
        req_put(msg);
    } else {
        msg-&amp;gt;swallow = 1;

        ASSERT(msg-&amp;gt;request);
        ASSERT(msg-&amp;gt;peer == NULL); //响应还没回来

        //日志: 这个消息被我标记为 swallow
        log_debug(LOG_INFO, &amp;quot;close c %d schedule swallow of req %&amp;quot;PRIu64&amp;quot; &amp;quot;
                  &amp;quot;len %&amp;quot;PRIu32&amp;quot; type %d&amp;quot;, conn-&amp;gt;sd, msg-&amp;gt;id, msg-&amp;gt;mlen,
                  msg-&amp;gt;type);
    }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于 &lt;tt class="docutils literal"&gt;swallow&lt;/tt&gt;, 英语意思是 &lt;tt class="docutils literal"&gt;吞没&lt;/tt&gt;, 只有在上面这种情况下, 才会设置swallow标志, 对于这样的消息, 它的rsp回来之后, 就不应该转给client了, 而直接丢掉就行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static bool
rsp_filter(struct context *ctx, struct conn *conn, struct msg *msg)
{
    pmsg = TAILQ_FIRST(&amp;amp;conn-&amp;gt;omsg_q); //这是req, 至于为什么用 TAILQ_FIRST, 此时还没有设置msg-&amp;gt;peer.

    ASSERT(pmsg-&amp;gt;peer == NULL);
    ASSERT(pmsg-&amp;gt;request &amp;amp;&amp;amp; !pmsg-&amp;gt;done);
    if (pmsg-&amp;gt;swallow) {
        conn-&amp;gt;dequeue_outq(ctx, conn, pmsg);
        pmsg-&amp;gt;done = 1;

        log_debug(LOG_INFO, &amp;quot;swallow rsp %&amp;quot;PRIu64&amp;quot; len %&amp;quot;PRIu32&amp;quot; of req &amp;quot;
                  &amp;quot;%&amp;quot;PRIu64&amp;quot; on s %d&amp;quot;, msg-&amp;gt;id, msg-&amp;gt;mlen, pmsg-&amp;gt;id,
                  conn-&amp;gt;sd);

        rsp_put(msg);
        req_put(pmsg);
        return true;
    }
}
&lt;/pre&gt;
&lt;p&gt;另外在server_close的时候, 对server_conn-&amp;gt;imsg_q 和server_conn-&amp;gt;omsg_q, 如果有swallow req, 也直接丢掉(见server_close).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="server-close"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;server_close&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;server_close_stats&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;conn-&amp;gt;unref(conn)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;把server_conn中 的imsg_q 和omsg_q 中的消息 设置&lt;/p&gt;
&lt;pre class="literal-block"&gt;
msg-&amp;gt;done = 1
msg-&amp;gt;error = 1
msg-&amp;gt;err = conn-&amp;gt;err;
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;检查当前 c_conn上有没有完成的req, 给返回(因为这里对一些req设置了msg-&amp;gt;done, 所以有可能有完成的req):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (raeq_done(c_conn, TAILQ_FIRST(&amp;amp;c_conn-&amp;gt;omsg_q))) {
    event_add_out(ctx-&amp;gt;evb, msg-&amp;gt;owner);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;各个回调中应该怎么返回错误和错误检查&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;参看这个神图:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
*
*             Client+             Proxy           Server+
*                              (nutcracker)
*                                   .
*       msg_recv {read event}       .       msg_recv {read event}
*         +                         .                         +
*         |                         .                         |
*         \                         .                         /
*         req_recv_next             .             rsp_recv_next
*           +                       .                       +
*           |                       .                       |       Rsp
*           req_recv_done           .           rsp_recv_done      &amp;lt;===
*             +                     .                     +
*             |                     .                     |
*    Req      \                     .                     /
*    ===&amp;gt;     req_filter*           .           *rsp_filter
*               +                   .                   +
*               |                   .                   |
*               \                   .                   /
*               req_forward-//  (a) . (c)  \\-rsp_forward
*                                   .
*                                   .
*       msg_send {write event}      .      msg_send {write event}
*         +                         .                         +
*         |                         .                         |
*    Rsp' \                         .                         /     Req'
*   &amp;lt;===  rsp_send_next             .             req_send_next     ===&amp;gt;
*           +                       .                       +
*           |                       .                       |
*           \                       .                       /
*           rsp_send_done-//    (d) . (b)    //-req_send_done
*
*
* (a) -&amp;gt; (b) -&amp;gt; (c) -&amp;gt; (d) is the normal flow of transaction consisting
* of a single request response, where (a) and (b) handle request from
* client, while (c) and (d) handle the corresponding response from the
* server.
&lt;/pre&gt;
&lt;div class="section" id="a-client-proxy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;(a)client-&amp;gt;proxy 路径&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们看core_recv 的调用链, 可能从什么地方返回这个错误码.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;core_recv()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;conn-&amp;gt;recv(), 即msg_recv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;msg_recv_chain(),&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;无内存: return NC_ENOMEM;&lt;/li&gt;
&lt;li&gt;读返回EAGAIN: return NC_OK,&lt;/li&gt;
&lt;li&gt;读出错: return NC_ERROR&lt;/li&gt;
&lt;li&gt;返回msg_parse()&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;msg_parse(), 调用msg-&amp;gt;parser(msg),&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;如果解析到一条消息(MSG_PARSE_OK), 返回msg_parsed()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;如果需要REPAIR, 返回msg_repair()&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;msg_repair() 就是简单split一下, 可能返回NC_ENOMEM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;如果parser出错, 函数里面同时设置 conn-&amp;gt;err, 并且返回 NC_ERROR&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
msg_parse(struct context *ctx, struct conn *conn, struct msg *msg)
{
    msg-&amp;gt;parser(msg);

    switch (msg-&amp;gt;result) {
    case MSG_PARSE_OK:
        status = msg_parsed(ctx, conn, msg);
        break;

    case MSG_PARSE_REPAIR:
        status = msg_repair(ctx, conn, msg);
        break;

    case MSG_PARSE_AGAIN:
        status = NC_OK;
        break;

    default:
        status = NC_ERROR;
        conn-&amp;gt;err = errno;
        break;
    }

    return conn-&amp;gt;err != 0 ? NC_ERROR : status;
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;所以 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;msg-&amp;gt;parser()&lt;/span&gt;&lt;/tt&gt; 函数里面, 如果要返回错误, 是通过msg-&amp;gt;result设置为一个错误码做的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
r-&amp;gt;result = MSG_PARSE_ERROR;
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;接下来的重点是 &lt;tt class="docutils literal"&gt;msg_parsed()&lt;/tt&gt; , 他的返回值也会直接返回到core_core:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
 static rstatus_t
 msg_parsed(struct context *ctx, struct conn *conn, struct msg *msg)
 {
     conn-&amp;gt;recv_done(ctx, conn, msg, nmsg);

     return NC_OK;
 }

这里挺重要, 这个函数虽然调用了conn-&amp;gt;recv_done, 但是直接返回NC_OK, 而没有管conn-&amp;gt;recv_done的返回值, 实际上, conn-&amp;gt;recv_done() 没有返回值::

 conn_recv_done_t   recv_done;     /* read done handler */
 typedef void (*conn_recv_done_t)(struct context *, struct conn *, struct msg *, struct msg *);
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;到这里return链断了, 下面只能通过设置conn-&amp;gt;err来表示错误&lt;/strong&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;req_recv_done调用:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;req_forward (同样是一个void函数)   TODO: 这里在fragement里面, 我需要处理错误, 处理方法是设置c_conn-&amp;gt;err, 这还不好处理..&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;req_forward 如果出错,  是通过 &lt;tt class="docutils literal"&gt;req_forward_error&lt;/tt&gt; 来告诉客户端的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void
req_forward(struct context *ctx, struct conn *c_conn, struct msg *msg)
{
    s_conn = server_pool_conn(ctx, c_conn-&amp;gt;owner, key, keylen);
    if (s_conn == NULL) {
        req_forward_error(ctx, c_conn, msg);                //这里并不会设置c_conn-&amp;gt;err, 这时如果设置c_conn-&amp;gt;err, 就会直接关连接,
                                                            //这里的处理方法是: 设置msg-&amp;gt;err, 于是后面会构造一个ERR rsp返回给客户端, 这并不算一个连接错误.
        return;
    }

    c_conn-&amp;gt;enqueue_outq(ctx, c_conn, msg);                 //简单队列操作.
    s_conn-&amp;gt;enqueue_inq(ctx, s_conn, msg);

    if (TAILQ_EMPTY(&amp;amp;s_conn-&amp;gt;imsg_q)) {
        status = event_add_out(ctx-&amp;gt;evb, s_conn);
        if (status != NC_OK) {
            req_forward_error(ctx, c_conn, msg);            //这里会告诉客户端出错.
            s_conn-&amp;gt;err = errno;                            //这里设置 s_conn-&amp;gt;err, 关掉后端连接(什么时候处理 这里的s_conn-&amp;gt;err????? 还有机会有事件么?)
            return;
        }
    }
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;req_forward_error 需要标记msg-&amp;gt;err, 此时消息未被转发到后端, 此时为了告诉客户端出错, 需要:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在c_conn上开始 ev_out 事件&lt;/li&gt;
&lt;li&gt;可写时, 构造一个ERR rsp返回给客户端.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体过程如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void
req_forward_error(struct context *ctx, struct conn *conn, struct msg *msg)
{
    rstatus_t status;

    ASSERT(conn-&amp;gt;client &amp;amp;&amp;amp; !conn-&amp;gt;proxy);

    msg-&amp;gt;done = 1;
    msg-&amp;gt;error = 1;
    msg-&amp;gt;err = errno;  //(如果内存分配失败, errno会被设为12, 对应错误消息'Cannot allocate memory')

    if (req_done(conn, TAILQ_FIRST(&amp;amp;conn-&amp;gt;omsg_q))) {
        status = event_add_out(ctx-&amp;gt;evb, conn);
        if (status != NC_OK) {
            conn-&amp;gt;err = errno;
        }
    }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里, 这个cliet-&amp;gt;proxy 的过程所有的出错路径都排查了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="b-proxy-backend"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;(b)proxy-&amp;gt;backend&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="c-backend-proxy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;(c)backend-&amp;gt;proxy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是另一个recv路径, 前半部分和(a)路径基本一样:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;core_recv()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;conn-&amp;gt;recv(), 即msg_recv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;msg_recv_chain(),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;msg_parse(), 调用msg-&amp;gt;parser(msg),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;msg_parsed()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;到这里return链断了, 下面只能通过设置conn-&amp;gt;err来表示错误&lt;/strong&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;rsp_recv_done() 和rsp_forward():&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void
rsp_forward(struct context *ctx, struct conn *s_conn, struct msg *msg)
{
    pmsg-&amp;gt;peer = msg;
    msg-&amp;gt;peer = pmsg;

    msg-&amp;gt;pre_coalesce(msg);                                         //void函数.

    c_conn = pmsg-&amp;gt;owner;
    ASSERT(c_conn-&amp;gt;client &amp;amp;&amp;amp; !c_conn-&amp;gt;proxy);

    if (req_done(c_conn, TAILQ_FIRST(&amp;amp;c_conn-&amp;gt;omsg_q))) {           //这里调用req_done.
        status = event_add_out(ctx-&amp;gt;evb, c_conn);
        if (status != NC_OK) {
            c_conn-&amp;gt;err = errno;
        }
    }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;这里rsp_forward比req_forward复杂, req_forward只是简单的dequeue_outq, enqueue_inq, event_add_out, 并没有太多的寄回设置conn-&amp;gt;err.&lt;/p&gt;
&lt;p&gt;rsp_forward则可能在pre_coalesce(), req_done(), post_coalesce() 函数里面设置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;pre_coalesce():&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void
redis_pre_coalesce(struct msg *r)
{
    pr-&amp;gt;frag_owner-&amp;gt;nfrag_done++;

    switch (r-&amp;gt;type) {
    case MSG_RSP_REDIS_INTEGER:
        xxx;
    case MSG_RSP_REDIS_MULTIBULK:
        xxx;
    case MSG_RSP_REDIS_STATUS:
        xxx;
    default:
        mbuf = STAILQ_FIRST(&amp;amp;r-&amp;gt;mhdr);
        log_hexdump(LOG_ERR, mbuf-&amp;gt;pos, mbuf_length(mbuf), &amp;quot;rsp fragment &amp;quot;
                    &amp;quot;with unknown type %d&amp;quot;, r-&amp;gt;type);
        pr-&amp;gt;error = 1;
        pr-&amp;gt;err = EINVAL;       //这里都只是设置了msg-&amp;gt;err.
        break;
    }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在mget-improve之前, req_done() post_coalesce 都不会做什么设置.
TODO: 这里的post_coalesce我需要处理错误, 处理方法应该类似pre_coalesce, 设置msg-&amp;gt;error, msg-&amp;gt;err&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="d-proxy-client"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;(d)proxy-&amp;gt;client&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;接(c), rsp_forward 会在c_conn上开启out事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
status = event_add_out(ctx-&amp;gt;evb, c_conn);
&lt;/pre&gt;
&lt;p&gt;当c_conn可写时, 会触发 msg_send-&amp;gt;rsp_send_next-&amp;gt;rsp_send_done 路径.&lt;/p&gt;
&lt;p&gt;这里前几步和 (a) 也一样, 出错了直接通过返回值返回:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;msg_send 可能调用msg_send_chain 和rsp_send_next.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;rsp_send_next:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (req_error(conn, pmsg)) { //这里也不会设置conn-&amp;gt;err. 所以如果在msg层没有内存, 也会返回一个错误给客户端. 但是如果在rsp_make_error的时候再次没内存, 就只能关闭连接了.
    msg = rsp_make_error(ctx, conn, pmsg);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;msg_send_chain 可能通过返回值告诉最上层发生了错误 (直接调用conn_sendv):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
msg_send_chain(struct context *ctx, struct conn *conn, struct msg *msg)
{
    conn-&amp;gt;smsg = NULL;
    n = conn_sendv(conn, &amp;amp;sendv, nsend);

    conn-&amp;gt;send_done(ctx, conn, msg);

    if (n &amp;gt;= 0) {
        return NC_OK;
    }
    return (n == NC_EAGAIN) ? NC_OK : NC_ERROR;
}
- 这里可能调用rsp_send_done, 单此时已经不能设置什么错误了
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因为总的能逻辑就是 &lt;tt class="docutils literal"&gt;core_core&lt;/tt&gt; 里面的这段逻辑:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
status = core_recv(ctx, conn);
if (status != NC_OK || conn-&amp;gt;done || conn-&amp;gt;err) {
    core_close(ctx, conn);
    return NC_ERROR;
}
&lt;/pre&gt;
&lt;p&gt;在处理请求中, 比如读msg的时候, 发现没有内存了, 或者解析出错了, 有两个方法返回错误:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;通过返回值在core_recv 返回一个非NC_OK值.&lt;/li&gt;
&lt;li&gt;设置conn-&amp;gt;err 即可,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在forward到后端时, 后端连接失败, 则可以通过 &lt;tt class="docutils literal"&gt;req_forward_error&lt;/tt&gt; 函数, 设置 msg-&amp;gt;err,
这时在 &lt;tt class="docutils literal"&gt;rsp_send_next&lt;/tt&gt; 中会用rsp_make_error生成一个err response返回给客户端.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;我们在forward时遇到内存不够, 调用req_forward_error就够了.&lt;/li&gt;
&lt;li&gt;收到response时遇到内存不够, 手动设置 msg-&amp;gt;err就行.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="conn-err"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;可能设置conn-&amp;gt;err的地方&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;parse失败.&lt;/li&gt;
&lt;li&gt;调nc_read() nc_writev(), server_connect() 出错.&lt;/li&gt;
&lt;li&gt;调用event_add_xx(), event_del_xx()&lt;/li&gt;
&lt;li&gt;req_get()/rsp_get() 调用msg_get() 无内存返回NULL&lt;/li&gt;
&lt;li&gt;rsp_make_error 无内存返回NULL&lt;/li&gt;
&lt;li&gt;发生timeout&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="return"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;可能通过return 方式返回错误&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
msg_parsed(struct context *ctx, struct conn *conn, struct msg *msg)
{
    ...
    nmsg = msg_get(msg-&amp;gt;owner, msg-&amp;gt;request, conn-&amp;gt;redis);
    if (nmsg == NULL) {
        mbuf_put(nbuf);
        return NC_ENOMEM;
    }
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="msg-err"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;可能设置msg-&amp;gt;err的地方&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
msg-&amp;gt;ferror         #是否有frag错误.
msg-&amp;gt;error          #错误标志, 0/1
msg-&amp;gt;err = errno;   #errno.
&lt;/pre&gt;
&lt;p&gt;比如memcache_pre_coalesce:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void
redis_pre_coalesce(struct msg *r)
{
    pr-&amp;gt;frag_owner-&amp;gt;nfrag_done++;

    switch (r-&amp;gt;type) {
    case MSG_RSP_REDIS_INTEGER:
        xxx;
    case MSG_RSP_REDIS_MULTIBULK:
    if (pr-&amp;gt;first_fragment) {
        mbuf = mbuf_get();
        if (mbuf == NULL) {
            pr-&amp;gt;error = 1;
            pr-&amp;gt;err = EINVAL;
            return;
        }
        STAILQ_INSERT_HEAD(&amp;amp;r-&amp;gt;mhdr, mbuf, next);
    }
    case MSG_RSP_REDIS_STATUS:
        xxx;
    default:
        mbuf = STAILQ_FIRST(&amp;amp;r-&amp;gt;mhdr);
        log_hexdump(LOG_ERR, mbuf-&amp;gt;pos, mbuf_length(mbuf), &amp;quot;rsp fragment &amp;quot;
                    &amp;quot;with unknown type %d&amp;quot;, r-&amp;gt;type);
        pr-&amp;gt;error = 1;
        pr-&amp;gt;err = EINVAL;       //这里都只是设置了msg-&amp;gt;err.
        break;
    }
}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
void
redis_pre_coalesce(struct msg *r)
{
    if (pr-&amp;gt;first_fragment) {
        mbuf = mbuf_get();
        if (mbuf == NULL) {
            pr-&amp;gt;error = 1;
            pr-&amp;gt;err = EINVAL;
            return;
        }
        STAILQ_INSERT_HEAD(&amp;amp;r-&amp;gt;mhdr, mbuf, next);
    }
    ...
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-i-do"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;what i do&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;从前的msg_fragment是在msg_parsed里面, 还能通过return 返回错误.
因为作者认为在msg_parsed 之后, 消息必然在recv_done里面传给后端了, 不会出错了. 所以recv_done等函数都是void函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
msg_parsed(struct context *ctx, struct conn *conn, struct msg *msg)
{
    conn-&amp;gt;recv_done(ctx, conn, msg, nmsg);

    return NC_OK;
}
&lt;/pre&gt;
&lt;p&gt;TODO 3: 我的fragement也得放到这里的msg_parsed里面, 否则的话, 就得修改 recv_done的返回值了, 这个动作更大些.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>我们还需要80列的限制么</title><link href="/do_we_need_80_column_rule.html" rel="alternate"></link><updated>2014-07-21T13:02:07+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-21:do_we_need_80_column_rule.html</id><summary type="html">&lt;p&gt;现在, 我们写代码通常不限制80列. 现在我们的屏幕都很宽, 一般都能放180列到200列. 所以貌似没必要限制80列了&lt;/p&gt;
&lt;p&gt;但是, 我们经常用diff工具来查看代码, 这样超过80列的代码在diff工具中就不好看了.&lt;/p&gt;
&lt;p&gt;所以, 我们还是坚持80列原则把.&lt;/p&gt;
</summary><category term="all"></category></entry><entry><title>从twemproxy计算 redis hitrate</title><link href="/redis-hitrate.html" rel="alternate"></link><updated>2014-07-11T11:37:13+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-11:redis-hitrate.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#get" id="id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;GET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hmget" id="id2"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;HMGET:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hgetall" id="id3"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;HGETALL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mget" id="id4"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;MGET&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;如何从proxy日志中, 理容response的字节数计算命中率:&lt;/p&gt;
&lt;div class="section" id="get"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;GET&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;key 不存在时:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 get kkk
(nil)
$-1..
&lt;/pre&gt;
&lt;p&gt;key存在时:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 set k v
OK
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 get k
&amp;quot;v&amp;quot;

$1..v..
&lt;/pre&gt;
&lt;p&gt;判断:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if rsp_len &amp;gt; 5 :
    hit
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="hmget"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;HMGET:&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;key 不存在时, 或者请求的field都不存在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 hmget kkk 1 2
1) (nil)
2) (nil)

*2..$-1..$-1..
&lt;/pre&gt;
&lt;p&gt;key 存在, 请求的field有存在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 hmset kk 1 xxx
OK
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 hmget kk 1 2
1) &amp;quot;xxx&amp;quot;
2) (nil)

*2..$3..xxx..$-1..
&lt;/pre&gt;
&lt;p&gt;这样判断:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nfiled = narg - 2
if rsp_len &amp;gt; 3+len(str(nfeild))+(5*nfield):
    hit
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="hgetall"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;HGETALL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;key 存在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 hgetall kk
1) &amp;quot;1&amp;quot;
2) &amp;quot;xxx&amp;quot;
*2..$1..1..$3..xxx..
&lt;/pre&gt;
&lt;p&gt;key不存在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ redis-cli -p 4100 hgetall kkk
(empty list or set)

|*0..|
&lt;/pre&gt;
&lt;p&gt;判断:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if rsp_len &amp;gt; 4:
    hit
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="mget"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;MGET&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用的比较少, 不能简单的从rsp_len来判断.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>honx分析</title><link href="/honx.html" rel="alternate"></link><updated>2014-07-10T09:41:04+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-10:honx.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#chromehttps-proxy" id="id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;chrome支持https proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id7"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试破解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id8"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;这个方法对自己有啥用&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#https" id="id9"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;架设https 代理服务器的方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id10"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;给honx的建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ps" id="id11"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;ps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;分析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;抓包, 发现 &lt;tt class="docutils literal"&gt;23.239.5.211&lt;/tt&gt; 这个host:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ host 23.239.5.211
211.5.239.23.in-addr.arpa domain name pointer li699-211.members.linode.com.
&lt;/pre&gt;
&lt;p&gt;访问 &lt;a class="reference external" href="https://23.239.5.211/"&gt;https://23.239.5.211/&lt;/a&gt; 发现是一个https服务.&lt;/p&gt;
&lt;p&gt;也就是说, honx 架设了一个https代理服务器,&lt;/p&gt;
&lt;p&gt;但是, 据我所知, client 和proxy 之间的协议, 只支持 socks, socks5, http, 并不支持https. 目前PAC文件也是只支持这三种协议,&lt;/p&gt;
&lt;p&gt;因为g-f-w会根据内容过滤, 所以代理必须使用一种加密的通道, 而不能是socks, http, 这也就是自己之前一直用ssh隧道的原因.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chromehttps-proxy"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;chrome支持https proxy&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;看了一下 chrome 扩展中 允许的 proxy 类型:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://developer.chrome.com/extensions/proxy"&gt;https://developer.chrome.com/extensions/proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现有https协议:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Scheme      Port
http        80
https       443
socks4      1080
socks5      1080
&lt;/pre&gt;
&lt;p&gt;原来, chrome 是支持 https 代理的:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.chromium.org/developers/design-documents/secure-web-proxy"&gt;http://www.chromium.org/developers/design-documents/secure-web-proxy&lt;/a&gt;
&lt;a class="reference external" href="http://www.chromium.org/spdy/spdy-proxy"&gt;http://www.chromium.org/spdy/spdy-proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以直接在porxy.pac里面返回HTTPS xxx就行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function FindProxyForURL(url, host) { return &amp;quot;HTTPS secure-proxy.example.com:443&amp;quot;; }
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;其实这里也可以是SPDY&lt;/li&gt;
&lt;li&gt;HTTPS proxy 的支持是chrome特有的, 目前还没发现其它浏览器或者ssh客户端之类支持(因为代码相对复杂)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试破解&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;既然如此, 我们写这样一个pac文件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function FindProxyForURL(url, host) {
    return 'HTTPS 23.239.5.211:443;';
}
&lt;/pre&gt;
&lt;p&gt;似乎就ok, 但是测试发现不行, 原因是 https 有域名校验, 这里chrome可能使用强制校验, 必须通过匹配的域名访问 23.239.5.211 才行.&lt;/p&gt;
&lt;p&gt;再查了一些chrome的资料, 其实通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;chrome://xxx-internals/&lt;/span&gt;&lt;/tt&gt;  很容易发现, honx其实也是写了这样的一个pac文件. 可以清楚的看到:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PAC script: data:application/x-ns-proxy-autoconfig...
&lt;/pre&gt;
&lt;p&gt;它的内容是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function FindProxyForURL(url, host) {

var D = &amp;quot;DIRECT&amp;quot;;
var p='HTTPS xxxxx.com:443;';

var node = {&amp;quot;net&amp;quot;:{&amp;quot;akamaihd&amp;quot;:1,&amp;quot;facebook&amp;quot;:1,&amp;quot;fbcdn&amp;quot;:1,&amp;quot;cloudfront&amp;quot;:1,&amp;quot;sstatic&amp;quot;:1,&amp;quot;doubleclick&amp;quot;:1,&amp;quot;2mdn&amp;quot;:1},&amp;quot;com&amp;quot;:{&amp;quot;facebook&amp;quot;:1,&amp;quot;twitter&amp;quot;:1,&amp;quot;twimg&amp;quot;:1,&amp;quot;google&amp;quot;:1,&amp;quot;googleusercontent&amp;quot;:1,&amp;quot;googleapis&amp;quot;:1,&amp;quot;gstatic&amp;quot;:1,&amp;quot;gmail&amp;quot;:1,&amp;quot;tumblr&amp;quot;:1,&amp;quot;appspot&amp;quot;:1,&amp;quot;amazonaws&amp;quot;:{&amp;quot;s3&amp;quot;:1},&amp;quot;blogspot&amp;quot;:1,&amp;quot;blogger&amp;quot;:1,&amp;quot;mediafire&amp;quot;:1,&amp;quot;ytimg&amp;quot;:1,&amp;quot;youtube&amp;quot;:1,&amp;quot;googlevideo&amp;quot;:1,&amp;quot;youtube-nocookie&amp;quot;:1,&amp;quot;wordpress&amp;quot;:1,&amp;quot;vimeo&amp;quot;:1,&amp;quot;googlesyndication&amp;quot;:1,&amp;quot;ggpht&amp;quot;:1,&amp;quot;imgur&amp;quot;:1,&amp;quot;googleadservices&amp;quot;:1,&amp;quot;cloudflare&amp;quot;:1,&amp;quot;chrome&amp;quot;:1,&amp;quot;symantec&amp;quot;:1},&amp;quot;co&amp;quot;:{&amp;quot;t&amp;quot;:1},&amp;quot;hk&amp;quot;:{&amp;quot;com&amp;quot;:{&amp;quot;google&amp;quot;:1}},&amp;quot;ly&amp;quot;:{&amp;quot;bit&amp;quot;:1},&amp;quot;be&amp;quot;:{&amp;quot;youtu&amp;quot;:1},&amp;quot;wpad&amp;quot;:1,&amp;quot;org&amp;quot;:{&amp;quot;chromium&amp;quot;:1}};

var hostParts = host.toLowerCase().split('.');
for (var i=hostParts.length - 1; i &amp;gt;= 0; i --) {
    var part = hostParts[i];
    node = node[part];
    if (node == undefined || node == 1) break;
}
if (node == 1)
    return p;

return D;
}
&lt;/pre&gt;
&lt;p&gt;我们发现这个脚本里面清楚的写着xxxx.com 这个域名, 把自己的pac换成这个域名:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function FindProxyForURL(url, host) {
    return 'HTTPS xxxxx.com:443;';
}
&lt;/pre&gt;
&lt;p&gt;ok, 发现我们已经顺利使用这个https 代理了.&lt;/p&gt;
&lt;p&gt;这里为了防止大家瞎搞, 域名我已经隐去了.&lt;/p&gt;
&lt;p&gt;这段js里面居然用了一个 &lt;strong&gt;trie-tree&lt;/strong&gt; , 好赞, 不像我写的土鳖js:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
var hosts = [
    &amp;quot;google.com&amp;quot;,
    &amp;quot;google.co.jp&amp;quot;,
    &amp;quot;blogspot.com&amp;quot;,
];

function FindProxyForURL(url, host) {
    for (var i in hosts){
        pattern = '.*' + hosts[i] + '.*';
        if (regExpMatch(host, pattern)){
            return proxy;
        }
    }
    return &amp;quot;DIRECT&amp;quot;;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;这个方法对自己有啥用&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;既然知道了chrome 可以用https 的proxy, 那我就可以在自己的linode上搭了.&lt;/li&gt;
&lt;li&gt;搭了这样一个https代理, 会不会被大家乱用呢.. 还得想办法.&lt;/li&gt;
&lt;li&gt;如果能让ssh客户端等支持https 代理就好了.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="https"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;架设https 代理服务器的方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Running a Secure Web Proxy&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;While all the details of running a secure web proxy are out of scope for this document, here are two suggestions.  If you are already running a web proxy, you use stunnel to convert it into a secure web proxy.  For example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
stunnel -f -d 443 -r localhost:8080 -p cert.pem
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This would cause stunnel to listen for SSL connections on port 443 and send any HTTP requests to the web proxy running on port 8080.&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Squid&lt;/tt&gt; appears to offer support for running as a secure web proxy via the https_port directive.&lt;/li&gt;
&lt;li&gt;nginx+SPDY?&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/igrigorik/node-spdyproxy"&gt;https://github.com/igrigorik/node-spdyproxy&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;给honx的建议&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;增加某种验证机制,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;使用http/https的 proxy验证机制&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;都比较弱, 而且需要用户介入手动填一次密码, 会频繁打断用户.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;比如在代理服务器上同时开一个注册服务, 当honx启动后, 每x秒会向这个接口注册一次, 说这个clientip是合法的, 这个接口可以加入复杂的验证, 这样就比较优雅.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不过引入这种机制会导致一些ip会变(公司多出口之类)的用户可能不能正常使用. 比较烦恼&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;再者, 一个honx用户估计是可以在多处登录, 这样就可以多人共享proxy, 所以, 加认证等等, 终归是防君子不防小人.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;建议针对学生降价.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ps"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;ps&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;honx 在产品设计上非常傻瓜, 0配置, 一键加入代理也很方便.&lt;/li&gt;
&lt;li&gt;好服务, 要呵护, 希望大家没功夫折腾的同学, 多多支持honx(我也买了)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>redis-latancy问题</title><link href="/redis-latancy.html" rel="alternate"></link><updated>2014-07-09T10:04:00+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-09:redis-latancy.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-latency-problems-troubleshooting" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Redis latency problems troubleshooting&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1.网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#slow-commands" id="id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;2.slow commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fork" id="id7"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;3.fork&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#swapping" id="id8"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;4.swapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aof-and-disk-i-o" id="id9"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;5.aof and disk I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#expires" id="id10"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;6.expires&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;1.7&amp;nbsp;&amp;nbsp;&amp;nbsp;工具&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#watchdog" id="id12"&gt;1.7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;watchdog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#latancy" id="id13"&gt;1.7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;最新的latancy监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id14"&gt;1.8&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-latency-problems-troubleshooting"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Redis latency problems troubleshooting&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主要来自redis 作者的文章: &lt;a class="reference external" href="http://redis.io/topics/latency"&gt;http://redis.io/topics/latency&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章介绍了很多工具, iostat, vmstat&lt;/p&gt;
&lt;p&gt;测量:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
redis-cli --latency -h `host` -p `port`
&lt;/pre&gt;
&lt;p&gt;基准(不可能好于这个数):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./redis-cli --intrinsic-latency 100
Max latency so far: 573 microseconds.
Max latency so far: 695 microseconds.
Max latency so far: 919 microseconds.
Max latency so far: 1606 microseconds.
Max latency so far: 3191 microseconds.
Max latency so far: 9243 microseconds.
Max latency so far: 9671 microseconds.
Here we have an intrinsic latency of 9.7 milliseconds: this means that we can't ask better than that to Redis.
&lt;/pre&gt;
&lt;p&gt;可能的原因:&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1.网络&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The typical latency of a 1 GBits/s network is about 200 us, while the latency with a Unix domain socket can be as low as 30 us.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;不要用虚拟机.&lt;/li&gt;
&lt;li&gt;长连接&lt;/li&gt;
&lt;li&gt;use Unix domain sockets&lt;/li&gt;
&lt;li&gt;MSET/MGET/pipeline&lt;/li&gt;
&lt;/ul&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;On Linux, some people can achieve better latencies by playing with :&lt;/dt&gt;
&lt;dd&gt;process placement (taskset), cgroups, real-time priorities (chrt), NUMA configuration (numactl), or by using a low-latency kernel.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Please note vanilla Redis is not really suitable to be bound on a single CPU core. Redis can fork background tasks that can be extremely CPU consuming like bgsave or AOF rewrite. These tasks must never run on the same core as the main event loop.&lt;/p&gt;
&lt;p&gt;from Redis 2.4 we use threads in Redis in order to perform some slow I/O operations in the background, mainly related to disk I/O,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slow-commands"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;2.slow commands&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;建议:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;避免keys, sort, lrem, sunion&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="fork"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;3.fork&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;内存page为4K,  24 GB Redis instance requires a page table of 24 GB / 4 KB * 8 = 48 MB&lt;/li&gt;
&lt;li&gt;Xen 上更加糟糕.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建议:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用较小的实例.(&amp;lt;10G)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="swapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;4.swapping&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;查看swap:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ cat /proc/18941/smaps  | grep Swap
Swap:                  0 kB
Swap:                  0 kB
Swap:                  0 kB
Swap:                  0 kB
Swap:                  0 kB
Swap:                156 kB
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="aof-and-disk-i-o"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;5.aof and disk I/O&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;write() + fdatasync()&lt;/p&gt;
&lt;p&gt;Both the write(2) and fdatasync(2) calls can be source of latency. For instance write(2) can block both when there is a system wide sync in progress, or when the output buffers are full and the kernel requires to flush on disk in order to accept new writes.&lt;/p&gt;
&lt;p&gt;close 也会导致flush.&lt;/p&gt;
&lt;p&gt;fdatasync 可能从几个ms到几s. 所以redis2.4 尽可能在另一个线程里面做fdatasync.&lt;/p&gt;
&lt;p&gt;When appendfsync is set to the value of no Redis performs no fsync. In this configuration the only source of latency can be write(2).&lt;/p&gt;
&lt;p&gt;测量:&lt;/p&gt;
&lt;blockquote&gt;
sudo strace -p $(pidof redis-server) -T -e trace=fdatasync -f&lt;/blockquote&gt;
&lt;p&gt;因为fdatasync 是在另一个线程, 所以需要加-f&lt;/p&gt;
&lt;p&gt;However since write(2) is also used in order to write data to the client sockets this will likely show too many things unrelated to disk I/O. Apparently there is no way to tell strace to just show slow system calls so I use the following command:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
strace -f -p $(pidof redis-server) -T -e trace=fdatasync,write 2&amp;gt;&amp;amp;1 | grep -v '0.0' | grep -v unfinished
&lt;/pre&gt;
&lt;p&gt;建议:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;appendfsync no&lt;/li&gt;
&lt;li&gt;Using an SSD disk can help as well,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用这个, 我们在做copy 的时候, 可以观察到:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[pid 24734] write(42, &amp;quot;*4\r\n$5\r\nhmset\r\n$37\r\np-lc-d687791&amp;quot;..., 272475) = 272475 &amp;lt;0.036430&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;2.030435&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;0.012418&amp;gt;
[pid 24734] write(42, &amp;quot;*4\r\n$5\r\nHMSET\r\n$37\r\np-lc-6787211&amp;quot;..., 73) = 73 &amp;lt;0.125906&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;4.476948&amp;gt;
[pid 24734] &amp;lt;... write resumed&amp;gt; )       = 294594 &amp;lt;2.477184&amp;gt;   (2.47s)
&lt;/pre&gt;
&lt;p&gt;此时输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./_binaries/redis-cli --latency-history -h 10.38.114.60 -p 2000
min: 0, max: 223, avg: 1.24 (1329 samples) -- 15.01 seconds range
min: 0, max: 2500, avg: 3.46 (1110 samples) -- 15.00 seconds range   (这里观察到2.5s)
min: 0, max: 5, avg: 1.01 (1355 samples) -- 15.01 seconds range
&lt;/pre&gt;
&lt;p&gt;watchdog 输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[24734] 07 Jul 10:54:41.006 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
[24734 | signal handler] (1404701682)
--- WATCHDOG TIMER EXPIRED ---
bin/redis-server *:2000(logStackTrace+0x4b)[0x443bdb]
/lib64/tls/libpthread.so.0(__write+0x4f)[0x302b80b03f]
/lib64/tls/libpthread.so.0[0x302b80c420]
/lib64/tls/libpthread.so.0(__write+0x4f)[0x302b80b03f]
bin/redis-server *:2000(flushAppendOnlyFile+0x76)[0x43f616]
bin/redis-server *:2000(serverCron+0x325)[0x41b5b5]
bin/redis-server *:2000(aeProcessEvents+0x2b2)[0x416a22]
bin/redis-server *:2000(aeMain+0x3f)[0x416bbf]
bin/redis-server *:2000(main+0x1c8)[0x41dcd8]
/lib64/tls/libc.so.6(__libc_start_main+0xdb)[0x302af1c4bb]
bin/redis-server *:2000[0x415b1a]
[24734 | signal handler] (1404701682) --------
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="expires"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;6.expires&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;if the database contains has many many keys expiring in the same second, and this keys are at least 25% of the current population of keys with an expire set,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;1.7&amp;nbsp;&amp;nbsp;&amp;nbsp;工具&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="watchdog"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id12"&gt;1.7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;watchdog&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;redis2.6 自带. 通过时钟中断定时触发检查:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
CONFIG SET watchdog-period 500
&lt;/pre&gt;
&lt;p&gt;会在发现有大延迟时, 打印日志.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="latancy"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;1.7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;最新的latancy监控&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
latency-monitor-threshold 100
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;1.8&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;2, 3, 5 我们都遇到了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>redis-aof-latency</title><link href="/redis-aof-latency.html" rel="alternate"></link><updated>2014-07-09T08:36:06+08:00</updated><author><name>ning</name></author><id>tag:,2014-07-09:redis-aof-latency.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;一些分析&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么慢查询看不到?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id13"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;观察&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#appendfsync-no" id="id14"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么 appendfsync no 无效&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id15"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;一些想法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#page-cache" id="id16"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;关于page cache&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id17"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;查看当前page cache 状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id18"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#stable-page-write" id="id19"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Stable Page Write&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id20"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;查看线上&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dirty-ratio" id="id21"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;调整dirty_ratio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dirty-expire-centisecs" id="id22"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;调整 dirty_expire_centisecs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id23"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id24"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;相关&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;我的redis配置的aof如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
appendonly yes
appendfsync everysec
&lt;/pre&gt;
&lt;p&gt;redis-mgr配置每天早上 6:00-8:00 做aof_rewrite 和 rdb, 所以每天早上这段时间, 我们就会收到twempxoy的forward_err报警, 大约每分钟会损失5000个请求.&lt;/p&gt;
&lt;p&gt;失败率是 10/10000.&lt;/p&gt;
&lt;p&gt;在线上测试, 做一个10G的文件写操作, 就会触发上面问题:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
dd if=/dev/zero of=xxxxx bs=1M count=10000 &amp;amp;
&lt;/pre&gt;
&lt;p&gt;我们修改了 &lt;tt class="docutils literal"&gt;appendfsync no&lt;/tt&gt;, 发现这个问题能缓解, 但是不能解决.&lt;/p&gt;
&lt;p&gt;关于redis的各种延迟, 作者antirez的 &lt;a class="reference external" href="/redis-latancy.html"&gt;这篇文章&lt;/a&gt; 已经说的很清楚了.&lt;/p&gt;
&lt;p&gt;我们这里遇到的就是有disk I/O 的时候aof受到影响.&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;一些分析&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么慢查询看不到?&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;慢查询统计的时间只包括cpu计算的时间, 写aof这个过程不计入查询时间统计(也不应该计入)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;观察&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用下面命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
strace -f -p $(pidof redis-server) -T -e trace=fdatasync,write 2&amp;gt;&amp;amp;1 | grep -v '0.0' | grep -v unfinished
&lt;/pre&gt;
&lt;p&gt;我们在做copy 的时候, 可以观察到:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[pid 24734] write(42, &amp;quot;*4\r\n$5\r\nhmset\r\n$37\r\np-lc-d687791&amp;quot;..., 272475) = 272475 &amp;lt;0.036430&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;2.030435&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;0.012418&amp;gt;
[pid 24734] write(42, &amp;quot;*4\r\n$5\r\nHMSET\r\n$37\r\np-lc-6787211&amp;quot;..., 73) = 73 &amp;lt;0.125906&amp;gt;
[pid 24738] &amp;lt;... fdatasync resumed&amp;gt; )   = 0 &amp;lt;4.476948&amp;gt;
[pid 24734] &amp;lt;... write resumed&amp;gt; )       = 294594 &amp;lt;2.477184&amp;gt;   (2.47s)
&lt;/pre&gt;
&lt;p&gt;此时输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./_binaries/redis-cli --latency-history -h 10.38.114.60 -p 2000
min: 0, max: 223, avg: 1.24 (1329 samples) -- 15.01 seconds range
min: 0, max: 2500, avg: 3.46 (1110 samples) -- 15.00 seconds range   (这里观察到2.5s)
min: 0, max: 5, avg: 1.01 (1355 samples) -- 15.01 seconds range
&lt;/pre&gt;
&lt;p&gt;watchdog 输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[24734] 07 Jul 10:54:41.006 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
[24734 | signal handler] (1404701682)
--- WATCHDOG TIMER EXPIRED ---
bin/redis-server *:2000(logStackTrace+0x4b)[0x443bdb]
/lib64/tls/libpthread.so.0(__write+0x4f)[0x302b80b03f]
/lib64/tls/libpthread.so.0[0x302b80c420]
/lib64/tls/libpthread.so.0(__write+0x4f)[0x302b80b03f]
bin/redis-server *:2000(flushAppendOnlyFile+0x76)[0x43f616]
bin/redis-server *:2000(serverCron+0x325)[0x41b5b5]
bin/redis-server *:2000(aeProcessEvents+0x2b2)[0x416a22]
bin/redis-server *:2000(aeMain+0x3f)[0x416bbf]
bin/redis-server *:2000(main+0x1c8)[0x41dcd8]
/lib64/tls/libc.so.6(__libc_start_main+0xdb)[0x302af1c4bb]
bin/redis-server *:2000[0x415b1a]
[24734 | signal handler] (1404701682) --------
&lt;/pre&gt;
&lt;p&gt;所以确定是write hang住&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="appendfsync-no"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么 appendfsync no 无效&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当磁盘写buf满的时候, write就会阻塞, 释放一些buf才会允许继续写入,&lt;/p&gt;
&lt;p&gt;所以, 如果程序不调用sync, 系统就会在不确定的时候 做sync, 此时 &lt;tt class="docutils literal"&gt;wirte()&lt;/tt&gt; 就会hang住&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;一些想法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;能否对rdb/aof_rewrite/cp等命令限速,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不可能针对每个进程(比如有其它写日志的进程) 都做限制. 所以最好不要这样.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;增加proxy timeout, 目前400ms, 增加到2000ms?&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如果超时400ms, 想当于快速失败. 客户端重试效果一样, 所以还是不必改.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;master 关aof&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这个方法不需要做任何改动, 代价较小, 效果最好, 缺点是提高运维复杂性和数据可靠性, redis-mgr可以做这个支持.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;write 时的阻塞貌似无法避免, 能否用一个新的线程来做write呢?&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;关于这个想法写了个patch提给作者: &lt;a class="reference external" href="https://github.com/antirez/redis/pull/1862"&gt;https://github.com/antirez/redis/pull/1862&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不过作者貌似不太感冒.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="page-cache"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;关于page cache&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;IO调度一般是针对读优化的, 因为读的时候是同步的, 进程读取不到, 就会睡眠.
写是异步的, 只是写到page cache.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;查看当前page cache 状态&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
grep ^Cached: /proc/meminfo # page cache size
grep ^Dirty: /proc/meminfo # total size of all dirty pages
grep ^Writeback: /proc/meminfo # total size of actively processed dirty pages
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;参数&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ sysctl -a | grep dirty
vm.dirty_background_ratio = 10
vm.dirty_background_bytes = 0
vm.dirty_ratio = 20
vm.dirty_bytes = 0
vm.dirty_writeback_centisecs = 1500
vm.dirty_expire_centisecs = 3000
&lt;/pre&gt;
&lt;p&gt;详细参考: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"&gt;https://www.kernel.org/doc/Documentation/sysctl/vm.txt&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/proc/sys/vm/dirty_expire_centisecs         #3000, 表示3000*0.01s = 30s, 队列中超过30s的被刷盘.
/proc/sys/vm/dirty_writeback_centisecs      #1500, 表示1500*0.01s = 15s, 内核pdflush wakeup 一次.

/proc/sys/vm/dirty_background_ratio
/proc/sys/vm/dirty_ratio
Both values are expressed as a percentage of RAM. When the amount of dirty pages reaches the first threshold (dirty_background_ratio), write-outs begin in the background via the “flush” kernel threads. When the second threshold is reached, processes will block, flushing in the foreground.


The problem with these variables is their minimum value: even 1% can be too much. This is why another two controls were introduced in 2.6.29:
/proc/sys/vm/dirty_background_bytes
/proc/sys/vm/dirty_bytes
&lt;/pre&gt;
&lt;p&gt;x_bytes 和 x_ratio是互斥的, 设置dirty_bytes 的时候, dirty_ratio 会被清0:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
root&amp;#64;ning-laptop:~# cat /proc/sys/vm/dirty_bytes
0
root&amp;#64;ning-laptop:~# cat /proc/sys/vm/dirty_ratio
20
root&amp;#64;ning-laptop:~# echo '5000000' &amp;gt; /proc/sys/vm/dirty_bytes
root&amp;#64;ning-laptop:~# cat /proc/sys/vm/dirty_bytes
5000000
root&amp;#64;ning-laptop:~# cat /proc/sys/vm/dirty_ratio
0
&lt;/pre&gt;
&lt;p&gt;Lower values generate more I/O requests (and more interrupts), significantly decrease sequential I/O bandwidth but also decrease random I/O latency
数值小的时候, 会减小IO系统带宽, 同时减少 随机的IO延迟.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://monolight.cc/2011/06/barriers-caches-filesystems/"&gt;http://monolight.cc/2011/06/barriers-caches-filesystems/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="stable-page-write"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Stable Page Write&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://yoshinorimatsunobu.blogspot.com/2014/03/why-buffered-writes-are-sometimes.html"&gt;http://yoshinorimatsunobu.blogspot.com/2014/03/why-buffered-writes-are-sometimes.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When a dirty page is written to disk, write() to the same dirty page is blocked until flushing to disk is done. This is called &lt;strong&gt;Stable Page Write&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This may cause write() stalls, especially when using slower disks. Without write cache, flushing to disk takes ~10ms usually, ~100ms in bad cases.&lt;/p&gt;
&lt;p&gt;有patch在较新的内核上能缓解这个问题, 原理是减少write调用 wait_on_page_writeback 的几率:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1d1d1a767206fbe5d4c69493b7e6d2a8d08cc0a0
Here's the result of using dbench to test latency on ext2:

3.8.0-rc3:
 Operation      Count    AvgLat    MaxLat
 ----------------------------------------
 WriteX        109347     0.028    59.817
 ReadX         347180     0.004     3.391
 Flush          15514    29.828   287.283

Throughput 57.429 MB/sec  4 clients  4 procs  max_latency=287.290 ms

3.8.0-rc3 + patches:
 WriteX        105556     0.029     4.273
 ReadX         335004     0.005     4.112
 Flush          14982    30.540   298.634

Throughput 55.4496 MB/sec  4 clients  4 procs  max_latency=298.650 ms

As you can see, the maximum write latency drops considerably with this
patch enabled.
&lt;/pre&gt;
&lt;p&gt;据说xfs 也能解决问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;查看线上&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/sys/vm/dirty_background_ratio
10
$ cat /proc/sys/vm/dirty_ratio
20
&lt;/pre&gt;
&lt;p&gt;平时dirty:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ grep ^Dirty: /proc/meminfo
Dirty:            104616 kB
机器内存128G.
&lt;/pre&gt;
&lt;p&gt;早上做rdb/aof_rewrite时, dirty:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
500,000 kB (500M)
&lt;/pre&gt;
&lt;p&gt;都还没到达配置的 &lt;tt class="docutils literal"&gt;dirty_background_ratio&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;dirty_ratio&lt;/tt&gt; 所以调这两个参数估计没用.&lt;/p&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#1. 最常90s.
vm.dirty_expire_centisecs = 9000
echo '9000' &amp;gt; /proc/sys/vm/dirty_expire_centisecs

#2. 改大dirty_ratio
echo '80' &amp;gt; /proc/sys/vm/dirty_ratio
&lt;/pre&gt;
&lt;div class="section" id="dirty-ratio"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id21"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;调整dirty_ratio&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在一个io较差的48G机器上,  设置 dirty_ratio = 80, dirty 会涨的很高, 但是redis延迟看不明显的改善:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ grep ^Dirty: /proc/meminfo
Dirty:           8598180 kB  =&amp;gt;echo '80' &amp;gt; /proc/sys/vm/dirty_ratio
$ grep ^Dirty: /proc/meminfo
Dirty:          11887180 kB
$ grep ^Dirty: /proc/meminfo
Dirty:          21295624 kB
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="dirty-expire-centisecs"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id22"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;调整 dirty_expire_centisecs&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;看上去也没有效果, 有变差趋势.
因为我在线下是通过长期dd来压测, 和线上还不太一样.&lt;/p&gt;
&lt;p&gt;看来只能线上测试了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;master关aof应该是目前最可以接受的方法&lt;/li&gt;
&lt;li&gt;antirez在做一个latency采样的工作&lt;/li&gt;
&lt;li&gt;XFS/Solaris 貌似没有这个问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;相关&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="http://redis.io/topics/latency"&gt;http://redis.io/topics/latency&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;11 年就有的讨论 &lt;a class="reference external" href="https://groups.google.com/forum/#!msg/redis-db/jgGuGngDEb0/ZwnvUdx-gdAJ"&gt;https://groups.google.com/forum/#!msg/redis-db/jgGuGngDEb0/ZwnvUdx-gdAJ&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;作者本来想把write和fsync都移到另一个线程, 结论是把fsync移到一个线程了,&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Linkedin 的一个工程师做了这样一个实验, 测试用1/4的带宽来写的时候, 产生的延迟情况:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.empathybox.com/post/35088300798/why-does-fwrite-sometimes-block"&gt;http://blog.empathybox.com/post/35088300798/why-does-fwrite-sometimes-block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>redis-config-hz</title><link href="/redis-config-hz.html" rel="alternate"></link><updated>2014-06-24T10:19:32+08:00</updated><author><name>ning</name></author><id>tag:,2014-06-24:redis-config-hz.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id3"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cen-li" id="id4"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;cen-li的分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hz-antirez" id="id5"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;关于hz, antirez 的一个解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id6"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;现象&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;redis 内存居高不下&lt;/p&gt;
&lt;p&gt;我们上线了一个新的业务后, 单实例内存从4G彪到6G左右, 凌晨低峰期大约5G. 调整cache时间, 由4h改为2h, 未见内存下降.&lt;/p&gt;
&lt;p&gt;怀疑是key已经过期, 但是并未淘汰. 通过把线上aof重放到线下看, 线上有19M个key, 线下只有12M个key, 说明存在很多脏key(过期但是未淘汰)&lt;/p&gt;
&lt;p&gt;修改配置 &lt;tt class="docutils literal"&gt;HZ=100&lt;/tt&gt; , 加速淘汰, 内存开始下降, 从5.5G下降到3.5G.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cen-li"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;cen-li的分析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;至于hz应该设什么值, 可以参考 cen-li的分析: &lt;a class="reference external" href="http://cen-li.github.io/redis-expire.html"&gt;http://cen-li.github.io/redis-expire.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结下来:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;key的淘汰有三个时机:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;主动(cron定时执行)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;每秒执行HZ次(理想情况), 每次执行一个固定时间片: &lt;tt class="docutils literal"&gt;1s/HZ/4&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;被动&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;写操作时, 发现内存超过maxmemory, 此时淘汰n个key, 直到内存降到配置maxmemory以下.&lt;/li&gt;
&lt;li&gt;读操作时, 发现当前读取的key已经过期, 则淘汰掉.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;内存不满的集群, 主要受到cron淘汰机制的制约, 此时有一个算法来淘汰, 此时我们可以得出 &lt;tt class="docutils literal"&gt;脏key率&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;key 淘汰速度&lt;/tt&gt; 的关系:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
X: 脏key率
Y: 每个主程序循环内执行loop2次数 (Y &amp;gt;= 1)
HZ: 每秒执行多少次cron
qps：qps为key的过期速度，不考虑流量的波动的话，约等于当时的过期操作的请求数
&lt;/pre&gt;
&lt;p&gt;得出如下关系:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
X = qps / (20 * HZ * Y)
&lt;/pre&gt;
&lt;p&gt;因为 &lt;tt class="docutils literal"&gt;Y &amp;gt;= 1&lt;/tt&gt;, 所以上面公式给出了一个 &lt;tt class="docutils literal"&gt;脏key率 X&lt;/tt&gt; 的上限, 比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
HZ=10  =&amp;gt; X&amp;lt;=pqs/200.
HZ=100 =&amp;gt; X&amp;lt;=pqs/2000.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;调大HZ会导致redis空闲时的cpu占用上升, 我们的场景下单实例CPU占用大约增加 &lt;tt class="docutils literal"&gt;1%&lt;/tt&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;其它:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;aof rewrite和rdb不会包括已过期的key&lt;/li&gt;
&lt;li&gt;从库不执行过期操作, 主库过期一个key时，会生成一个DEL操作，该操作会同步到从库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hz-antirez"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;关于hz, antirez 的一个解释&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://groups.google.com/forum/#!topic/redis-db/6kILekxQXBM"&gt;https://groups.google.com/forum/#!topic/redis-db/6kILekxQXBM&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Redis HZ was 10 in 2.4
Redis HZ is 100 in 2.6
2.8 里面增加HZ配置, 默认10.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于快速淘汰的cache集群, 应该设置较大的hz, 100是一个无害值.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy-deadlock-on-signal_handler</title><link href="/twemproxy-deadlock-on-signal_handler.html" rel="alternate"></link><updated>2014-06-14T05:54:42+08:00</updated><author><name>ning</name></author><id>tag:,2014-06-14:twemproxy-deadlock-on-signal_handler.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#localtime" id="id8"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;localtime() 的实现&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tz-convert-is-not-signal-safe" id="id9"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;__tz_convert is not signal-safe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#free-signal-safe" id="id10"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;类似的, free()也不是signal-safe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;模拟复现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;修复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#signal-safe-thread-safe" id="id13"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;signal-safe/thread safe/可重入&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#sprintfasync-signal-safe" id="id14"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;sprintf不是async-signal-safe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#async-signal-safe" id="id15"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;确定一个函数是否 async-signal-safe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id16"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;其它系统中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#as-safe" id="id17"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;这些函数是AS-SAFE的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id18"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nginx" id="id19"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx为什么没有这个问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mysql" id="id20"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id21"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reference" id="id22"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;现象&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们的 &lt;a class="reference external" href="https://github.com/idning/redis-mgr"&gt;redis-mgr&lt;/a&gt; 会默认对集群中的第一个twemproxy使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt; 5&lt;/tt&gt; 打印 &lt;tt class="docutils literal"&gt;notice&lt;/tt&gt; 级别的日志, 切日志使用的是, &lt;tt class="docutils literal"&gt;kill &lt;span class="pre"&gt;-HUP&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;线上发现两次切日志之后twemproxy停止响应, gdb:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Loaded symbols for /lib64/ld-linux-x86-64.so.2
__lll_lock_wait_private () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:97
97      ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: No such file or directory.
        in ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
(gdb) bt
#0  __lll_lock_wait_private () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:97
#1  0x00007f0393918b2d in _L_lock_1934 () at tzset.c:138
#2  0x00007f03939188e7 in __tz_convert (timer=0x7f0393bfd9f4, use_localtime=1, tp=0x7f0393c00360) at tzset.c:619
#3  0x0000000000410fba in _log (file=0x431036 &amp;quot;nc_signal.c&amp;quot;, line=122, panic=0, fmt=0x43101c &amp;quot;signal %d (%s) received%s&amp;quot;) at nc_log.c:140
#4  0x000000000041016c in signal_handler (signo=&amp;lt;value optimized out&amp;gt;) at nc_signal.c:122
#5  &amp;lt;signal handler called&amp;gt;

#6  0x00007f03939552d5 in *__GI___xstat (vers=&amp;lt;value optimized out&amp;gt;, name=&amp;lt;value optimized out&amp;gt;, buf=0x7fff2a266fc0) at ../sysdeps/unix/sysv/linux/wordsize-64/xstat.c:38
#7  0x00007f03939193f0 in __tzfile_read (file=0x7f03939c5b7c &amp;quot;/etc/localtime&amp;quot;, extra=0, extrap=&amp;lt;value optimized out&amp;gt;) at tzfile.c:173
#8  0x00007f03939187a4 in tzset_internal (always=&amp;lt;value optimized out&amp;gt;, explicit=&amp;lt;value optimized out&amp;gt;) at tzset.c:439
#9  0x00007f0393918909 in __tz_convert (timer=0x7fff2a267158, use_localtime=1, tp=0x7f0393c00360) at tzset.c:624
#10 0x0000000000410fba in _log (file=0x42ed0c &amp;quot;nc_server.c&amp;quot;, line=645, panic=0, fmt=0x42ece0 &amp;quot;key '%.*s' on dist %d maps to server '%.*s'&amp;quot;) at nc_log.c:140

#11 0x000000000040887e in server_pool_server (ctx=0x1c0e090, pool=0x1c0e360, key=0x1c150c2 &amp;quot;key:__rand_int__\r\n&amp;quot;, keylen=16) at nc_server.c:644
#12 server_pool_conn (ctx=0x1c0e090, pool=0x1c0e360, key=0x1c150c2 &amp;quot;key:__rand_int__\r\n&amp;quot;, keylen=16) at nc_server.c:668
#13 0x000000000040ae04 in req_forward (ctx=0x1c0e090, conn=0x1c14e70, msg=0x1c14f70, nmsg=&amp;lt;value optimized out&amp;gt;) at nc_request.c:482
#14 req_recv_done (ctx=0x1c0e090, conn=0x1c14e70, msg=0x1c14f70, nmsg=&amp;lt;value optimized out&amp;gt;) at nc_request.c:524
#15 0x0000000000409f00 in msg_parsed (ctx=0x1c0e090, conn=0x1c14e70) at nc_message.c:451
#16 msg_parse (ctx=0x1c0e090, conn=0x1c14e70) at nc_message.c:581
#17 msg_recv_chain (ctx=0x1c0e090, conn=0x1c14e70) at nc_message.c:642
#18 msg_recv (ctx=0x1c0e090, conn=0x1c14e70) at nc_message.c:681
#19 0x0000000000406179 in core_recv (arg=0x1c14e70, events=&amp;lt;value optimized out&amp;gt;) at nc_core.c:158
#20 core_core (arg=0x1c14e70, events=&amp;lt;value optimized out&amp;gt;) at nc_core.c:293
#21 0x000000000041bbb8 in event_wait (evb=0x1c0e570, timeout=&amp;lt;value optimized out&amp;gt;) at nc_epoll.c:269
#22 0x0000000000405f89 in core_loop (ctx=0x1c0e090) at nc_core.c:316
#23 0x0000000000412a38 in nc_run (argc=&amp;lt;value optimized out&amp;gt;, argv=0x7fff2a267690) at nc.c:531
#24 main (argc=&amp;lt;value optimized out&amp;gt;, argv=0x7fff2a267690) at nc.c:580
(gdb)
&lt;/pre&gt;
&lt;p&gt;both of the &lt;tt class="docutils literal"&gt;normal Program flow&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;signal_handler&lt;/tt&gt; call &lt;tt class="docutils literal"&gt;__tz_convert()&lt;/tt&gt;, it looks that __tz_convert use a lock and this make the signal_handler never return, let's have a look &lt;tt class="docutils literal"&gt;__tz_convert&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;nc_signal.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void
signal_handler(int signo)
{
    struct signal *sig;
    void (*action)(void);
    char *actionstr;
    bool done;

    switch (signo) {
    case SIGHUP:
        actionstr = &amp;quot;, reopening log file&amp;quot;;
        action = log_reopen;
        break;
    }

    loga(&amp;quot;signal %d (%s) received%s&amp;quot;, signo, sig-&amp;gt;signame, actionstr);

    if (action != NULL) {
        action();
    }

    if (done) {
        exit(1);
    }
}
&lt;/pre&gt;
&lt;p&gt;loga 打印日志的时候, 会调用localtime():&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void
_log(const char *file, int line, int panic, const char *fmt, ...)
{
    ...
    t = time(NULL);
    local = localtime(&amp;amp;t);
    timestr = asctime(local);

    len += nc_scnprintf(buf + len, size - len, &amp;quot;[%.*s] %s:%d &amp;quot;,
                        strlen(timestr) - 1, timestr, file, line);

    va_start(args, fmt);
    len += nc_vscnprintf(buf + len, size - len, fmt, args);
    va_end(args);

    buf[len++] = '\n';

    n = nc_write(l-&amp;gt;fd, buf, len);
}
&lt;/pre&gt;
&lt;p&gt;首先 &lt;tt class="docutils literal"&gt;localtime()&lt;/tt&gt; 不是线程安全的, 同时它也不是signal-safe的, 所以在signal_handler里面使用localtime()就可能造成死锁.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="localtime"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;localtime() 的实现&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;glibc/time/localtime.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
22  struct tm _tmbuf;
23
24
25  /* Return the `struct tm' representation of *T in local time,
26     using *TP to store the result.  */
27  struct tm *
28  __localtime_r (t, tp)
29       const time_t *t;
30       struct tm *tp;
31  {
32    return __tz_convert (t, 1, tp);
33  }
34  weak_alias (__localtime_r, localtime_r)
35
36
37  /* Return the `struct tm' representation of *T in local time.  */
38  struct tm *
39  localtime (t)
40       const time_t *t;
41  {
42    return __tz_convert (t, 1, &amp;amp;_tmbuf);
43  }
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;localtime()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;localtime_r()&lt;/tt&gt; 都是简单的调用 &lt;tt class="docutils literal"&gt;__tz_convert()&lt;/tt&gt;, 区别只是在于 &lt;tt class="docutils literal"&gt;localtime()&lt;/tt&gt; 使用了一个全局变量 &lt;tt class="docutils literal"&gt;_tmbuf&lt;/tt&gt; , 所以不是线程安全的.&lt;/p&gt;
&lt;p&gt;但是 &lt;tt class="docutils literal"&gt;__tz_convert()&lt;/tt&gt; 不是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;signal-safe&lt;/span&gt;&lt;/tt&gt; 的.&lt;/p&gt;
&lt;div class="section" id="tz-convert-is-not-signal-safe"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;__tz_convert is not signal-safe&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;glibc/time/tzset.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
39  /* This locks all the state variables in tzfile.c and this file.  */
40  __libc_lock_define_initialized (static, tzset_lock)

...

613 /* Return the `struct tm' representation of *TIMER in the local timezone.
614    Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */
615 struct tm *
616 __tz_convert (const time_t *timer, int use_localtime, struct tm *tp)
617 {
618   long int leap_correction;
619   int leap_extra_secs;
620
621   if (timer == NULL)
622     {
623       __set_errno (EINVAL);
624       return NULL;
625     }
626
627   __libc_lock_lock (tzset_lock);
628
629   /* Update internal database according to current TZ setting.
630      POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.
631      This is a good idea since this allows at least a bit more parallelism.  */
632   tzset_internal (tp == &amp;amp;_tmbuf &amp;amp;&amp;amp; use_localtime, 1);
&lt;/pre&gt;
&lt;p&gt;这里用了一个锁 &lt;tt class="docutils literal"&gt;tzset_lock&lt;/tt&gt;, 它是用来保护对 &lt;tt class="docutils literal"&gt;tzset_internal()&lt;/tt&gt; 的调用的, &lt;tt class="docutils literal"&gt;tzset_internal&lt;/tt&gt; 是一个类似单态的模式, 第一次调用这个函数的时候初始化一些变量:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
399 static void
400 internal_function
401 tzset_internal (always, explicit)
402      int always;
403      int explicit;
404 {
405   static int is_initialized;
406   const char *tz;
407
408   if (is_initialized &amp;amp;&amp;amp; !always)
409     return;
410   is_initialized = 1;
      ...
465   __tzset_parse_tz (tz);
466 }
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;tzset_internal&lt;/tt&gt; 是用于初始化这个程序的时区设置, 并设置到 &lt;tt class="docutils literal"&gt;tz_rules&lt;/tt&gt; 这个全局变量:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
48  /* This structure contains all the information about a
49     timezone given in the POSIX standard TZ envariable.  */
50  typedef struct
51    {
52      const char *name;
53
54      /* When to change.  */
55      enum { J0, J1, M } type;    /* Interpretation of:  */
56      unsigned short int m, n, d; /* Month, week, day.  */
57      int secs;                   /* Time of day.  */
58
59      long int offset;            /* Seconds east of GMT (west if &amp;lt; 0).  */
60
61      /* We cache the computed time of change for a
62         given year so we don't have to recompute it.  */
63      time_t change;      /* When to change to this zone.  */
64      int computed_for;   /* Year above is computed for.  */
65    } tz_rule;
66
67  /* tz_rules[0] is standard, tz_rules[1] is daylight.  */
68  static tz_rule tz_rules[2];
&lt;/pre&gt;
&lt;p&gt;glibc作为一个库, 其实有三个地方可以初始化一些变量:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;程序启动的时候&lt;/li&gt;
&lt;li&gt;第一次调用的时候&lt;/li&gt;
&lt;li&gt;每次调用时再计算&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;第1个方法会造成不必要的开销(如果这个程序没调用过 &lt;tt class="docutils literal"&gt;localtime&lt;/tt&gt; , 也得初始化)&lt;/li&gt;
&lt;li&gt;第3个方法在每次调用时计算, 效率低,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以glibc的 &lt;tt class="docutils literal"&gt;localtime()&lt;/tt&gt; 选择在第一次调用时初始化, 熟悉单态模式的话就了解, 这里必须加一个锁. 就是这个锁导致 &lt;tt class="docutils literal"&gt;localtime()&lt;/tt&gt; 不是signal-safe的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="free-signal-safe"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;类似的, free()也不是signal-safe&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;free/malloc也用了锁:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
2907        __libc_free (void *mem)
2908        {
          ...
2942          _int_free (ar_ptr, p, 0);
2943        }

3798        static void
3799        _int_free (mstate av, mchunkptr p, int have_lock)
3919          else if (!chunk_is_mmapped(p)) {
3920            if (! have_lock) {
3921              (void)mutex_lock(&amp;amp;av-&amp;gt;mutex);
3922              locked = 1;
3923            }
        ...
4052            if (! have_lock) {
4053              assert (locked);
4054              (void)mutex_unlock(&amp;amp;av-&amp;gt;mutex);
4055            }
4056          }
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;模拟复现&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning/langtest/c/signal-safe$ cat test.c
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void handler(int signum)
{
    char result[100];
    time_t now;
    struct tm time1;

    now = time(NULL);
    localtime_r(&amp;amp;now, &amp;amp;time1);
    strftime(result, 100, &amp;quot;%T&amp;quot;, &amp;amp;time1);
    printf(&amp;quot;At %s, user pressed Ctrl-C\n&amp;quot;, result);
}

int main (void)
{
    time_t now;
    struct tm ltime;
    int i;

    if (signal(SIGHUP, handler) == SIG_IGN){
        return;
    }

    now = time(NULL);
    for(i=0 ; ; i++){
        localtime_r(&amp;amp;now, &amp;amp;ltime);
        if(i%1000 == 0){
            printf(&amp;quot;%d\n&amp;quot;, i);
        }
    }

    return 0;
}
ning&amp;#64;ning-laptop ~/idning/langtest/c/signal-safe$ cat Makefile
all:
    cc test.c
    ./a.out  &amp;amp;
    sleep 1
    pkill -HUP -f 'a.out'
    ps aux | grep a.out
    gdb -p `pidof a.out`
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
(gdb) bt
#0  __lll_lock_wait_private () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:97
#1  0x00002b928c8bfb2d in _L_lock_1934 () at tzset.c:138
#2  0x00002b928c8bf8e7 in __tz_convert (timer=0x2b928cba49f4, use_localtime=1, tp=0x7fff5cef1840) at tzset.c:619
#3  0x0000000000400708 in handler ()
#4  &amp;lt;signal handler called&amp;gt;
#5  _IO_str_init_static_internal (sf=0x7fff5cef1d90, ptr=0x7de354 &amp;quot;8&amp;quot;, size=&amp;lt;value optimized out&amp;gt;, pstart=0x0)
    at strops.c:63
#6  0x00002b928c88d265 in _IO_vsscanf (string=0x7de354 &amp;quot;8&amp;quot;, format=0x2b928c96cb58 &amp;quot;%hu%n:%hu%n:%hu%n&amp;quot;,
    args=0x7fff5cef1eb0) at iovsscanf.c:44
#7  0x00002b928c87a5b8 in __sscanf (s=0x0, format=0x7de354 &amp;quot;8&amp;quot;) at sscanf.c:34
#8  0x00002b928c8bee32 in __tzset_parse_tz (tz=0x7de354 &amp;quot;8&amp;quot;) at tzset.c:212
#9  0x00002b928c8c00ac in __tzfile_compute (timer=1402735871, use_localtime=&amp;lt;value optimized out&amp;gt;,
    leap_correct=0x7fff5cef2090, leap_hit=0x7fff5cef209c, tp=0x7fff5cef20c0) at tzfile.c:682
#10 0x00002b928c8bf9a7 in __tz_convert (timer=0x7fff5cef2100, use_localtime=1, tp=0x7fff5cef20c0) at tzset.c:627
#11 0x00000000004007a1 in main ()
&lt;/pre&gt;
&lt;p&gt;这个栈和twemproxy出现的栈是一样的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;修复&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;有没有``signal-safe`` + &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;thread-safe&lt;/span&gt;&lt;/tt&gt; 的localtime实现?&lt;/p&gt;
&lt;p&gt;至少是可以自己来实现这样一个逻辑的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;修改signal_handler, 只使用signal-safe的函数:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pull request 在此: &lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/231"&gt;https://github.com/twitter/twemproxy/pull/231&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="signal-safe-thread-safe"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;signal-safe/thread safe/可重入&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html"&gt;http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;pre class="literal-block"&gt;
3.313 Reentrant Function

A function whose effect, when called by two or more threads, is guaranteed to be as if the threads each executed the function one after another in an undefined order, even if the actual execution is interleaved.

Thread-Safe

A function that may be safely invoked concurrently by multiple threads. Each function defined in the System Interfaces volume of IEEE Std 1003.1-2001 is thread-safe unless explicitly stated otherwise. Examples are any &amp;quot;pure&amp;quot; function, a function which holds a mutex locked while it is accessing static storage, or objects shared among threads.

3.26 Async-Signal-Safe Function

A function that may be invoked, without restriction, from signal-catching functions. No function is async-signal-safe unless explicitly described as such.
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Reentrant:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不使用全局变量.&lt;/li&gt;
&lt;li&gt;不调用non-reentrant函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Thread-safe:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;要求较低,&lt;/li&gt;
&lt;li&gt;可以访问全局变量，不过需要加锁&lt;/li&gt;
&lt;li&gt;每次调用它返回不同的结果也没关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Async-Signal-Safe:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;只有几个固定的函数是 signal-safe的&lt;/li&gt;
&lt;li&gt;使用了锁的一定不是信号安全的（除非屏蔽了信号）&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可重入函数一定是线程安全的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可重入函数一定是Async-Signal-Safe的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="sprintfasync-signal-safe"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;sprintf不是async-signal-safe&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为malloc/free不是signal-safe, 而gblic 的 vsnprintf用了malloc, 所以sprintf也不是signal-safe&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="async-signal-safe"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;确定一个函数是否 async-signal-safe&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最好严格遵循 &lt;tt class="docutils literal"&gt;man 7 signal&lt;/tt&gt; 的列表, 注意不同系统中async-signal-safe函数列表不同, 比如这里是FreeBSD的库中 signal-safe情况:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.openbsd.org/cgi-bin/man.cgi?query=signal"&gt;http://www.openbsd.org/cgi-bin/man.cgi?query=signal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有glibc 的各个函数列表:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/Library-Summary.html#Library-Summary"&gt;http://www.gnu.org/software/libc/manual/html_node/Library-Summary.html#Library-Summary&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;下面文档定义了glibc中几种safe概念:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html"&gt;http://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;cite&gt;MT-Safe&lt;/cite&gt; : Thread-Safe functions are safe to call in the presence of other threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;cite&gt;AS-Safe&lt;/cite&gt; :  Async-Signal-Safe functions are safe to call from asynchronous signal handlers. AS, in AS-Safe, stands for Asynchronous Signal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;cite&gt;AC-Safe&lt;/cite&gt; &lt;span class="classifier-delimiter"&gt;:&lt;/span&gt; &lt;span class="classifier"&gt;Async-Cancel-Safe functions are safe to call when asynchronous cancellation is enabled. AC in AC-Safe stands for Asynchronous Cancellation.&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;The POSIX standard defines only three functions to be AC-Safe: pthread_cancel, pthread_setcancelstate, and pthread_setcanceltype&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;下面文档定义了glibc中, 导致unsafe的原因:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/Unsafe-Features.html"&gt;http://www.gnu.org/software/libc/manual/html_node/Unsafe-Features.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;lock&lt;/tt&gt; Functions marked with lock as an AS-Unsafe feature may be interrupted by a signal while holding a non-recursive lock. If the signal handler calls another such function that takes the same lock, the result is a deadlock.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;corrupt&lt;/tt&gt; Functions marked with corrupt as an AS-Unsafe feature may corrupt data structures and misbehave when they interrupt,&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;heap&lt;/tt&gt; Functions marked with heap may call heap memory management functions from the malloc/free family of functions and are only as safe as those functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如 &lt;tt class="docutils literal"&gt;vsnprintf&lt;/tt&gt; 就是AS-Unsafe, 因为它用了malloc/free这样的heap函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
— Function: int vsnprintf (char *s, size_t size, const char *template, va_list ap)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety Concepts.
&lt;/pre&gt;
&lt;p&gt;所有printf系列函数都是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;AS-Unsafe&lt;/span&gt;&lt;/tt&gt; 的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;其它系统中&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;FreeBSD中更多的signal-safe函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ffs, htonl, htons, memccpy, memchr, memcmp, memcpy, memmove, memset, ntohl, ntohs, stpcpy, stpncpy, strcat, strchr, strcmp, strcpy, strcspn, strlen, strncat, strncmp, strncpy, strnlen, strpbrk, strrchr, strspn, strstr, strtok_r, wcpcpy, wcpncpy, wcscat, wcschr, wcscmp, wcscpy, wcscspn, wcslen, wcsncat, wcsncmp, wcsncpy, wcsnlen, wcspbrk, wcsrchr, wcsspn, wcsstr, wcstok, wmemchr, wmemcmp, wmemcpy, wmemmove, wmemset
&lt;/pre&gt;
&lt;p&gt;上面这些函数在目前已知的实现中, 都是signal-safe的, 参考下文, 这些函数已经加到signal-safe函数列表中, 参见: &lt;a class="reference external" href="http://austingroupbugs.net/view.php?id=692#c1609"&gt;http://austingroupbugs.net/view.php?id=692#c1609&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="as-safe"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;这些函数是AS-SAFE的&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;strtol&lt;/tt&gt; (参考http://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html#Parsing-of-Integers)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx为什么没有这个问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;nginx自己实现了一套printf:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
u_char *
ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)
{
    u_char                *p, zero;
    ngx_uint_t             width, sign, hex, max_width, frac_width, n;

    while (*fmt &amp;amp;&amp;amp; buf &amp;lt; last) {

        /*
         * &amp;quot;buf &amp;lt; last&amp;quot; means that we could copy at least one character:
         * the plain character, &amp;quot;%%&amp;quot;, &amp;quot;%c&amp;quot;, and minus without the checking
         */

        if (*fmt == '%') {

            i64 = 0;
            ui64 = 0;
&lt;/pre&gt;
&lt;p&gt;ngx还使用了时间cache, 从而能够在打日志的时候使用正确的时间字符串.&lt;/p&gt;
&lt;p&gt;ngx 中时间cache是通过timer信号来更新的, 略复杂.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mysql"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;mysql&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;也是实现了一族safe函数.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
size_t my_safe_snprintf(char* to, size_t n, const char* fmt, ...)
  ATTRIBUTE_FORMAT(printf, 3, 4);

/**
  A (very) limited version of snprintf, which writes the result to STDERR.
  &amp;#64;sa my_safe_snprintf
  Implemented with simplicity, and async-signal-safety in mind.
  &amp;#64;note Has an internal buffer capacity of 512 bytes,
  which should suffice for our signal handling routines.
*/
size_t my_safe_printf_stderr(const char* fmt, ...)
  ATTRIBUTE_FORMAT(printf, 1, 2);
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;记住linux中, localtime, vsnprintf, malloc/free都是 AS-Unsafe的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;Reference&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;linux signal-safe函数列表: &lt;a class="reference external" href="http://man7.org/linux/man-pages/man7/signal.7.html"&gt;http://man7.org/linux/man-pages/man7/signal.7.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FreeBSD signal-safe 函数列表: &lt;a class="reference external" href="http://www.openbsd.org/cgi-bin/man.cgi?query=signal"&gt;http://www.openbsd.org/cgi-bin/man.cgi?query=signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FreeBSD 中 其它可以认为signal-safe的函数(目前已知实现都是safe的): &lt;a class="reference external" href="http://austingroupbugs.net/view.php?id=692#c1609"&gt;http://austingroupbugs.net/view.php?id=692#c1609&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;glibc 中所有函数是否signal-safe: &lt;a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/Library-Summary.html#Library-Summary"&gt;http://www.gnu.org/software/libc/manual/html_node/Library-Summary.html#Library-Summary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;va_start 是宏&lt;/li&gt;
&lt;li&gt;glibc代码(这个网站不错): &lt;a class="reference external" href="http://code.woboq.org/userspace/glibc/time/tzset.c.html"&gt;http://code.woboq.org/userspace/glibc/time/tzset.c.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个libc free时内存溢出后死锁的问题(这个和信号无关, 分析很赞): &lt;a class="reference external" href="http://www.cnblogs.com/hokyhu/archive/2012/09/14/2685437.html"&gt;http://www.cnblogs.com/hokyhu/archive/2012/09/14/2685437.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html"&gt;http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;reentrant，thread-safe 和 async-signal-safe: &lt;a class="reference external" href="http://wangcong.org/blog/archives/506"&gt;http://wangcong.org/blog/archives/506&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;redis源码中之前也存在这个问题: &lt;a class="reference external" href="https://github.com/antirez/redis/issues/213"&gt;https://github.com/antirez/redis/issues/213&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy-core-20140523</title><link href="/twemproxy-core-20140523.html" rel="alternate"></link><updated>2014-05-25T12:56:48+08:00</updated><author><name>ning</name></author><id>tag:,2014-05-25:twemproxy-core-20140523.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#what-happend" id="id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;what happend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#repetition" id="id2"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;Repetition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#explain" id="id3"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;explain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#add-a-testcase" id="id4"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;add-a-testcase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fix" id="id5"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;fix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#more-bugs" id="id6"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;more bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="what-happend"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;what happend&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;today we got a core of twemproxy:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gdb -c core.14420 ./bin/nutcracker

(gdb) bt
#0  0x000000302af2e2ed in raise () from /lib64/tls/libc.so.6
#1  0x000000302af2fa3e in abort () from /lib64/tls/libc.so.6
#2  0x0000000000419c82 in nc_assert (cond=0x444dc0 &amp;quot;!TAILQ_EMPTY(&amp;amp;send_msgq) &amp;amp;&amp;amp; nsend != 0&amp;quot;, file=0x444aa8 &amp;quot;nc_message.c&amp;quot;, line=745, panic=1) at nc_util.c:308
#3  0x000000000040d0d6 in msg_send_chain (ctx=0x553090, conn=0x55b380, msg=0x0) at nc_message.c:745
#4  0x000000000040d568 in msg_send (ctx=0x553090, conn=0x55b380) at nc_message.c:820
#5  0x00000000004059af in core_send (ctx=0x553090, conn=0x55b380) at nc_core.c:173
#6  0x0000000000405ffe in core_core (arg=0x55b380, events=65280) at nc_core.c:301
#7  0x0000000000429297 in event_wait (evb=0x5652e0, timeout=389) at nc_epoll.c:269
#8  0x000000000040606f in core_loop (ctx=0x553090) at nc_core.c:316
#9  0x000000000041b109 in nc_run (nci=0x7fbfffea80) at nc.c:530
#10 0x000000000041b20d in main (argc=14, argv=0x7fbfffecc8) at nc.c:579
(gdb) f 3
#3  0x000000000040d0d6 in msg_send_chain (ctx=0x553090, conn=0x55b380, msg=0x0) at nc_message.c:745
745         ASSERT(!TAILQ_EMPTY(&amp;amp;send_msgq) &amp;amp;&amp;amp; nsend != 0);
(gdb) l
740             if (msg == NULL) {
741                 break;
742             }
743         }
744
745         ASSERT(!TAILQ_EMPTY(&amp;amp;send_msgq) &amp;amp;&amp;amp; nsend != 0);
746
747         conn-&amp;gt;smsg = NULL;
748
749         n = conn_sendv(conn, &amp;amp;sendv, nsend);
&lt;/pre&gt;
&lt;p&gt;it is caused by this &lt;tt class="docutils literal"&gt;ASSERT&lt;/tt&gt; at nc_message.c:745,&lt;/p&gt;
&lt;p&gt;this core is not always raise when we do the same request again,&lt;/p&gt;
&lt;p&gt;if we use -v 9 to debug, it never raise.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="repetition"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;Repetition&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;use gdb, we found that the msg we want to send is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p * (send_msgq.tqh_first )
$6 = {c_tqe = {tqe_next = 0x0, tqe_prev = 0x0, trace = {lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 291, prevfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, prevline = 270}}, s_tqe = {tqe_next = 0x0, tqe_prev = 0x0,
    trace = {lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 302, prevfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, prevline = 279}}, m_tqe = {tqe_next = 0x0, tqe_prev = 0x7fbfffe8c0, trace = {
      lastfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;, lastline = 712, prevfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;, prevline = 196}}, id = 6515, peer = 0x810cc0, owner = 0x55ae00, tmo_rbe = {left = 0x0, right = 0x0,
    parent = 0x0, key = 0, data = 0x0, color = 0 '\0'}, mhdr = {stqh_first = 0x82ecc0, stqh_last = 0x82ecc8}, mlen = 0, state = 0,
  pos = 0x82eaf4 &amp;quot;:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n:0\r\n&amp;quot;,
  token = 0x0, parser = 0x42713b &amp;lt;redis_parse_rsp&amp;gt;, result = MSG_PARSE_OK, pre_splitcopy = 0x427e1d &amp;lt;redis_pre_splitcopy&amp;gt;, post_splitcopy = 0x427f8a &amp;lt;redis_post_splitcopy&amp;gt;,
  pre_coalesce = 0x42816a &amp;lt;redis_pre_coalesce&amp;gt;, post_coalesce = 0x428557 &amp;lt;redis_post_coalesce&amp;gt;, type = MSG_RSP_REDIS_INTEGER, key_start = 0x0, key_end = 0x0, vlen = 0, end = 0x0, narg_start = 0x0,
  narg_end = 0x0, narg = 0, rnarg = 0, rlen = 0, integer = 0, frag_owner = 0x0, nfrag = 0, frag_id = 0, err = 0, error = 0, ferror = 0, request = 0, quit = 0, noreply = 0, done = 0, fdone = 0,
  first_fragment = 0, last_fragment = 0, swallow = 0, redis = 1}
&lt;/pre&gt;
&lt;p&gt;this is the only msg( and the last msg) in send_msgq, &lt;tt class="docutils literal"&gt;mlen=0&lt;/tt&gt; ,&lt;/p&gt;
&lt;p&gt;and it's peer request is a fragment of a delete cmd:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p * (send_msgq.tqh_first -&amp;gt; peer )
$5 = {c_tqe = {tqe_next = 0x75e140, tqe_prev = 0x55b400, trace = {lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 270, prevfile = 0x0, prevline = 0}}, s_tqe = {tqe_next = 0x0, tqe_prev = 0x0, trace = {
      lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 302, prevfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, prevline = 279}}, m_tqe = {tqe_next = 0x0, tqe_prev = 0x0, trace = {lastfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;,
      lastline = 758, prevfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;, prevline = 712}}, id = 4515, peer = 0x5fe2c0, owner = 0x55b380, tmo_rbe = {left = 0x0, right = 0x0, parent = 0x0, key = 0, data = 0x0,
    color = 0 '\0'}, mhdr = {stqh_first = 0x6c1090, stqh_last = 0x6c1098}, mlen = 47, state = 0,
  pos = 0x6c0eef &amp;quot;*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_393307809209&amp;quot;..., token = 0x0, parser = 0x421279 &amp;lt;redis_parse_req&amp;gt;, result = MSG_PARSE_OK, pre_splitcopy = 0x427e1d &amp;lt;redis_pre_splitcopy&amp;gt;,
  post_splitcopy = 0x427f8a &amp;lt;redis_post_splitcopy&amp;gt;, pre_coalesce = 0x42816a &amp;lt;redis_pre_coalesce&amp;gt;, post_coalesce = 0x428557 &amp;lt;redis_post_coalesce&amp;gt;, type = MSG_REQ_REDIS_DEL,
  key_start = 0x6c0ed2 &amp;quot;rrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nD&amp;quot;...,
  key_end = 0x6c0eed &amp;quot;\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092&amp;quot;..., vlen = 0, end = 0x0,
  narg_start = 0x6c0ec0 &amp;quot;*2\r\n$3\r\ndel\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_566362775949&amp;quot;...,
  narg_end = 0x6c0ec2 &amp;quot;\r\n$3\r\ndel\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_56636277594915&amp;quot;..., narg = 2, rnarg = 0, rlen = 0, integer = 0, frag_owner = 0x75e4f0, nfrag = 0, frag_id = 1256, err = 0, error = 0, ferror = 0, request = 1, quit = 0,
  noreply = 0, done = 1, fdone = 1, first_fragment = 0, last_fragment = 1, swallow = 0, redis = 1}
&lt;/pre&gt;
&lt;p&gt;the orig msg is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) p * (send_msgq.tqh_first -&amp;gt; peer -&amp;gt;frag_owner )
$23 = {c_tqe = {tqe_next = 0x0, tqe_prev = 0x0, trace = {lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 291, prevfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, prevline = 270}}, s_tqe = {tqe_next = 0x0, tqe_prev = 0x0,
    trace = {lastfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, lastline = 302, prevfile = 0x444e28 &amp;quot;nc_request.c&amp;quot;, prevline = 279}}, m_tqe = {tqe_next = 0x5f9740, tqe_prev = 0x551f80, trace = {
      lastfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;, lastline = 360, prevfile = 0x444aa8 &amp;quot;nc_message.c&amp;quot;, prevline = 758}}, id = 4514, peer = 0x0, owner = 0x55b380, tmo_rbe = {left = 0x0, right = 0x0, parent = 0x0,
    key = 0, data = 0x0, color = 1 '\001'}, mhdr = {stqh_first = 0x0, stqh_last = 0x75e5c8}, mlen = 34, state = 27,
  pos = 0x74f15f &amp;quot;$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n&amp;quot;..., token = 0x0, parser = 0x421279 &amp;lt;redis_parse_req&amp;gt;, result = MSG_PARSE_FRAGMENT, pre_splitcopy = 0x427e1d &amp;lt;redis_pre_splitcopy&amp;gt;,
  post_splitcopy = 0x427f8a &amp;lt;redis_post_splitcopy&amp;gt;, pre_coalesce = 0x42816a &amp;lt;redis_pre_coalesce&amp;gt;, post_coalesce = 0x428557 &amp;lt;redis_post_coalesce&amp;gt;, type = MSG_REQ_REDIS_DEL,
  key_start = 0x74f142 &amp;quot;rrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\ncoun&amp;quot;...,
  key_end = 0x74f15d &amp;quot;\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3&amp;quot;..., vlen = 0, end = 0x0,
  narg_start = 0x74ed80 &amp;quot;*2\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r&amp;quot;,
  narg_end = 0x74ed82 &amp;quot;\r\n$3\r\nDEL\r\n$27\r\nrrr_kkk_3933078092091789232\r\n$27\r\nrrr_kkk_5663627759491506624\r\n*3\r\n$3\r\nDEL\r&amp;quot;, narg = 3, rnarg = 1, rlen = 0, integer = 0, frag_owner = 0x75e4f0,
  nfrag = 2, frag_id = 1256, err = 0, error = 0, ferror = 0, request = 1, quit = 0, noreply = 0, done = 1, fdone = 1, first_fragment = 1, last_fragment = 0, swallow = 0, redis = 1}
&lt;/pre&gt;
&lt;p&gt;we found that it's a DEL cmd with narg=3. the orig cmd is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEL rrr_kkk_3933078092091789232 rrr_kkk_5663627759491506624
&lt;/pre&gt;
&lt;p&gt;so we try to repetition this bug with lot's of MULTI-DEL.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="explain"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;explain&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;a MULTI-DEL cmd will split into many &lt;tt class="docutils literal"&gt;DEL&lt;/tt&gt; in nutcracker,&lt;/p&gt;
&lt;p&gt;response will coalesce. (all fragment except the first one will be rewrite to empty msg), following pic show the split and coalesce of msg:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-core-201405-001.png" /&gt;
&lt;p&gt;ok, let's check this code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
msg_send_chain(struct context *ctx, struct conn *conn, struct msg *msg)
{
    ...
    TAILQ_INIT(&amp;amp;send_msgq);
    array_set(&amp;amp;sendv, iov, sizeof(iov[0]), NC_IOV_MAX);
    nsend = 0;
    for (;;) {
        ASSERT(conn-&amp;gt;smsg == msg);

        TAILQ_INSERT_TAIL(&amp;amp;send_msgq, msg, m_tqe);

        for (mbuf = STAILQ_FIRST(&amp;amp;msg-&amp;gt;mhdr);
             mbuf != NULL &amp;amp;&amp;amp; array_n(&amp;amp;sendv) &amp;lt; NC_IOV_MAX &amp;amp;&amp;amp; nsend &amp;lt; limit;
             mbuf = nbuf) {
            nbuf = STAILQ_NEXT(mbuf, next);

            if (mbuf_empty(mbuf)) {
                continue;
            }

            mlen = mbuf_length(mbuf);
            if ((nsend + mlen) &amp;gt; limit) {
                mlen = limit - nsend;
            }

            ciov = array_push(&amp;amp;sendv);
            ciov-&amp;gt;iov_base = mbuf-&amp;gt;pos;
            ciov-&amp;gt;iov_len = mlen;

            nsend += mlen;
        }

        if (array_n(&amp;amp;sendv) &amp;gt;= NC_IOV_MAX || nsend &amp;gt;= limit) {
            break;
        }

        msg = conn-&amp;gt;send_next(ctx, conn);
        if (msg == NULL) {
            break;
        }
    }

    //log_debug(LOG_VVERB, &amp;quot;conn-&amp;gt;client: %d, len_sendv: %d nsend: %d&amp;quot;, conn-&amp;gt;client, array_n(&amp;amp;sendv), nsend);
    ASSERT(!TAILQ_EMPTY(&amp;amp;send_msgq) &amp;amp;&amp;amp; nsend != 0);
    conn-&amp;gt;smsg = NULL;
    n = conn_sendv(conn, &amp;amp;sendv, nsend);
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;conn_send&lt;/tt&gt; send no more than &lt;tt class="docutils literal"&gt;NC_IOV_MAX(128)&lt;/tt&gt; pieces in this function,&lt;/p&gt;
&lt;p&gt;if the first fragment of MULTI-DEL response is send on last batch. and this is the last msg in send queue, the next call of &lt;tt class="docutils literal"&gt;msg_send_chain&lt;/tt&gt; will got &lt;tt class="docutils literal"&gt;nsend == 0&lt;/tt&gt;:&lt;/p&gt;
&lt;p&gt;following img show such a case:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;mget on 126 keys&lt;/li&gt;
&lt;li&gt;a mutli-del cmd&lt;/li&gt;
&lt;/ol&gt;
&lt;img alt="" src="/imgs/twemproxy-core-201405-002.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="add-a-testcase"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;add-a-testcase&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;the test case with &lt;a class="reference external" href="https://github.com/idning/test-twemproxy"&gt;test-twemproxy&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_multi_delete_20140525():
    conn = redis.Redis('127.0.0.5', 4100)
    cnt = 126
    keys = ['key-%s'%i for i in range(cnt)]
    pipe = conn.pipeline(transaction=False)
    pipe.mget(keys)
    pipe.delete(*keys)
    print pipe.execute()
&lt;/pre&gt;
&lt;p&gt;see: &lt;a class="reference external" href="https://github.com/idning/test-twemproxy/blob/master/test_redis/test_del.py#L56-L63"&gt;https://github.com/idning/test-twemproxy/blob/master/test_redis/test_del.py#L56-L63&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;fix&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;we do not need this comment here:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ASSERT(!TAILQ_EMPTY(&amp;amp;send_msgq) &amp;amp;&amp;amp; nsend != 0);
&lt;/pre&gt;
&lt;p&gt;and we should eat all the fragment of MULTI-DEL in &lt;tt class="docutils literal"&gt;msg_send_chain&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-bugs"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;more bugs&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;current master (8a4f5c0)can not pass following cases:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
test_redis.test_mget_mset.test_mget_special_key ... ERROR
test_redis.test_mget_mset.test_mget_special_key_2 ... ERROR
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>fatcache-cr</title><link href="/fatcache-cr.html" rel="alternate"></link><updated>2014-05-21T14:17:46+08:00</updated><author><name>ning</name></author><id>tag:,2014-05-21:fatcache-cr.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id8"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;设计理念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id9"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;代码&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fc-request-c" id="id10"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;fc_request.c 中的请求处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mmap-map-anonymous" id="id11"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;mmap 的和 MAP_ANONYMOUS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#device-size" id="id12"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;如何获取device_size&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#slab" id="id13"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;slab逻辑&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id14"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id15"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;启动日志如下&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id16"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;写操作过程中对slab的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;性能测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id18"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#todo" id="id19"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;TODO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;设计理念&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Eliminate small, random disk writes&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;batched write&lt;/li&gt;
&lt;li&gt;如果用mmap的方式使用ssd(比如mongo), 就会产生很多随机写.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Minimize disk reads on cache hit&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Fatcache reduces disk reads by maintaining an in-memory index for all on-disk data.&lt;/li&gt;
&lt;li&gt;no disk accesses on cache miss and only a single disk access on cache hit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;定期gc, 对所有在磁盘上, 而不在内存索引中的元素清掉.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;内存index&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;所有key放在内存中, 内存中hash表记录value在磁盘上的位置.&lt;/li&gt;
&lt;li&gt;拉链式hash表&lt;/li&gt;
&lt;li&gt;为了减少key放在内存中的大小, 使用sha1, (冲突在读的时候会检测, 写的时候覆盖.)&lt;/li&gt;
&lt;li&gt;The index entry (struct itemx) on a 64-bit system is 44 bytes in size&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;代码&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;量不大:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-github/fatcache/src$ cat *.c *.h|wc -l
9830
&lt;/pre&gt;
&lt;p&gt;util:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fc_queue.h
fc_array.c
fc_array.h
fc_log.c
fc_log.h
fc_sha1.c
fc_sha1.h
fc_signal.c
fc_signal.h
fc_string.c
fc_string.h
fc_time.c
fc_time.h
fc_util.c
fc_util.h
&lt;/pre&gt;
&lt;p&gt;事件和连接处理:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fc_event.c
fc_event.h
fc_connection.c
fc_connection.h
fc_mbuf.c
fc_mbuf.h
fc_core.c
fc_core.h
fc_client.c
fc_client.h
fc_server.c
fc_server.h
&lt;/pre&gt;
&lt;p&gt;请求处理:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fc.c
fc_memcache.c           协议解析.
fc_memcache.h
fc_message.c
fc_message.h
fc_request.c            #处理请求, 转化为itemx/slab 存储. 读取.
fc_response.c           #如何发送response
&lt;/pre&gt;
&lt;p&gt;cache模型:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fc_item.c
fc_item.h
fc_itemx.c
fc_itemx.h
fc_slab.c
fc_slab.h
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;util&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;事件处理&lt;/tt&gt; 部分和twemproxy有极大复用度. 请求处理部分主要是协议的解析.&lt;/p&gt;
&lt;p&gt;fc_request是负责将解析出来的请求转化为存储层的函数调用(操作item/itemx/slab)&lt;/p&gt;
&lt;p&gt;概念:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;item: 一个kv对,&lt;/li&gt;
&lt;li&gt;itemx: 索引项&lt;/li&gt;
&lt;li&gt;slab: 用来存储item, 一个slab默认是1M(最大可配为512M), 可以存放多个item. slab有内存和磁盘两种类型.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;item:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct item {
    uint32_t          magic;      /* item magic (const) */
    uint32_t          offset;     /* raw offset from owner slab base (const) */
    uint32_t          sid;        /* slab id (const) */
    uint8_t           cid;        /* slab class id (const) */
    uint8_t           unused[2];  /* unused */
    uint8_t           nkey;       /* key length */
    uint32_t          ndata;      /* date length */
    rel_time_t        expiry;     /* expiry in secs */
    uint32_t          flags;      /* flags opaque to the server */
    uint8_t           md[20];     /* key sha1*/
    uint32_t          hash;       /* key hash */
    uint8_t           end[1];     /* item data */
};

uint8_t * item_key(struct item *it) { return it-&amp;gt;end; }                                     //获得item-&amp;gt;key
uint8_t * item_data(struct item *it) { return it-&amp;gt;end + it-&amp;gt;nkey; }                         //获得item-&amp;gt;value
size_t item_ntotal(uint8_t nkey, uint32_t ndata) { return ITEM_HDR_SIZE + nkey + ndata; }   //获得item大小.

struct itemx {
    STAILQ_ENTRY(itemx) tqe;    /* link in index / free q */
    uint8_t             md[20]; /* sha1 */
    uint32_t            sid;    /* owner slab id */
    uint32_t            offset; /* item offset from owner slab base */
    uint64_t            cas;    /* cas */
} __attribute__ ((__packed__));

struct slab {
    uint32_t  magic;     /* slab magic (const) */
    uint32_t  sid;       /* slab id */
    uint8_t   cid;       /* slab class id */
    uint8_t   unused[3]; /* unused */
    uint8_t   data[1];   /* opaque data */
};
&lt;/pre&gt;
&lt;div class="section" id="fc-request-c"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;fc_request.c 中的请求处理&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
static void
req_process_get(struct context *ctx, struct conn *conn, struct msg *msg)
{
    struct itemx *itx;
    struct item *it;

    itx = itemx_getx(msg-&amp;gt;hash, msg-&amp;gt;md);
    if (itx == NULL) {
        msg_type_t type;

        /*
         * On a miss, we send a &amp;quot;END\r\n&amp;quot; response, unless the request
         * is an intermediate fragment in a fragmented request.
         */
        if (msg-&amp;gt;frag_id == 0 || msg-&amp;gt;last_fragment) {
            type = MSG_RSP_END;
        } else {
            type = MSG_EMPTY;
        }

        rsp_send_status(ctx, conn, msg, type);
        return;
    }

    /*
     * On a hit, we read the item with address [sid, offset] and respond
     * with item value if the item hasn't expired yet.
     */
    it = slab_read_item(itx-&amp;gt;sid, itx-&amp;gt;offset);
    if (it == NULL) {
        rsp_send_error(ctx, conn, msg, MSG_RSP_SERVER_ERROR, errno);
        return;
    }
    if (item_expired(it)) {
        rsp_send_status(ctx, conn, msg, MSG_RSP_NOT_FOUND);
        return;
    }

    rsp_send_value(ctx, conn, msg, it, itx-&amp;gt;cas);
}

static void
req_process_set(struct context *ctx, struct conn *conn, struct msg *msg)
{
    uint8_t *key, nkey, cid;
    struct item *it;

    key = msg-&amp;gt;key_start;
    nkey = (uint8_t)(msg-&amp;gt;key_end - msg-&amp;gt;key_start);

    cid = item_slabcid(nkey, msg-&amp;gt;vlen);
    if (cid == SLABCLASS_INVALID_ID) {
        rsp_send_error(ctx, conn, msg, MSG_RSP_CLIENT_ERROR, EINVAL);
        return;
    }

    itemx_removex(msg-&amp;gt;hash, msg-&amp;gt;md);

    it = item_get(key, nkey, cid, msg-&amp;gt;vlen, time_reltime(msg-&amp;gt;expiry),
                  msg-&amp;gt;flags, msg-&amp;gt;md, msg-&amp;gt;hash);
    if (it == NULL) {
        rsp_send_error(ctx, conn, msg, MSG_RSP_SERVER_ERROR, ENOMEM);
        return;
    }

    mbuf_copy_to(&amp;amp;msg-&amp;gt;mhdr, msg-&amp;gt;value, item_data(it), msg-&amp;gt;vlen);

    rsp_send_status(ctx, conn, msg, MSG_RSP_STORED);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="mmap-map-anonymous"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;mmap 的和 MAP_ANONYMOUS&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;代码中看到下面这种用法, 不理解是什么意思, 于是查了一下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void *
_fc_mmap(size_t size, const char *name, int line)
{
    p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,
             -1, 0);
}
&lt;/pre&gt;
&lt;p&gt;man:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
MAP_ANONYMOUS
  The mapping is not backed by any file; its contents are initialized to zero.  The fd and offset arguments are ignored; however, some implementations require fd to be  -1  if  MAP_ANONYMOUS
  (or MAP_ANON) is specified, and portable applications should ensure this.  The use of MAP_ANONYMOUS in conjunction with MAP_SHARED is only supported on Linux since kernel 2.4.
&lt;/pre&gt;
&lt;p&gt;mmap 的 &lt;tt class="docutils literal"&gt;MAP_ANONYMOUS&lt;/tt&gt; 相当于malloc一片内存:&lt;/p&gt;
&lt;p&gt;MAP_ANONYMOUS is commonly used for two things on systems that implement it:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;To share a memory region between a parent and a child, as you said.  However, it requires that the child does not execve(), since it must have the pointer to the mmap()ed address.&lt;/li&gt;
&lt;li&gt;To simply get memory pages from the kernel. That's how most malloc() implementations work nowadays. (The glibc malloc() uses brk() for small allocations and mmap() with MAP_ANONYMOUS for big ones.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
itemx_init:
    /* init item index memory */
    itx = fc_mmap(settings.max_index_memory);
    if (itx == NULL) {
        return FC_ENOMEM;
    }
    istart = itx;
    iend = itx + n;

slab_init:
    /* init nmslab, mstart and mend */
    nmslab = MAX(nctable, settings.max_slab_memory / settings.slab_size);
    mspace = nmslab * settings.slab_size;
    mstart = fc_mmap(mspace);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="device-size"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;如何获取device_size&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
fc_device_size(const char *path, size_t *size)
{
    fd = open(path, O_RDONLY, 0644);
    status = ioctl(fd, BLKGETSIZE64, size);
    return FC_OK;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="slab"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;slab逻辑&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;fatcache 有两种slab: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mem-slab&lt;/span&gt;&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;disk-slab&lt;/span&gt;&lt;/tt&gt;, 大小相同,&lt;/p&gt;
&lt;p&gt;mem-slab作为disk-slab的写buffer.&lt;/p&gt;
&lt;p&gt;一个slab里面可以包含多个item. 写操作都是写到mem-slab, 写满一个, 就交换到disk-slab, 能做到顺序写, 随机读, 从而最大化ssd利用率.&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;启动&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
struct settings {
    size_t   max_slab_memory;              /* maximum memory allowed for slabs in bytes */
    size_t   max_index_memory;             /* maximum memory allowed for in bytes */
    size_t   slab_size;                    /* slab size */

    size_t   chunk_size;                   /* minimum item chunk size */
    size_t   max_chunk_size;               /* maximum item chunk size */
    double   factor;                       /* item chunk size growth factor */
};
&lt;/pre&gt;
&lt;p&gt;启动后, 先从配置中获得slab_size, 根据配置的mem-slab大小和磁盘大小, 计算总共有多少个slab, 分别初始化 ctable和stable:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
slab_init(void)
{

    status = slab_init_ctable();                //根据factor, 初始化一系列slab-class, 每个slab-class的item-size呈递增关系.

    //计算有多少个mem-slab
    nmslab = MAX(nctable, settings.max_slab_memory / settings.slab_size);

    //计算有多少个disk-slab
    status = fc_device_size(settings.ssd_device, &amp;amp;size);
    ndchunk = size / settings.slab_size;        //整个device能放多少个slab?
    ASSERT(settings.server_n &amp;lt;= ndchunk);
    ndslab = ndchunk / settings.server_n;

    status = slab_init_stable();
}
&lt;/pre&gt;
&lt;p&gt;slab的总个数就是nmslab+ndslab.  slab总数, mslab, dslab 的个数都是不会变的.&lt;/p&gt;
&lt;p&gt;初始化完成后, 所有的mem-slab和disk-slab都被标记为free(放到free_xxx_q里面)&lt;/p&gt;
&lt;p&gt;初始化完成后, 如下图所示:&lt;/p&gt;
&lt;img alt="" src="/imgs/fatcache-001.png" style="width: 800px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;启动日志如下&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
$ ./src/fatcache -D /dev/sdb -p 11211 -s 0/8
[Wed May 21 21:51:51 2014] fc.c:683 fatcache-0.1.1 started on pid 1721
[Wed May 21 21:51:51 2014] fc.c:688 configured with debug logs disabled, asserts disabled, panic disabled
[Wed May 21 21:51:51 2014] fc_slab.c:85 slab size 1048576, slab hdr size 12, item hdr size 52, item chunk size 88
[Wed May 21 21:51:51 2014] fc_slab.c:88 index memory 0, slab memory 67108864, disk space 239498952704
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   0: items   11915  size      88  data      36  slack      44
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   1: items    9362  size     112  data      60  slack      20
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   2: items    7281  size     144  data      92  slack     100
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   3: items    5698  size     184  data     132  slack     132
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   4: items    4519  size     232  data     180  slack     156
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   5: items    3542  size     296  data     244  slack     132
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   6: items    2788  size     376  data     324  slack     276
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   7: items    2221  size     472  data     420  slack     252
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   8: items    1771  size     592  data     540  slack     132
[Wed May 21 21:51:51 2014] fc_slab.c:94 class   9: items    1409  size     744  data     692  slack     268
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  10: items    1120  size     936  data     884  slack     244
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  11: items     891  size    1176  data    1124  slack     748
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  12: items     712  size    1472  data    1420  slack     500
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  13: items     569  size    1840  data    1788  slack    1604
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  14: items     455  size    2304  data    2252  slack     244
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  15: items     364  size    2880  data    2828  slack     244
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  16: items     291  size    3600  data    3548  slack     964
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  17: items     232  size    4504  data    4452  slack    3636
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  18: items     186  size    5632  data    5580  slack    1012
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  19: items     148  size    7040  data    6988  slack    6644
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  20: items     119  size    8800  data    8748  slack    1364
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  21: items      95  size   11000  data   10948  slack    3564
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  22: items      76  size   13752  data   13700  slack    3412
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  23: items      60  size   17192  data   17140  slack   17044
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  24: items      48  size   21496  data   21444  slack   16756
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  25: items      39  size   26872  data   26820  slack     556
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  26: items      31  size   33592  data   33540  slack    7212
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  27: items      24  size   41992  data   41940  slack   40756
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  28: items      19  size   52496  data   52444  slack   51140
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  29: items      15  size   65624  data   65572  slack   64204
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  30: items      12  size   82032  data   81980  slack   64180
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  31: items      10  size  102544  data  102492  slack   23124
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  32: items       8  size  128184  data  128132  slack   23092
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  33: items       6  size  160232  data  160180  slack   87172
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  34: items       5  size  200296  data  200244  slack   47084
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  35: items       4  size  250376  data  250324  slack   47060
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  36: items       3  size  312976  data  312924  slack  109636
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  37: items       2  size  391224  data  391172  slack  266116
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  38: items       2  size  489032  data  488980  slack   70500
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  40: items       1  size  764120  data  764068  slack  284444
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  41: items       1  size  955152  data  955100  slack   93412
[Wed May 21 21:51:51 2014] fc_slab.c:94 class  42: items       1  size 1048564  data 1048512  slack       0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;写操作过程中对slab的使用&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
req_process_set
    cid = item_slabcid(nkey, msg-&amp;gt;vlen)     //计算需要一个多大的item
    itemx_removex(msg-&amp;gt;hash, msg-&amp;gt;md);      //如果索引里面已有, 删掉
    item_get                                //获得一个klen+vlen大小的item.
        slab_get_item
            1. 尝试从ctable[cid]-&amp;gt;partial_msinfoq 里面获取.  如果获取到则返回
            2. 尝试从free_msinfoq中获取一个free的mslab挂到 ctable[cid]-&amp;gt;partial_msinfoq, to 1.
            3. 如果上面两步都失败, 则 slab_drain()
                如果还有空闲的dslab, 直接把这个mslab刷到dslab.
                如果没有:
                slab_evict //先回收一块磁盘上的空间. (这会导致写操作的时候有读)
                _slab_drain //把一个写满的mem_slab刷盘.
                    - pwrite
&lt;/pre&gt;
&lt;p&gt;这里我主要分析mem-slab和disk-slab交换的过程, 在如下时刻都是转折点:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;启动后第一个插入操作.&lt;/li&gt;
&lt;li&gt;mem-slab用光, 开始启用第一个disk-slab&lt;/li&gt;
&lt;li&gt;disk-slab用光, 开始会对disk-slab做回收.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面举例:&lt;/p&gt;
&lt;p&gt;在获取slab的过程中, 我们假设 假设每次写操作都希望获得一个size为100的item, 这样就只会涉及到一个slab class.( &lt;tt class="docutils literal"&gt;ctable[1]&lt;/tt&gt; )&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;第一次写, 发现 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ctable[1]-&amp;gt;partial_msinfoq&lt;/span&gt;&lt;/tt&gt; 为空, 于是从 &lt;tt class="docutils literal"&gt;free_msinfoq&lt;/tt&gt; 中拿一个挂到 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ctable[cid]-&amp;gt;partial_msinfoq&lt;/span&gt;&lt;/tt&gt; , 并从这个slab中分配一个item, 写入数据,
这样一直写, 直到这个slab写满, 就把它移到full_msinfoq, 并获取下一个free_msinfoq&lt;/p&gt;
&lt;p&gt;这个过程如下图:&lt;/p&gt;
&lt;img alt="" src="/imgs/fatcache-002.png" style="width: 500px;" /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;当mem-slab用光后, 就会开始使用disk-slab, 这是通过一次drain实现的, drain 会找到一个free 的disk-slab, 把它刷到这个disk-slab对应的磁盘上,
这样就产生了一个free-mem-slab 和一个full-disk-slab.&lt;/p&gt;
&lt;img alt="" src="/imgs/fatcache-003.png" style="width: 500px;" /&gt;
&lt;p&gt;此后full_msinfoq 就一直处于空的状态, 每次需要一个slab, 都发生一次drain, 每次drain都会消耗一个disk-slab, 如下图:&lt;/p&gt;
&lt;img alt="" src="/imgs/fatcache-004.png" style="width: 500px;" /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;再过了一段时间, disk-slab用光, 此时mem-slab 和disk-slab都full,
此时为了获得一个disk-slab, 就会发生一次 evict, 驱逐掉一个disk-slab中的数据(最老的) 获得一个free-disk-slab, 然后回到2, 获得一个free-mem-slab&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这里是一种fifo的淘汰, 比较悲剧?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;img alt="" src="/imgs/fatcache-005.png" style="width: 500px;" /&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;性能测试&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我的性能测试, 先set 10亿条100字节的数据, 再来get:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
num = 1000000000 #10亿
cmd = 'mc-benchmark  -p 11211 -n %s -r %s -d 100' % (num, num)
&lt;/pre&gt;
&lt;p&gt;发现, fatcache始终能维持5w+的 写入和读取, 但是问题是, 读压力的时候, 磁盘的read-iops才不到100, 这很不合理. 具体原因没有仔细追查.&lt;/p&gt;
&lt;p&gt;因为 -n 1000000000 -r 100000000000 的话, 命中率只有1%. 很多查询通过内存就能发现key不存在, 根本不需要访问ssd.&lt;/p&gt;
&lt;p&gt;benchmark的结果(图中前半段是写入, 后半段是读取, 读取时的r/s很低, 不能解释):&lt;/p&gt;
&lt;img alt="" src="/imgs/stat_ssd_fat_1.log.png" style="width: 800px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;限制: item (key+value必须小于一个slab)&lt;/li&gt;
&lt;li&gt;disk-slab的回收是fifo, 这不好.&lt;/li&gt;
&lt;li&gt;裸写设备的方法, 虽然能更好的利用磁盘的iops, 但是我不太喜欢.&lt;/li&gt;
&lt;li&gt;fc 不会持久化, 虽然它写磁盘, 但是它重启的时候, 是默认把所有slab都标记为free.&lt;/li&gt;
&lt;li&gt;用 &lt;tt class="docutils literal"&gt;sha1&lt;/tt&gt; 做index里面的key, 也是一个不好的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="todo"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;TODO&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;问题:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;从代码看, 应该是现有twemproxy, 后有fatcache.&lt;/li&gt;
&lt;li&gt;如何处理expire, 参看 req_process_get&lt;/li&gt;
&lt;li&gt;目测get的时候一个kv, 只能放在一个mbuf里面 rsp_send_value?&lt;/li&gt;
&lt;li&gt;没有主从同步等机制.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小结:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自己管理实现存储引擎, 需要关注空间分配, 回收, 索引等, 略复杂, 用levelDB是比较好的方案. 不用关注这一层的细节.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>ssd-cache</title><link href="/ssd-cache.html" rel="alternate"></link><updated>2014-05-13T06:56:03+08:00</updated><author><name>ning</name></author><id>tag:,2014-05-13:ssd-cache.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id25"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;需求&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#why" id="id26"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;why&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id27"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;具体需求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#index" id="id28"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ssd" id="id29"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 特性&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id30"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;成本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id31"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id32"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;比较典型的ssd参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id33"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id34"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;现有系统调研&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis" id="id35"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;基于redis修改&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-vm" id="id36"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-vm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-storage" id="id37"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id38"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id39"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;单机存储引擎&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#leveldb" id="id40"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;LevelDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rocksdb-facebook" id="id41"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;RocksDB(facebook)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#berkley-db" id="id42"&gt;4.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Berkley DB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nessdb" id="id43"&gt;4.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;nessDB(国人开发)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id44"&gt;4.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id45"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;备选项目&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id46"&gt;4.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;ssdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id47"&gt;4.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;fatcache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ardb" id="id48"&gt;4.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;ardb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ledisdb" id="id49"&gt;4.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;ledisdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id18" id="id50"&gt;4.3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id19" id="id51"&gt;4.3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id20" id="id52"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;成熟分布式存储系统&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tair" id="id53"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;淘宝tair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aerospike" id="id54"&gt;4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;aerospike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#facebook-apollo" id="id55"&gt;4.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;#facebook Apollo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#facebook-mcdipper" id="id56"&gt;4.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;#facebook-McDipper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ckv" id="id57"&gt;4.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;#腾讯CKV海量分布式存储系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id21" id="id58"&gt;4.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id22" id="id59"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id23" id="id60"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id24" id="id61"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于目前的很多系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;style type="text/css"&gt;
      table {
        width: 30%
      }
&lt;/style&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id25"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;需求&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="why"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;why&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用redis内存实在太贵了, 假设要存1T数据双副本:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;内存: 1000*2 / 64 = 32台机器.&lt;/li&gt;
&lt;li&gt;2T盘机器:  2-4台&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;具体需求&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;数据存放在ssd.&lt;/li&gt;
&lt;li&gt;性能要求: 6台机器的集群10w/s, (单机2w/s)&lt;/li&gt;
&lt;li&gt;有expire功能.&lt;/li&gt;
&lt;li&gt;使用redis协议 (twemproxy, client-lib可以复用)&lt;/li&gt;
&lt;li&gt;数据类型仅支持kv, 以后可以考虑支持hash.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其它:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;事务或script支持.&lt;/li&gt;
&lt;li&gt;主从, failover&lt;/li&gt;
&lt;li&gt;集群.&lt;/li&gt;
&lt;li&gt;redis-mgr 部署支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="index"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id28"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;index&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主要涉及下面几个方面:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;ssd特性.&lt;/li&gt;
&lt;li&gt;存储引擎,  如LevelDB, RocksDB, BDB等.&lt;/li&gt;
&lt;li&gt;现有系统的调研和benchmark, 主要关注SSDB和fatcache.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文是这个调研系列的目录和结论, 相关调研:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="/coding-for-ssd.html"&gt;coding-for-ssd笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LevelDB 调研 TODO&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="/cr-ssdb.html"&gt;SSDB代码阅读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="/ssdb-benchmark.html"&gt;SSDB benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="/fatcache-cr.html"&gt;fatcache 代码阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ssd"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id29"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;ssd 特性&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id30"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;成本&lt;/a&gt;&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="11%" /&gt;
&lt;col width="18%" /&gt;
&lt;col width="56%" /&gt;
&lt;col width="15%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;--&lt;/th&gt;
&lt;th class="head"&gt;国外&lt;/th&gt;
&lt;th class="head"&gt;国内&lt;/th&gt;
&lt;th class="head"&gt;2T成本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;ssd&lt;/td&gt;
&lt;td&gt;$0.6/GB&lt;/td&gt;
&lt;td&gt;京东价格(400元/128G=3.1元/GB)&lt;/td&gt;
&lt;td&gt;6000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;hdd:&lt;/td&gt;
&lt;td&gt;$0.12/GB&lt;/td&gt;
&lt;td&gt;京东价格(400元/1T=0.4元/GB)&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;实际上, 我们买服务器的时候, 价格会更便宜些, 不过还是这个数量级.&lt;/li&gt;
&lt;li&gt;考虑到一台1U服务器价格 在3-5w, 使用2T ssd带来的成本上升: 5200/30000 = 18%左右, 并不算太贵, 加之后续电费等消耗, 可以认为使用ssd带来的成本上升小于15%&lt;/li&gt;
&lt;li&gt;当然, 我们不能用ssd来存文件之类的大/冷的数据, 这是明显的浪费.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id31"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;接口&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目前ssd主要2种接口:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;sata&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pci-e, 性能更高.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;典型产品如:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Fusion-io ioScale Gen2  (w: 4w, r:5w)&lt;/li&gt;
&lt;li&gt;Fusion-io ioMemory (w: 32w, r:19w)&lt;/li&gt;
&lt;li&gt;华为ES3000 (w: 10w,  r:15w)&lt;/li&gt;
&lt;li&gt;MemblazeQ520 (w:7w, r:3w)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sata 带宽6Gbps, pci-e 常见带宽 3.2G*8 = 24Gbps.&lt;/p&gt;
&lt;img alt="" src="/imgs/fusionio.png" style="width: 310px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id32"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;比较典型的ssd参数&lt;/a&gt;&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="27%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Product&lt;/th&gt;
&lt;th class="head"&gt;Intel SSD 320&lt;/th&gt;
&lt;th class="head"&gt;Intel SSD 530&lt;/th&gt;
&lt;th class="head"&gt;ioMemory PX600&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Components&lt;/td&gt;
&lt;td&gt;MLC&lt;/td&gt;
&lt;td&gt;MLC&lt;/td&gt;
&lt;td&gt;MLC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Launch Date&lt;/td&gt;
&lt;td&gt;2011&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Sequential Read&lt;/td&gt;
&lt;td&gt;270 MB/s&lt;/td&gt;
&lt;td&gt;540 MB/s&lt;/td&gt;
&lt;td&gt;2700 MB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Sequential Write&lt;/td&gt;
&lt;td&gt;220 MB/s&lt;/td&gt;
&lt;td&gt;490 MB/s&lt;/td&gt;
&lt;td&gt;1500MB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Random Read (8GB Span)&lt;/td&gt;
&lt;td&gt;39,500 IOPS&lt;/td&gt;
&lt;td&gt;48,000 IOPS&lt;/td&gt;
&lt;td&gt;196,000 IOPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Random Write (8GB Span)&lt;/td&gt;
&lt;td&gt;23,000 IOPS&lt;/td&gt;
&lt;td&gt;80,000 IOPS&lt;/td&gt;
&lt;td&gt;320,000 IOPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Latency - Read&lt;/td&gt;
&lt;td&gt;75 us&lt;/td&gt;
&lt;td&gt;80 us&lt;/td&gt;
&lt;td&gt;92 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Latency - Write&lt;/td&gt;
&lt;td&gt;90 us&lt;/td&gt;
&lt;td&gt;80 us&lt;/td&gt;
&lt;td&gt;15 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;interface&lt;/td&gt;
&lt;td&gt;SATA 6.0 Gb/s&lt;/td&gt;
&lt;td&gt;SATA 6.0 Gb/s&lt;/td&gt;
&lt;td&gt;PCI-Express 2.0 x8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数据来源:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Intel-SSD-320: &lt;a class="reference external" href="http://ark.intel.com/products/56569/Intel-SSD-320-Series-600GB-2_5in-SATA-3Gbs-25nm-ML"&gt;http://ark.intel.com/products/56569/Intel-SSD-320-Series-600GB-2_5in-SATA-3Gbs-25nm-ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Intel-SSD-530: &lt;a class="reference external" href="http://ark.intel.com/products/75336/Intel-SSD-530-Series-480GB-2_5in-SATA-6Gbs-20nm-MLC"&gt;http://ark.intel.com/products/75336/Intel-SSD-530-Series-480GB-2_5in-SATA-6Gbs-20nm-MLC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fusion-io: &lt;a class="reference external" href="http://www.fusionio.com/data-sheets/iomemory-px600-atomic-series/"&gt;http://www.fusionio.com/data-sheets/iomemory-px600-atomic-series/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;这里选的 Fusion-io ioMemory系列, 写可以达到32w/s, 写延迟只有15us, 很明显写操作都是先写buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;对三块Intel-SSD-530 做raid0后, 用fio进行了测试, 数据和标称数据差不多:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;random-write: 5.5w/s&lt;/li&gt;
&lt;li&gt;random-read: 7.3w/s&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id33"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;随机读性能好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;随机写性能较差&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;写放大: 写一个字节也会导致整个page的read-modify-write&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;应该尽量避免small-write&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;很多ssd会通过 &lt;tt class="docutils literal"&gt;hybrid &lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt; 来做写merge. 从而减轻写放大,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这相当于把Log-Structure的一些算法在ssd控制器这一层实现了, 从而实现较高的随机写性能.&lt;/li&gt;
&lt;li&gt;但是即便有了 &lt;tt class="docutils literal"&gt;hybrid &lt;span class="pre"&gt;log-block&lt;/span&gt; mapping&lt;/tt&gt;, 也应该尽量避免small-write(因为需要多次操作映射关系表)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ssd在大量写压力下, 性能可能恶化到8000iops.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;因为很多update, GC可能跟不上, 如果每次写操作需要做一次erase整个block, 就悲剧了.&lt;/li&gt;
&lt;li&gt;正常情况下, GC利用后台的时间, 可以完成erase工作.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;顺序读写和hdd在同一量级.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;寿命有限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssd可以通过下面这些方式调优:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;调整page/block的大小, 较小的擦除块可以得到较高的wqps.&lt;/li&gt;
&lt;li&gt;gc策略: 可以通过不同的算法优化, 这是ssd控制器FTL的核心技术.&lt;/li&gt;
&lt;li&gt;Flash Translation Layer (FTL) 上做 hybrid log-block mapping 优化随机写.&lt;/li&gt;
&lt;li&gt;使用 &lt;tt class="docutils literal"&gt;TRIM&lt;/tt&gt; 命令, 会有少量优化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细参考: &lt;a class="reference external" href="/coding-for-ssd.html"&gt;coding-for-ssd笔记&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id34"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;现有系统调研&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;针对我们的需求, 调研了一些现有的系统, 主要分三类:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;基于redis的修改如redis-vm.&lt;/li&gt;
&lt;li&gt;单机引擎如Berkley DB, LevelDB.&lt;/li&gt;
&lt;li&gt;一些和我们需求接近的现有系统, 如ssdb, fatcache等.&lt;/li&gt;
&lt;li&gt;成熟产品, 如淘宝tair, aerospike 等.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="redis"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;基于redis修改&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="redis-vm"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id36"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-vm&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://antirez.com/news/52"&gt;http://antirez.com/news/52&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.nosqlfan.com/html/1047.html"&gt;http://blog.nosqlfan.com/html/1047.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;redis在2.2-2.4曾经做过vm功能, 来将内存扩展到磁盘, 但是不久就被废弃了, 原因主要是造成性能不稳定.&lt;/p&gt;
&lt;p&gt;存在的问题:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;slow restart: 重启太慢&lt;/li&gt;
&lt;li&gt;slow saving: 保存数据太慢&lt;/li&gt;
&lt;li&gt;slow replication: 上面两条导致 replication 太慢&lt;/li&gt;
&lt;li&gt;complex code: 代码过于复杂&lt;/li&gt;
&lt;li&gt;2.4 之后就已经从redis代码中移除了.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者的观点:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;have Redis do what it does best - very quickly serve data from RAM.&lt;/li&gt;
&lt;li&gt;估计当时的测试, 使用的磁盘都是hdd, 那当然性能糟糕, 如果换成ssd应该会好些.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-storage"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id37"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-storage&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;把leveldb嵌入到redis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;完成度较高, 新增了一些rl_开头的命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rl系列命令：(同时操作redis和leveldb系列命令)
=======string数据操作======
rl_get key            (从redis或leveldb取值, 优先顺序：redis &amp;gt; leveldb)
rl_getset key         (返回同rl_get, 当leveldb有值，redis无值时，会回写到redis)
...
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;读: 先从redis读取, 如果redis没有，则到leveldb读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;写: 先写到leveldb中，写成功了，再写到redis中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;问题:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;这个项目的目的是把redis的内存扩大2-5倍, 把redis作为leveldb的cache+store. 两份storage很诡异.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;作者设计的时候, 应该是考虑到兼容redis, 客户端尽量不需要改动, 冷key会自动淘汰,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;但是实际上提供了两套命令, 客户端需要根据情况, 指定只写redis/只写leveldb还是双写. 就很麻烦.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;没有expire支持, leveldb过大后, 怎么办?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;完全没有考虑到主从的设计.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/qiye/redis-storage"&gt;https://github.com/qiye/redis-storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.guangla.com/post/2014-03-17/40061277735"&gt;http://www.guangla.com/post/2014-03-17/40061277735&lt;/a&gt;  (shenzhe)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id38"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;基于redis的改进, 主要有这么几种:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;增加新命令&lt;/li&gt;
&lt;li&gt;在key被淘汰时写磁盘&lt;/li&gt;
&lt;li&gt;key一直在内存, 把某些value放磁盘(redis-vm的实现方案)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果基于redis来实现, 存在下面一些问题:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;主从同步很可能被破坏(现有全量同步机制需要重新改写)&lt;/li&gt;
&lt;li&gt;重启时加载数据的机制.&lt;/li&gt;
&lt;li&gt;不能支持全部命令, 容易造成混淆.&lt;/li&gt;
&lt;li&gt;不能被主流所接受&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不基于redis代码来做:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;主从同步需要重做&lt;/li&gt;
&lt;li&gt;sentinel机制需要重做.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;单机存储引擎&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="leveldb"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id40"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;LevelDB&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;LevelDB是BigTable的单机存储, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LSM-Tree&lt;/span&gt;&lt;/tt&gt; 思想, 写操作都转化为顺序写.&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;KV引擎&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持SCAN(iteration)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Snappy压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;随机读写能达到 10w/s 的性能&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这里性能是小数据量下, 还不刷盘的情况&lt;/li&gt;
&lt;li&gt;实际写能到10w, 读取决于存储介质.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持Bloom Filter, 能在一定程度上优化读性能.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="rocksdb-facebook"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id41"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;RocksDB(facebook)&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;基于LevelDB改进&lt;/li&gt;
&lt;li&gt;更好的利用多核等&lt;/li&gt;
&lt;li&gt;代码包比LevelDB复杂.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="berkley-db"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id42"&gt;4.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Berkley DB&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;历史悠久的嵌入式数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持事务, 细粒度锁.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;支持多种算法&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;B+树&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Heap(更节约空间)&lt;/li&gt;
&lt;li&gt;Recno&lt;/li&gt;
&lt;li&gt;Queue(定长record)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;对一些老的UNIX数据库, 如dbm, ndbm接口兼容.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="http://docs.oracle.com/cd/E17076_02/html/programmer_reference/am_conf.html"&gt;http://docs.oracle.com/cd/E17076_02/html/programmer_reference/am_conf.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nessdb"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id43"&gt;4.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;nessDB(国人开发)&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;支持事务 &lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;自己实现存储引擎, 不是基于LevelDB&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;3.0 提供 Buffered-Tree index (Toku的FT-Tree)&lt;/li&gt;
&lt;li&gt;作者是TokuDB的贡献者.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;2011-2014持续开发, 目测代码质量很高.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;本身是一个库.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;还提供一个服务端，支持Redis的 PING, SET, MSET, GET, MGET, DEL, EXISTS, INFO, SHUTDOWN 命令，&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;现在已经专注于实现引擎, 不提供server功能了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;整个引擎基于LSM-Tree思想开发，对随机写非常友好。为提高随机读，nessDB使用了Level LRU和Bloom Filter策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;引擎是自己开发的, 还需要时间验证.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id44"&gt;4.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;较老的存储引擎都基于B+树或Hash实现, 写性能差.&lt;/li&gt;
&lt;li&gt;较新的存储引擎基于LSM-Tree, Log Structed Hash, FT-Tree之类新的数据结构, 针对写进行优化, 写性能能得到很大改善&lt;/li&gt;
&lt;li&gt;读操作主要取决于底层磁盘能提供的 &lt;strong&gt;随机读IOPS&lt;/strong&gt; , 通过Bloom Filter等能有一定的优化.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id45"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;备选项目&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id46"&gt;4.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;ssdb&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;ssdb 是一个基于leveldb的kv存储, 提供兼容redis的协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持String, Hash, Zset, Queue几种数据结构.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持Expire和主从同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ssd上写性能稳定在3.8wqps, 不会随着写数据增多而变差, 和hdd差不多,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;读性能稳定在5000qps, 不能充分发挥硬件性能, 这主要是由于读操作是单线程顺序执行.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;主要问题:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;读性能问题(多线程可达到15000)&lt;/li&gt;
&lt;li&gt;所有expire的key记录在内存&lt;/li&gt;
&lt;li&gt;兼容问题(expire/ttl/del都有问题, scan类设计上和redis不同)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细参考:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="/cr-ssdb.html"&gt;SSDB代码阅读笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="/ssdb-benchmark.html"&gt;SSDB benchmark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id47"&gt;4.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;fatcache&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Memcache on SSD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Log-Structure Hash结构.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;不能持久化(元数据不落盘, 重启后数据丢失)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;性能不错, Initial performance results with fatcache 100K sets/sec, 40K gets/sec on a single SSD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;读不命中时效率高(所有key记录在内存中)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;写裸盘. 需要root.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;主要问题:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;不持久化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;key都放在内存, 如果10亿条的话, 每条key 32字节, 就需要32G. 此时存的数据(100字节/kv) 大约100G.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;所以这适合value较大的情况, 比如1K, 这样32G内存就能管理1T数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细参考: &lt;a class="reference external" href="/fatcache-cr.html"&gt;fatcache代码阅读笔记&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ardb"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id48"&gt;4.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;ardb&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/yinqiwen/ardb"&gt;https://github.com/yinqiwen/ardb&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Full redis-protocol compatible&lt;/li&gt;
&lt;li&gt;Most redis commands supported, and a few new commands&lt;/li&gt;
&lt;li&gt;Replication compatible with Redis 2.6/2.8&lt;/li&gt;
&lt;li&gt;Auto failover support by redis-sentinel&lt;/li&gt;
&lt;li&gt;存储引擎支持  LevelDB/LMDB/RocksDB&lt;/li&gt;
&lt;li&gt;空间索引.&lt;/li&gt;
&lt;li&gt;代码量5w, 很难想象是一个人的作品. (HUST)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看上去很不错, c++实现.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ledisdb"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id49"&gt;4.3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;ledisdb&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;go 实现(金山 siddontang)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/siddontang/ledisdb"&gt;https://github.com/siddontang/ledisdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;支持多种引擎: LevelDB, goleveldb, LMDB, RocksDB, BoltDB.&lt;/li&gt;
&lt;li&gt;支持expiration&lt;/li&gt;
&lt;li&gt;比GoRedis完善&lt;/li&gt;
&lt;li&gt;写的很细心&lt;/li&gt;
&lt;li&gt;lua&lt;/li&gt;
&lt;li&gt;redis 协议 +rest协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://siddontang.com/2014/05/10/ledisdb-introduction/"&gt;http://siddontang.com/2014/05/10/ledisdb-introduction/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://siddontang.com/2014/05/30/ledisdb-design-1/"&gt;http://siddontang.com/2014/05/30/ledisdb-design-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://siddontang.com/2014/06/14/ledisdb-design-2/"&gt;http://siddontang.com/2014/06/14/ledisdb-design-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id18"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id50"&gt;4.3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;memcachedb&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gitorious.org/mdb/memcachedb/source/9f2e5415e4d9017889caf61c100a9b8652825319"&gt;https://gitorious.org/mdb/memcachedb/source/9f2e5415e4d9017889caf61c100a9b8652825319&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;redis-leveldb&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不是基于redis的代码,&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/KDr2/redis-leveldb"&gt;https://github.com/KDr2/redis-leveldb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;redis-protocol compatible&lt;/li&gt;
&lt;li&gt;libev, cpp实现.&lt;/li&gt;
&lt;li&gt;2000行代码, 简单实现的玩具, 代码中各种printf直接输出到终端. 代码质量差&lt;/li&gt;
&lt;li&gt;没有expire, 主从同步,&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;seqdb&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;提供sql接口的kv.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;GoRedis&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;go实现, (陌陌)&lt;/li&gt;
&lt;li&gt;存储引擎使用RocksDB, redis接口.&lt;/li&gt;
&lt;li&gt;不支持expire&lt;/li&gt;
&lt;li&gt;slaveof-proxy为两个redis建立自定义的主从同步，包含限速、断线重试等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;rdisk 是一个hackathon项目, 提供兼容redis的协议.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;libuv做服务&lt;/li&gt;
&lt;li&gt;rangel 解析&lt;/li&gt;
&lt;li&gt;tokyocabinet 作为存储引擎(作为.so嵌入)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/Moodstocks/redisk"&gt;https://github.com/Moodstocks/redisk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;是一个不错的开始&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;lycadb&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;An experiment with InnoDB storage for a Redis-like key/value store&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;redis-land-go&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xjdrew/redis-land-go"&gt;https://github.com/xjdrew/redis-land-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;旁路监听，把redis数据存盘到leveldb&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id51"&gt;4.3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;有很多尝试做兼容redis的磁盘存储的项目,&lt;/li&gt;
&lt;li&gt;在设计实现上都存在或多或少的问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;成熟分布式存储系统&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="tair"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id53"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;淘宝tair&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;淘宝开发的分布式 key/value 存储系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;模块&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;config-server (master+slave)&lt;/li&gt;
&lt;li&gt;data server (存储节点)&lt;/li&gt;
&lt;li&gt;客户端保存路由表, 有local cache&lt;/li&gt;
&lt;li&gt;一致性hash+数据迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;存储引擎&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;mdb: 缓存, 支持kv,&lt;/li&gt;
&lt;li&gt;rdb: redis内存结构, kv, list, set, zset.&lt;/li&gt;
&lt;li&gt;ldb: 基于leveldb.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;需要专用的 client lib.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持多副本, 多版本.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;规模(2011):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;共有20多个集群，400多台的服务器，其中300多台是cache的，每台提供22G的内存。其他的是持久化的Tair集群。&lt;/li&gt;
&lt;li&gt;存放了数百亿条记录，每秒百万级别的请求数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="http://code.taobao.org/p/tair/wiki/intro/"&gt;http://code.taobao.org/p/tair/wiki/intro/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="aerospike"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id54"&gt;4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;aerospike&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;商业产品, 开源.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;三层:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;client 感知数据存在哪里&lt;/li&gt;
&lt;li&gt;Distribution Layer&lt;/li&gt;
&lt;li&gt;Data Storage Layer: 单机引擎.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;API形式: 不是简单的key/value, 每个key需要指定 (namespace, set, key), 应该是为了控制锁粒度.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Indexes are always stored in RAM.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;数据类型: map, list, integer, string, blob.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可配 expire&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持lua.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持Secondary indexes, 不是简单kv, 更像mongo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持Hot Analytics (distributed aggregations or indexed map-reduce)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/aerospike/aerospike-server"&gt;https://github.com/aerospike/aerospike-server&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="facebook-apollo"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id55"&gt;4.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;#facebook Apollo&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.infoq.com/news/2014/06/facebook-apollo"&gt;http://www.infoq.com/news/2014/06/facebook-apollo&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Paxos-like NoSQL database&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;低延迟, 特别是Flash and in-memory&lt;/li&gt;
&lt;li&gt;不是简单kv, 支持数据结构:  maps, queues, trees&lt;/li&gt;
&lt;li&gt;分布式, 有shard概念, 每个shard内基于RocksDB.&lt;/li&gt;
&lt;li&gt;Apollo isn't currently being used in production at Facebook&lt;/li&gt;
&lt;li&gt;The company is also looking at using Apollo as a reliable queuing system&lt;/li&gt;
&lt;li&gt;是分布式的ssdb&lt;/li&gt;
&lt;li&gt;还没开源.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="facebook-mcdipper"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id56"&gt;4.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;#facebook-McDipper&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.facebook.com/notes/facebook-engineering/mcdipper-a-key-value-cache-for-flash-storage/10151347090423920"&gt;https://www.facebook.com/notes/facebook-engineering/mcdipper-a-key-value-cache-for-flash-storage/10151347090423920&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Compared with memory, flash provides up to 20 times the capacity per server and still supports tens of thousands of operations per second,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;大约12年5月上线.&lt;/li&gt;
&lt;li&gt;cache替换策略: LRU或者FIFO&lt;/li&gt;
&lt;li&gt;you can enable bloom filters to avoid unnecessary reads&lt;/li&gt;
&lt;li&gt;主要用于图片服务器的缓存(cdn上) 后端是HayStack.&lt;/li&gt;
&lt;li&gt;We serve over 150 Gb/s from McDipper forward caches in our CDN.&lt;/li&gt;
&lt;li&gt;是一个cdn用的cache存储. memcache协议.&lt;/li&gt;
&lt;li&gt;不开源.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ckv"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id57"&gt;4.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;#腾讯CKV海量分布式存储系统&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;(闭源, 这里参考一个ppt)&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.csdn.net/article/2014-03-11/2818723"&gt;http://www.csdn.net/article/2014-03-11/2818723&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高性能、低延时、持久化、分布式KV存储服务, 日请求数: 超过万亿次 (那得看多少套集群)&lt;/p&gt;
&lt;p&gt;与Memcached和Redis等开源NoSQL相比，CKV具有以下优点.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;内存+SSD, 99%命中率(取决于应用)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可以扩展到1PB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;单表 千万qps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;单台Cache服务器千兆网络环境支持50万/秒的访问，万兆网络环境支持超过100万/秒的访问 &amp;lt;redis也10个实例, 也可以做到&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;双机热备，主备切换对业务透明. redis一样.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;扩容: 需要停写&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;扩容过程如下：Master将禁止shard2数据写访问命令发送给Access&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;规模: 近万台服务器&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;万台, 每天万亿请求, 那就是说1亿/台, 每台只相当于1000qps.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id58"&gt;4.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这里的几个系统, 都是类似GFS的架构, config-server + data server + 智能client&lt;/li&gt;
&lt;li&gt;支持动态数据迁移和路由更新.&lt;/li&gt;
&lt;li&gt;它们都有各自的接口, 相对来说比较复杂.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id59"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;其它思路&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;HBase/Cassendra/MySQL on ssd?&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;可以利用现有hbase等系统良好的扩展性, 性能上也能有所保证&lt;/li&gt;
&lt;li&gt;接口不兼容.&lt;/li&gt;
&lt;li&gt;过于复杂.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id60"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;为了避免随机写, 现在很多存储引擎都是Write-optimized的, 基于LSM的思想来开发, 比如:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;fatcache/Riak: Log-Structure Hash table&lt;/li&gt;
&lt;li&gt;RethinkDB: Log-Structure B-tree&lt;/li&gt;
&lt;li&gt;LevelDB, Cassendra, HBase: Log-Structure merge tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;LevelDB 平均每次读大约需要1.3-1.5次IO, Log-Structure Hash 只需要1次, 但是不能scan.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ssdb/ardb/nessDB/ledisdb 都是国人做的, 很赞, 值得持续关注.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可以否决基于redis做的改造.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;基于LevelDB或者RocksDB封装提供redis协议比较简单, 难点主要是expire/replication/failover的实现.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id61"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于目前的很多系统&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;无论对redis改造或者是重新实现, 在数据结构/expire/主从同步上, 都延用了redis的做法, 比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;支持富数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;expire信息放在内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;主从断掉全量同步.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;依然有rdb, 整个库占了1T磁盘, rdb出来也占1T =&amp;gt; 这些设计可能没考虑1T这个数据量级, 只考虑100G这个量级.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如ardb依然使用rdb做同步.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;甚至有的还会把磁盘操作计入aof, 再加上aof_rewrite,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于数据规模变大(60G=&amp;gt;600G的级别) 这些设计就存在问题.&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="2%" /&gt;
&lt;col width="11%" /&gt;
&lt;col width="4%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="25%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;代码&lt;/th&gt;
&lt;th class="head"&gt;特点&lt;/th&gt;
&lt;th class="head"&gt;expire&lt;/th&gt;
&lt;th class="head"&gt;repl&lt;/th&gt;
&lt;th class="head"&gt;其它&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;redis-storage&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;redis+特定命令&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;专注于使内存成为磁盘的cache&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;ssdb&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;单独key存储&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;ardb&lt;/td&gt;
&lt;td&gt;5w&lt;/td&gt;
&lt;td&gt;cpp, 复杂, 地理索引&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;存储:&lt;/li&gt;
&lt;li&gt;同步: ?&lt;/li&gt;
&lt;li&gt;切换: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;td&gt;兼容性好, 沿用redis, 依然支持rdb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;ledisdb(go)
金山&lt;/td&gt;
&lt;td&gt;2w&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;单独key存储, 定期elim&lt;/td&gt;
&lt;td&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;存储: 自定义binlog,fid+offset&lt;/li&gt;
&lt;li&gt;同步: 从拉,全量+增量&lt;/li&gt;
&lt;li&gt;切换: 全量同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;GoRedis&lt;/td&gt;
&lt;td&gt;2w&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>tmux</title><link href="/tmux.html" rel="alternate"></link><updated>2014-05-08T09:52:32+08:00</updated><author><name>ning</name></author><id>tag:,2014-05-08:tmux.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#why" id="id9"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;why&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id10"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;使用&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#session" id="id12"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;session&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#window" id="id13"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pane" id="id14"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;pane&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#copy-paste" id="id15"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;copy-paste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id16"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;交换两个window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kill-window" id="id17"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;kill-window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id18"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;帮助&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id19"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id20"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;工具&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tmuxp" id="id21"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;tmuxp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#workspace" id="id22"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;workspace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id23"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id24"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="why"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;why&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;配置更可读, 比如状态栏:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#screen
hardstatus alwayslastline '%{gk}[ %{G}%H %{g}][%= %{wk}%?%-Lw%?%{=b kR}(%{W}%n*%f%t%?(%u)%?%{=b kR})%{= kw}%?%+Lw%?%?%= %{y}][%{G} %l%{y}] %{y}[%{G} %m/%d %c %{y}]%{W}'

#tmux
set -g status-left ' #[fg=green,bold]#H#[default]'
set -g status-right '#[fg=yellow,bold]#(cut -d &amp;quot; &amp;quot; -f 1-4 /proc/loadavg)#[default] #[fg=cyan,bold]%Y-%m-%d %H:%M:%S#[default] '

screen的配置完全看不懂 颜色在哪, 看上去更像魔法.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可编程&lt;/p&gt;
&lt;p&gt;nearly all commands can be invoked from the command line,&lt;/p&gt;
&lt;p&gt;screen 也可以的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Window Splitting&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;和screen一样, 也支持 前缀.
比如 tmux attach 可以简写为 tmux att&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;列出所有window, 在window很多的时候 有用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Ctrl-b w (List all windows / window numbers)
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;动态修改配置(有些属性不能及时生效, 要杀掉所有session):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
By default tmux reads ~/.tmux.conf only if it was not already running. To have tmux load a configuration file afterwards, execute:
tmux source-file &amp;lt;path&amp;gt;
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;很多外部工具, 如tmuxp&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;安装&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因为我的ubuntu tmux是1.1..  ubuntu 也太老,  只能自己编译了..  需要libevent 2.x and ncurses .&lt;/p&gt;
&lt;p&gt;用这个脚本: &lt;a class="reference external" href="https://gist.github.com/ryin/3106801"&gt;https://gist.github.com/ryin/3106801&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;使用&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="session"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;session&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
#creates a new tmux session named session_name
tmux new -s session_name

#attaches to an existing tmux session named session_name
tmux attach -t session_name

#switches to an existing session named session_name
tmux switch -t session_name

#lists existing tmux sessions
tmux list-sessions

#detach the currently attached session
tmux detach (prefix + d)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="window"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;window&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
create a new window
tmux new-window (prefix + c)

move to the window based on index
tmux select-window -t :0-9 (prefix + 0-9)

rename the current window
tmux rename-window (prefix + ,)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pane"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;pane&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
tmux split-window (prefix + &amp;quot;)
splits the window into two vertical panes

tmux split-window -h (prefix + %)
splits the window into two horizontal panes

tmux swap-pane -[UDLR] (prefix + { or })
swaps pane with another in the specified direction

tmux select-pane -[UDLR]
selects the next pane in the specified direction

tmux select-pane -t :.+
selects the next pane in numerical order
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="copy-paste"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;copy-paste&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;空格开始选择, Enter确认copy
1. enter copy mode using &lt;tt class="docutils literal"&gt;Control+b [&lt;/tt&gt;
2. navigate to beginning of text, you want to select and hit &lt;tt class="docutils literal"&gt;Space&lt;/tt&gt;
3. move around using arrow keys to select region
4. when you reach end of region simply hit &lt;tt class="docutils literal"&gt;Enter&lt;/tt&gt; to copy the region
5. now &lt;tt class="docutils literal"&gt;Control+b ]&lt;/tt&gt; will paste the selection&lt;/p&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# Setup 'v' to begin selection as in Vim
bind-key -t vi-copy v begin-selection
bind-key -t vi-copy y copy-selection
#bind-key -t vi-copy y copy-pipe &amp;quot;reattach-to-user-namespace pbcopy&amp;quot;

# Update default binding of `Enter` to also use copy-pipe
unbind -t vi-copy Enter
bind-key -t vi-copy Enter copy-pipe &amp;quot;reattach-to-user-namespace pbcopy&amp;quot;

bind-key p paste-buffer
&lt;/pre&gt;
&lt;p&gt;这样就可以 &lt;tt class="docutils literal"&gt;^a[&lt;/tt&gt; 进入回滚模式, &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; 开始选择, &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; 拷贝, &lt;tt class="docutils literal"&gt;q&lt;/tt&gt; 退出,&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;^a p&lt;/tt&gt; 粘贴.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;交换两个window&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当前window和1号window交换:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
swap-window -t 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="kill-window"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;kill-window&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
tmux kill-window -t ndb:7
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;帮助&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;列出命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning/blog_and_notes$ tmux lscm
attach-session [-d] [-t target-session]
bind-key [-cnr] [-t key-table] key command [arguments]
break-pane [-t target-pane] [-d]
choose-client [-t target-window] [template]
choose-session [-t target-window] [template]
choose-window [-t target-window] [template]
&lt;/pre&gt;
&lt;p&gt;列出绑定:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
^A?
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;用^A ^A 来在最常用的两个window间切换:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#select last window
bind-key C-a last-window
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;.bashrc/.profile is not loaded on new tmux session&lt;/p&gt;
&lt;p&gt;tmux加载 &lt;tt class="docutils literal"&gt;.bash_profile&lt;/tt&gt; 需要在 &lt;tt class="docutils literal"&gt;.bash_profile&lt;/tt&gt; 中加入:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
. ~/.bashrc
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;new 和attatch 的标识不一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tmux new -s
tmux attach -t
&lt;/pre&gt;
&lt;p&gt;好在有这个alias:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
alias t=&amp;quot;if tmux has-session -t $USER; then tmux attach -t $USER; else tmux new -s $USER; fi&amp;quot;
&lt;/pre&gt;
&lt;p&gt;不过这个不能指定名字, 用函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
t(){
    if [ $# -eq 0 ]
      then
        tmux ls
      else
        if tmux has-session -t $&amp;#64;; then tmux attach -t $&amp;#64;; else tmux new -s $&amp;#64;; fi
    fi

}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ctrl-left&lt;/span&gt;&lt;/tt&gt; 不能用, 特别是在vim里面, 需要配置一下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tmux.conf:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set-window-option -g xterm-keys on
&lt;/pre&gt;
&lt;p&gt;.vimrc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;for tmux
if &amp;amp;term =~ '^screen'
    &amp;quot; tmux will send xterm-style keys when xterm-keys is on
    execute &amp;quot;set &amp;lt;xUp&amp;gt;=\e[1;*A&amp;quot;
    execute &amp;quot;set &amp;lt;xDown&amp;gt;=\e[1;*B&amp;quot;
    execute &amp;quot;set &amp;lt;xRight&amp;gt;=\e[1;*C&amp;quot;
    execute &amp;quot;set &amp;lt;xLeft&amp;gt;=\e[1;*D&amp;quot;
endif
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;双层嵌套退出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tmux detach  -s tmp
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol class="arabic" start="5"&gt;
&lt;li&gt;&lt;p class="first"&gt;vim里面 &lt;tt class="docutils literal"&gt;shift+tab&lt;/tt&gt; 不能用, 至今无解.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;tagbar等乱掉:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://plus.google.com/u/0/+VysakhSreenivasan/posts/4heRzoxbM72"&gt;https://plus.google.com/u/0/+VysakhSreenivasan/posts/4heRzoxbM72&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在tmux.conf里面加上:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set-window-option -g utf8 on
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;工具&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="tmuxp"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;tmuxp&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pip install tmuxp&lt;/p&gt;
&lt;p&gt;保存会话(我试用有问题, ):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
usage: tmuxp freeze [-h] [-L socket-name] [-S socket-path]
                session_name [session_name ...]

ning&amp;#64;ning-laptop ~/test$ tmuxp load a.yaml
(E) [10:05:09] tmuxp.cli cli.main():952 [u'tmux: unknown option -- V', u'usage: tmux [-28lquv] [-c shell-command] [-f file] [-L socket-name]', u'            [-S socket-path] [command [flags]]']
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="workspace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;workspace&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;修改了我的workspace脚本, 老的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;task
def redissrc():
    cmd('''
gnome-terminal --geometry=120x40
--tab --working-directory ~/idning/blog_and_notes
--tab --working-directory ~/idning/blog_and_notes
--tab --working-directory ~/idning-github/redis/src
--tab --working-directory ~/idning-github/twemproxy/src
--tab --working-directory ~/idning-github/twemproxy/src
''')
&lt;/pre&gt;
&lt;p&gt;新的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;task
def redismgr():
    startcmd = '''
        tmux new -d      -s redismgr -n src  -c ~/idning-github/redis-mgr/
        tmux new-window  -t redismgr -n src  -c ~/idning-github/redis-mgr/
        tmux new-window  -t redismgr -n src  -c ~/idning-github/redis-mgr/
        tmux new-window  -t redismgr -n note -c ~/idning/blog_and_notes/
        tmux new-window  -t redismgr -n note -c ~/idning/blog_and_notes/
        '''

    if not _tmux_exists('redismgr'):
        cmd2(startcmd)
    cmd('tmux attach -t redismgr')
&lt;/pre&gt;
&lt;p&gt;类似的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;task
def work():
    cmd('''
gnome-terminal --geometry=120x40  --name=abc
--tab --working-directory /home/ning/mywork/work-log
--tab --working-directory /home/ning/mywork/work-log
--tab --working-directory /home/ning/mywork/codebase-git/
--tab --working-directory /home/ning/mywork/codebase
''')

    cmd('xdotool key alt+1')
    cmd('xdotool type &amp;quot;vim M/201402.rst&amp;quot;')
    cmd('xdotool key  Return F8')
    #cmd('xdotool key  alt+Tab')
&lt;/pre&gt;
&lt;p&gt;换成了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;task
def work():
    startcmd = '''
        tmux new -d      -s work -n worklog     -c /home/ning/mywork/work-log/
        tmux new-window  -t work -n worklog     -c /home/ning/mywork/work-log/
        tmux new-window  -t work -n git         -c /home/ning/mywork/codebase-git/
        tmux new-window  -t work -n code        -c /home/ning/mywork/codebase/
        '''

    if not _tmux_exists('work'):
        cmd2(startcmd)

    cmd('tmux send-keys -t work:0 &amp;quot;vi M/201405.rst&amp;quot; Enter')
    cmd('tmux select-window -t work:0')
    cmd('tmux attach -t work')
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;比screen好(可定制性强)&lt;/li&gt;
&lt;li&gt;自己写脚本管理, 比用tmuxp这样的工具好&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://wiki.gentoo.org/wiki/Tmux"&gt;http://wiki.gentoo.org/wiki/Tmux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/tmux"&gt;https://wiki.archlinux.org/index.php/tmux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aziz/dotfiles/blob/master/tmux.conf"&gt;https://github.com/aziz/dotfiles/blob/master/tmux.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/kwbock/5161135"&gt;https://gist.github.com/kwbock/5161135&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/roylez/dotfiles/blob/master/.tmux.conf"&gt;https://github.com/roylez/dotfiles/blob/master/.tmux.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy-cfg-reload</title><link href="/twemproxy-cfg-reload.html" rel="alternate"></link><updated>2014-04-28T16:46:45+08:00</updated><author><name>ning</name></author><id>tag:,2014-04-28:twemproxy-cfg-reload.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nginx" id="id9"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx 怎么做的&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id10"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;配置修改&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id11"&gt;1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id12"&gt;1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;细节&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id13"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;热升级二进制&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id14"&gt;1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id15"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;关键点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id16"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;应该做到怎样&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;配置热加载:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
case SIGUSR2:
&lt;/pre&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;nginx 怎么做的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;nginx 有两种情况:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;配置修改&lt;/li&gt;
&lt;li&gt;热升级二进制&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;配置修改&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;难点在于:&lt;/p&gt;
&lt;p&gt;因为不能由各个子进程分别做监听, 只能父进程监听后, 确定监听sokcet列表, 然后fork出子进程, 由子进程继承监听socket.&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id11"&gt;1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;启动后:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------+
|               0               |
+-------------------------------+
  |       |
+---+   +---+
|   |   |   |
| 1 |   | 2 |
|   |   |   |
+---+   +---+
&lt;/pre&gt;
&lt;p&gt;向父进程0发信号, 派生出新的子进程:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------+
|               0               |
+-------------------------------+
  |       |         a|       |
+---+   +---+      +---+   +---+
|   |   |   |      |   |   |   |
| 1 |   | 2 |      | 3 |   | 4 |
|   |   |   |      |   |   |   |
+---+   +---+      +---+   +---+
&lt;/pre&gt;
&lt;p&gt;父进程收到信号后, 解析新的配置, 得到新的需要监听的列表, 以及每个监听socket对应的配置, 并派生新worker,
新worker启动后, 向老worker 发送优雅关闭的信号即可, 最后达到这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------+
|               0               |
+-------------------------------+
                    a|       |
                   +---+   +---+
                   |   |   |   |
                   | 3 |   | 4 |
                   |   |   |   |
                   +---+   +---+
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id12"&gt;1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;细节&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;考虑父进程收到信号后, 派生新worker的过程. 假设&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;旧配置监听8000, 8001, 8002几个port,&lt;/li&gt;
&lt;li&gt;新配置监听8000, 8001, 8003.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么父进程解析完新的配置文件后, 会对比监听列表, 决定关闭8002, 新开8003, 保留8000, 8001, 然后把这三个fd开着, fork出新worker.&lt;/p&gt;
&lt;p&gt;新worker 直接使用新的配置结构即可.&lt;/p&gt;
&lt;p&gt;这里父进程可以直接修改自己的老配置为新配置(不会影响到 老的worker自己的那一份老配置)&lt;/p&gt;
&lt;p&gt;对于twemporxy这样单进程模型, 就不能这样做, 如果在运行时修改自己的配置, 一个请求很可能跨两种不同的配置. 这就容易出问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;热升级二进制&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt;1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------+
|               0               |
+-------------------------------+
  |       |
+---+   +---+
|   |   |   |
| 1 |   | 2 |
|   |   |   |
+---+   +---+
&lt;/pre&gt;
&lt;p&gt;发信号:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+-------------------------------+
|               0               |
+-------------------------------+
  |       |                 |
+---+   +---+    +----------------------+
|   |   |   |    |          3           |
| 1 |   | 2 |    +----------------------+
|   |   |   |          |       |
+---+   +---+        +---+   +---+
                     |   |   |   |
                     | 4 |   | 5 |
                     |   |   |   |
                     +---+   +---+
&lt;/pre&gt;
&lt;p&gt;发信号后0派生出一个新的master 3, 这个过程会把所有老的fd传给3, 由3来决定把哪些fd关掉. 新开哪些fd, 之后3会派生自己的worker.&lt;/p&gt;
&lt;p&gt;0和3之间传递fd是通过环境变量来做的, 0会向环境变量里面写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fds=3:8:72
&lt;/pre&gt;
&lt;p&gt;这样的, 表示这三个listen fd, 子进程拿到这三个fd, 解析自己的配置, 看需要监听哪些端口, 和这些fd对比(这些fd可以通过getsockaddr获取所监听的端口)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;关键点&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;传递fd:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;像nginx,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;子进程派生时, 保留父进程fd, 根据情况 关闭 开启新的listen fd.&lt;/li&gt;
&lt;li&gt;但是nginx是master和多worker的进程模型.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;用sendmsg 把fd发送过去.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;库: &lt;a class="reference external" href="http://www.normalesup.org/~george/comp/libancillary/"&gt;http://www.normalesup.org/~george/comp/libancillary/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;应该做到怎样&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;增加pool&lt;/li&gt;
&lt;li&gt;pool属性变化.&lt;/li&gt;
&lt;li&gt;减少pool.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;思路1: 改造tw为master-worker模式.&lt;/li&gt;
&lt;li&gt;思路2: 派生新进程, 通过环境变量来传递fd.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;按照思路2, 实现: &lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/257"&gt;https://github.com/twitter/twemproxy/pull/257&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>icomet-cr</title><link href="/icomet-cr.html" rel="alternate"></link><updated>2014-04-23T16:18:23+08:00</updated><author><name>ning</name></author><id>tag:,2014-04-23:icomet-cr.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;代码量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#utils" id="id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;utils&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#config" id="id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#log" id="id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#comet" id="id10"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;comet逻辑&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#comet-server-cpp-main" id="id11"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;comet-server.cpp main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#server-cpp-server-h" id="id12"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;server.cpp server.h&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pub" id="id13"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#sub" id="id14"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;sub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#channel-cpp-pub" id="id15"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;channel.cpp (pub端)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#subscriber-cpp-subscriber-h" id="id16"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;subscriber.cpp subscriber.h&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#k" id="id18"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1000K 连接的测试.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id19"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;icomet是ideawu的作品, 基于libevent 的evhttp框架做的comet服务.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/ideawu/icomet"&gt;https://github.com/ideawu/icomet&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;代码量&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test/icomet/src$ find . -name '*.cpp' | xargs cat | wc -l
2116
ning&amp;#64;ning-laptop:~/test/icomet/src$ find . -name '*.h' | xargs cat | wc -l
982
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="utils"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;utils&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="config"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;config&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;支持名字空间的config&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;支持保存到文件(dump)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;注释也会读入, 并记录行号, dump的时候可以保留注释, 这不错.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;是否支持默认值和覆盖?&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不支持.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;数组支持, 需要解析的时候特别解析:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;allow xx&lt;/li&gt;
&lt;li&gt;allow xxx&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注释里面说是是c的cfg这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct config *cfg, *c;

cfg = cfg_load_file(&amp;quot;cfg_test.conf&amp;quot;);
if(!cfg){
    return 0;
}
printf(&amp;quot;proxy.php.host = %s\n&amp;quot;, cfg_getstr(cfg, &amp;quot;proxy.php.host&amp;quot;));
printf(&amp;quot;proxy.php.port = %d\n&amp;quot;, cfg_getnum(cfg, &amp;quot;proxy.php.port&amp;quot;));
&lt;/pre&gt;
&lt;p&gt;实际上, 格式较怪异:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# 有效行以 \t* 开头
proxy :
    php =
        host = 127.0.0.1
        port = 8088
    py :
        host = 127.0.0.1
        port = 8080
&lt;/pre&gt;
&lt;p&gt;实际用起来还是有点费劲:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
    Config *cc = (Config *)conf-&amp;gt;get(&amp;quot;admin&amp;quot;);
    if(cc != NULL){
        std::vector&amp;lt;Config *&amp;gt; *children = &amp;amp;cc-&amp;gt;children;
        std::vector&amp;lt;Config *&amp;gt;::iterator it;
        for(it = children-&amp;gt;begin(); it != children-&amp;gt;end(); it++){
            if((*it)-&amp;gt;key != &amp;quot;allow&amp;quot;){
                continue;
            }
            const char *ip = (*it)-&amp;gt;str();
            log_info(&amp;quot;    allow %s&amp;quot;, ip);
            ip_filter-&amp;gt;add_allow(ip);
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="log"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;log&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;和自己习惯不一样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static const int LEVEL_NONE     = (-1);
static const int LEVEL_MIN      = 0;
static const int LEVEL_FATAL    = 0;
static const int LEVEL_ERROR    = 1;
static const int LEVEL_WARN     = 2;
static const int LEVEL_INFO     = 3;
static const int LEVEL_DEBUG    = 4;
static const int LEVEL_TRACE    = 5;
static const int LEVEL_MAX      = 5;
&lt;/pre&gt;
&lt;p&gt;支持按照文件大小切日志-能按小时切最好&lt;/p&gt;
&lt;p&gt;可以设置写的时候加锁:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if(this-&amp;gt;mutex){
    pthread_mutex_lock(this-&amp;gt;mutex);
}
fwrite(buf, len, 1, this-&amp;gt;fp);
fflush(this-&amp;gt;fp);

stats.w_curr += len;
stats.w_total += len;
if(rotate_size &amp;gt; 0 &amp;amp;&amp;amp; stats.w_curr &amp;gt; rotate_size){
    this-&amp;gt;rotate();
}
if(this-&amp;gt;mutex){
    pthread_mutex_unlock(this-&amp;gt;mutex);
}
&lt;/pre&gt;
&lt;p&gt;因为 这里用的是 &lt;tt class="docutils literal"&gt;FILE *&lt;/tt&gt;, 不能直接append.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;daemon.h
file.h
ip_filter.h 黑白名单,
list.h 链表 c++还需要这个么?:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
template &amp;lt;class T&amp;gt;
class LinkedList{
&lt;/pre&gt;
&lt;p&gt;strings.h 提供trim(), hexmem() parse_ip_port() 函数
objpool.h 因为用范型, 所以很有用的对象池, 可惜c用不了, icomet里面没用.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="comet"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;comet逻辑&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="comet-server-cpp-main"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;comet-server.cpp main()&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
Server *serv = NULL;
void pub_handler(struct evhttp_request *req, void *arg){
    CHECK_AUTH();
    serv-&amp;gt;pub(req, true);
}

void timer_cb(evutil_socket_t sig, short events, void *user_data){ //每秒一次.
    rand();
    serv-&amp;gt;check_timeout();
}

int main(int argc, char **argv){
    //读取配置
    serv = new Server();
    // /pub?cname=abc&amp;amp;content=hi
    evhttp_set_cb(admin_http, &amp;quot;/pub&amp;quot;, pub_handler, NULL);

    // /sub?cname=abc&amp;amp;cb=jsonp&amp;amp;token=&amp;amp;seq=123&amp;amp;noop=123
    evhttp_set_cb(front_http, &amp;quot;/sub&amp;quot;, poll_handler, NULL);

}
&lt;/pre&gt;
&lt;p&gt;为啥把pub 放在admin_http上&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="server-cpp-server-h"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;server.cpp server.h&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;used_channels 所有已用channel链表
cname_channels 每个channel有一个名字, 用map存name-&amp;gt;channel的关系.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Channel* Server::new_channel(const std::string &amp;amp;cname){
    if(used_channels.size &amp;gt;= ServerConfig::max_channels){
        return NULL;
    }
    log_debug(&amp;quot;new channel: %s&amp;quot;, cname.c_str());

    Channel *channel = new Channel();
    channel-&amp;gt;serv = this;
    channel-&amp;gt;name = cname;
    channel-&amp;gt;create_token();

    add_presence(PresenceOnline, channel-&amp;gt;name);

    used_channels.push_back(channel);
    cname_channels[channel-&amp;gt;name] = channel;

    return channel;
}
&lt;/pre&gt;
&lt;p&gt;check_timeout 每秒对每个channel上的每个sub, 检查是否过了一段时间的idle, 如果是idle, 就回复这个sub没有更新(noop()方法):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int Server::check_timeout(){
    //log_debug(&amp;quot;&amp;lt;&amp;quot;);
    LinkedList&amp;lt;Channel *&amp;gt;::Iterator it = used_channels.iterator();
    while(Channel *channel = it.next()){
        if(channel-&amp;gt;subs.size == 0){
            if(--channel-&amp;gt;idle &amp;lt; 0){
                this-&amp;gt;free_channel(channel);
            }
            continue;
        }
        if(channel-&amp;gt;idle &amp;lt; ServerConfig::channel_idles){
            channel-&amp;gt;idle = ServerConfig::channel_idles;
        }

        LinkedList&amp;lt;Subscriber *&amp;gt;::Iterator it2 = channel-&amp;gt;subs.iterator();
        while(Subscriber *sub = it2.next()){
            if(++sub-&amp;gt;idle &amp;lt;= ServerConfig::polling_idles){
                continue;
            }
            sub-&amp;gt;idle = 0;
            sub-&amp;gt;noop();
        }
    }
    //log_debug(&amp;quot;&amp;gt;&amp;quot;);
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;这个方法效率极低.&lt;/p&gt;
&lt;div class="section" id="pub"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pub&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
int Server::pub(struct evhttp_request *req, bool encoded){
    channel = this-&amp;gt;get_channel_by_name(cname);
    // response to publisher
    evhttp_add_header(req-&amp;gt;output_headers, &amp;quot;Content-Type&amp;quot;, &amp;quot;text/javascript; charset=utf-8&amp;quot;);
    struct evbuffer *buf = evbuffer_new();

    evbuffer_add_printf(buf, &amp;quot;{\&amp;quot;type\&amp;quot;:\&amp;quot;ok\&amp;quot;}&amp;quot;);

    evhttp_send_reply(req, 200, &amp;quot;OK&amp;quot;, buf);
    evbuffer_free(buf);

    // push to subscribers
    channel-&amp;gt;send(&amp;quot;data&amp;quot;, content, encoded);
    return 0;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="sub"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;sub&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
int Server::sub(struct evhttp_request *req, Subscriber::Type sub_type){
    HttpQuery query(req);
    int seq = query.get_int(&amp;quot;seq&amp;quot;, 0);
    int noop = query.get_int(&amp;quot;noop&amp;quot;, 0);
    const char *cb = query.get_str(&amp;quot;cb&amp;quot;, &amp;quot;&amp;quot;);
    const char *token = query.get_str(&amp;quot;token&amp;quot;, &amp;quot;&amp;quot;);
    std::string cname = query.get_str(&amp;quot;cname&amp;quot;, &amp;quot;&amp;quot;);

    Channel *channel = this-&amp;gt;get_channel_by_name(cname);

    ... //check

    Subscriber *sub = new Subscriber();
    sub-&amp;gt;req = req;
    sub-&amp;gt;type = sub_type;
    sub-&amp;gt;idle = 0;
    sub-&amp;gt;seq_next = seq;
    sub-&amp;gt;seq_noop = noop;
    sub-&amp;gt;callback = cb;

    channel-&amp;gt;add_subscriber(sub); //添加进去.
    subscribers ++;
    sub-&amp;gt;start();

    return 0;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="channel-cpp-pub"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;channel.cpp (pub端)&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
class Channel{
    LinkedList&amp;lt;Subscriber *&amp;gt; subs;
    int idle;
    int seq_next;
    std::string name;
    std::string token;
    std::vector&amp;lt;std::string&amp;gt; msg_list; //用一个vector保存msg
    void add_subscriber(Subscriber *sub);
    void send(const char *type, const char *content, bool encoded=true);
}
&lt;/pre&gt;
&lt;p&gt;这是pub逻辑,&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void Channel::send(const char *type, const char *content, bool encoded){
    ...
    msg_list.push_back(content);
    seq_next ++;
    if(msg_list.size() &amp;gt;= ServerConfig::channel_buffer_size * 1.5){
        std::vector&amp;lt;std::string&amp;gt;::iterator it;
        it = msg_list.end() - ServerConfig::channel_buffer_size;
        msg_list.assign(it, msg_list.end());
        log_trace(&amp;quot;resize msg_list to %d, seq_next: %d&amp;quot;, msg_list.size(), seq_next);
    }
    LinkedList&amp;lt;Subscriber *&amp;gt;::Iterator it = subs.iterator();
    while(Subscriber *sub = it.next()){
        sub-&amp;gt;send_chunk(this-&amp;gt;seq_next, type, new_content.c_str());
    }
}
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;sub-&amp;gt;send_chunk&lt;/span&gt;&lt;/tt&gt; 是决定向sub端发数据,
前面 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;serv-&amp;gt;check_timeout()&lt;/span&gt;&lt;/tt&gt; 里面sub-&amp;gt;noop() 是决定向sub端回复说 &lt;tt class="docutils literal"&gt;没有消息&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="subscriber-cpp-subscriber-h"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;subscriber.cpp subscriber.h&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
evhttp_add_header(req-&amp;gt;output_headers, &amp;quot;Connection&amp;quot;, &amp;quot;keep-alive&amp;quot;);
evhttp_send_reply_chunk(this-&amp;gt;req, buf);
&lt;/pre&gt;
&lt;p&gt;evhttp_send_reply_chunk, 就是用Chunked方式回复数据.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;消息存在内存中, 不能持久化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一个channel如果一直活跃, 消息就不会删除, 越堆越多?(一个channel有个最大消息量):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if(msg_list.size() &amp;gt;= ServerConfig::channel_buffer_size * 1.5){
    std::vector&amp;lt;std::string&amp;gt;::iterator it;
    it = msg_list.end() - ServerConfig::channel_buffer_size;
    msg_list.assign(it, msg_list.end());
    log_trace(&amp;quot;resize msg_list to %d, seq_next: %d&amp;quot;, msg_list.size(), seq_next);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;有channel timeout, 没有msg timeout&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="k"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;1000K 连接的测试.&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ideawu 提供了一个 c1000k 代码:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/ideawu/c1000k"&gt;https://github.com/ideawu/c1000k&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要测试c1000k 主要两个问题:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;是server 端, 每个sokcet 大约需要占用0.5M内存(内核sokcet缓冲区内存), 所以总共需要500G内存.&lt;/li&gt;
&lt;li&gt;client端, client 只能开大约3w-5w个client端口(对每个server ip+port, 只能有3w-5w连接)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ideawu是这样解决的:
1. server 端每accept一个连接, 都设置它的缓冲区大小为5k:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
     bufsize = 5000;
     setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;amp;bufsize, sizeof(bufsize));
     setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;amp;bufsize, sizeof(bufsize));

这样1000k连接只需要10G内存.
&lt;/pre&gt;
&lt;ol class="arabic" start="2"&gt;
&lt;li&gt;&lt;p class="first"&gt;server 端开100个port, 这样每个客户端3w端口, 就可以开300w个连接.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;这时候, 限制就只有fd个数限制了.&lt;/p&gt;
&lt;p&gt;我启动的时候设置好limit就可以&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ limit -n 1024000 ./server 6000
$ limit -n 1024000 ./client 127.0.0.1 6000

可以一直跑到:
connections: 1023897
error: Too many open files
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于comet, evhttp 应该是最佳选择, 好于nginx.&lt;/li&gt;
&lt;li&gt;赞ideawu.&lt;/li&gt;
&lt;li&gt;消息不持久化,&lt;/li&gt;
&lt;li&gt;单机模式, 如何扩展?&lt;/li&gt;
&lt;li&gt;定时timer遍历, 对单进程服务器来说, 应该不可接受.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>redis-aof-replay</title><link href="/redis-aof-replay.html" rel="alternate"></link><updated>2014-02-27T09:44:50+08:00</updated><author><name>ning</name></author><id>tag:,2014-02-27:redis-aof-replay.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aof" id="id13"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;简单的重放aof&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aofredis" id="id14"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;重放aof到redis实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aoftwemproxy" id="id15"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;重放aof到twemproxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id16"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;各种命令的aof格式&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mset" id="id17"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#del-key" id="id18"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;del 删除多个key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id19"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id20"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;aof解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aof-replay" id="id21"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;实现aof-replay&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id22"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;功能和注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tail-f" id="id23"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;tail -f&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fdselect" id="id24"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试在fd上做select&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#poll" id="id25"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;用poll 呢?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id26"&gt;4.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;tail -f 怎么做的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id27"&gt;4.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#twemproxypipeline" id="id28"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy对pipeline支持不好和性能&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#safe" id="id29"&gt;4.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;safe模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id30"&gt;4.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;测试几种方式的性能&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bench" id="id31"&gt;4.3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞式简单bench&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gprof" id="id32"&gt;4.3.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;gprof结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#write-read" id="id33"&gt;4.3.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞改为直接write/read&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pipeline" id="id34"&gt;4.3.2.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;改成pipeline:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id35"&gt;4.3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;异步bench&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-benchmark" id="id36"&gt;4.3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-benchmark 的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id37"&gt;4.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id38"&gt;4.3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#update-2014-03-13-10-13-19" id="id39"&gt;4.3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;update &amp;#64;2014-03-13 10:13:19&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id40"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clean" id="id41"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;clean脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id42"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="aof"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;简单的重放aof&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="aofredis"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;重放aof到redis实例&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;aof 文件有个优势:&lt;/p&gt;
&lt;p&gt;因为它的格式是和协议一致, 重放非常简单, 直接用如下命令即可:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat data/appendonly.aof | nc localhost 22003
+OK
+OK
+OK
+OK
+OK
+OK
+OK
+OK
&lt;/pre&gt;
&lt;p&gt;或者用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-cli&lt;/span&gt;&lt;/tt&gt; 提供的pipe功能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat data/appendonly.aof | redis-cli --pipe  -h 127.0.0.5 -p 22003
All data transferred. Waiting for the last reply...
Last reply received from server.
errors: 0, replies: 115
&lt;/pre&gt;
&lt;p&gt;时间消耗, 在我的pc上 300M需要 120s, 速度大约2M/s, (6w条/s), 每天单进程可以重放156G(5亿条):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis-mgr$ ll /home/ning/Desktop/t/appendonly.aof
787171 -rw-r--r-- 1 ning ning 371M 2014-02-26 22:56 /home/ning/Desktop/t/appendonly.aof

ning&amp;#64;ning-laptop:~/idning-github/redis-mgr$ time cat /home/ning/Desktop/t/appendonly.aof | redis-cli --pipe -h 127.0.0.5 -p 22003
All data transferred. Waiting for the last reply...
Last reply received from server.
errors: 0, replies: 7339651

real    1m58.729s
user    0m8.700s
sys 0m1.780s
&lt;/pre&gt;
&lt;p&gt;实现: pipe功能就是简单的 把STDIN 的内容写到soket:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="aoftwemproxy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;重放aof到twemproxy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面的方法不能通过twemproxy重放:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:/tmp/r/redis-22001$ cat data/appendonly.aof | redis-cli --pipe  -h 127.0.0.5 -p 24000
All data transferred. Waiting for the last reply...

No replies for 30 seconds: exiting.
errors: 1, replies: 0
&lt;/pre&gt;
&lt;p&gt;原因:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;proxy does not support mset/select ....&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了把它变成一个迁移工具, pipe工具性能已经满足要求, 功能上需要增加支持:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;兼容proxy(去掉select, 处理mset)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--filter&lt;/span&gt;&lt;/tt&gt; : key filter (这里需要解析命令)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--rewrite&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--tail&lt;/span&gt;&lt;/tt&gt; 支持 &lt;tt class="docutils literal"&gt;tail &lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;最后发的echo命令要去掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol class="arabic simple" start="6"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--check&lt;/span&gt;&lt;/tt&gt; check any command not supported&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;各种命令的aof格式&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#key-value
redis-cli -h 127.0.0.5 -p 22001 SET key0 v0
redis-cli -h 127.0.0.5 -p 22001 GETSET key0 v0
redis-cli -h 127.0.0.5 -p 22001 APPEND key0 v_a
redis-cli -h 127.0.0.5 -p 22001 STRLEN key0
#expire
redis-cli -h 127.0.0.5 -p 22001 EXPIRE key0 5
sleep 6
redis-cli -h 127.0.0.5 -p 22001 SETEX key0 5 v_a
sleep 6
#counter
redis-cli -h 127.0.0.5 -p 22001 INCR key1
#hash
redis-cli -h 127.0.0.5 -p 22001 HSET key3 h3 val3
#list
redis-cli -h 127.0.0.5 -p 22001 LPUSH key4 v4
redis-cli -h 127.0.0.5 -p 22001 LPOP key4
#set
redis-cli -h 127.0.0.5 -p 22001 SADD key5 v5
&lt;/pre&gt;
&lt;p&gt;对应关系如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
----------------------------------------------------------------------------------------------------------------

#key-value
redis-cli -h 127.0.0.5 -p 22001 SET key0 v0
                                                        *3
                                                        $3
                                                        SET
                                                        $4
                                                        key0
                                                        $2
                                                        v0

redis-cli -h 127.0.0.5 -p 22001 GETSET key0 v0
                                                        *3
                                                        $6
                                                        GETSET
                                                        $4
                                                        key0
                                                        $2
                                                        v0

redis-cli -h 127.0.0.5 -p 22001 APPEND key0 v_a
                                                        *3
                                                        $6
                                                        APPEND
                                                        $4
                                                        key0
                                                        $3
                                                        v_a

redis-cli -h 127.0.0.5 -p 22001 STRLEN key0 &amp;lt;nothing&amp;gt;

redis-cli -h 127.0.0.5 -p 22001 EXPIRE key0 5           (转变为PEXPIREAT)

                                                        *3
                                                        $9
                                                        PEXPIREAT
                                                        $4
                                                        key0
                                                        $13
                                                        1393467438683

sleep 6                                                 (5s后被删除)

                                                        *2
                                                        $3
                                                        DEL
                                                        $4
                                                        key0

redis-cli -h 127.0.0.5 -p 22001 SETEX key0 5 v_a        (SETEX转成两个命令)
                                                        *3
                                                        $3
                                                        SET
                                                        $4
                                                        key0
                                                        $3
                                                        v_a

                                                        *3
                                                        $9
                                                        PEXPIREAT
                                                        $4
                                                        key0
                                                        $13
                                                        1393467444711

sleep 6
                                                        *2
                                                        $3
                                                        DEL
                                                        $4
                                                        key0

redis-cli -h 127.0.0.5 -p 22001 INCR key1               &amp;lt;INCR记录的是变化, 不是结果&amp;gt;
                                                        *2
                                                        $4
                                                        INCR
                                                        $4
                                                        key1

redis-cli -h 127.0.0.5 -p 22001 HSET key3 h3 val3
                                                        *4
                                                        $4
                                                        HSET
                                                        $4
                                                        key3
                                                        $2
                                                        h3
                                                        $4
                                                        val3

redis-cli -h 127.0.0.5 -p 22001 LPUSH key4 v4
                                                        *3
                                                        $5
                                                        LPUSH
                                                        $4
                                                        key4
                                                        $2
                                                        v4

redis-cli -h 127.0.0.5 -p 22001 LPOP key4
                                                        *2
                                                        $4
                                                        LPOP
                                                        $4
                                                        key4

redis-cli -h 127.0.0.5 -p 22001 SADD key5 v5
                                                        *3
                                                        $4
                                                        SADD
                                                        $4
                                                        key5
                                                        $2
                                                        v5
&lt;/pre&gt;
&lt;div class="section" id="mset"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mset&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
$redis-cli -h 127.0.0.5 -p 22000 mset k1 v1 k2 v2

                                                            mset
                                                            $2
                                                            k1
                                                            $2
                                                            v1
                                                            $2
                                                            k2
                                                            $2
                                                            v2
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="del-key"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;del 删除多个key&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;不是记录3个del命令, 而是记录一个命令&lt;/li&gt;
&lt;li&gt;只要del生效(能删掉任何一条记录), 就会记录对命令中所有key的删除.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
$ redis-cli -h 127.0.0.5 -p 22001 set key1 3
OK
                                                                        *3
                                                                        $3
                                                                        set
                                                                        $4
                                                                        key1
                                                                        $1
                                                                        3

$ redis-cli -h 127.0.0.5 -p 22001 set key2 3
OK

                                                                        *3
                                                                        $3
                                                                        set
                                                                        $4
                                                                        key2
                                                                        $1
                                                                        3

#注意这里删除3个key, 只有2个key存在的情况下, 记录的aof是在一个del命令中删除3个key
$ redis-cli -h 127.0.0.5 -p 22001 del key1 key2 key3
(integer) 2
                                                                        *4
                                                                        $3
                                                                        del
                                                                        $4
                                                                        key1
                                                                        $4
                                                                        key2
                                                                        $4
                                                                        key3

$ redis-cli -h 127.0.0.5 -p 22001 del key1 key2 key3
(integer) 0
$ redis-cli -h 127.0.0.5 -p 22001 del key1 key2 key3
(integer) 0
                                                                        这里没有对应的aof
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;aof 中记录的命令可能是大写/小写. 用户怎么用就是怎么记录.&lt;/li&gt;
&lt;li&gt;mset, del比较记录的也是原始操作.&lt;/li&gt;
&lt;li&gt;incr等, 也是记录操作, 而不是记录结果.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;aof解析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;aof解析非常简单, 从 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-check-aof&lt;/span&gt;&lt;/tt&gt; 中就可以看出来:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
off_t process(FILE *fp) {
    long argc;
    off_t pos = 0;
    int i, multi = 0;
    char *str;

    while(1) {
        if (!multi) pos = ftello(fp);
        if (!readArgc(fp, &amp;amp;argc)) break;

        for (i = 0; i &amp;lt; argc; i++) {
            readString(fp,&amp;amp;str);
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;redis中解析, load aof 是这个函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Replay the append log file. On error REDIS_OK is returned. On non fatal
 * error (the append only file is zero-length) REDIS_ERR is returned. On
 * fatal error an error Message is logged and the program exists. */
int loadAppendOnlyFile(char *filename) {
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="aof-replay"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;实现aof-replay&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;功能和注意&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;points:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;remove all &lt;tt class="docutils literal"&gt;select&lt;/tt&gt; / &lt;tt class="docutils literal"&gt;multi&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;change &lt;tt class="docutils literal"&gt;MSET/MSETNX/DEL&lt;/tt&gt; to many &lt;tt class="docutils literal"&gt;SET/SETNX/DEL&lt;/tt&gt; cmd;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--filter&lt;/span&gt;&lt;/tt&gt; : filter key by prefix&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--orig&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--rewrite&lt;/span&gt;&lt;/tt&gt;, rewrite key.&lt;/li&gt;
&lt;li&gt;follow aof modification like &lt;tt class="docutils literal"&gt;tail &lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--check&lt;/span&gt;&lt;/tt&gt; check any command not supported&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;如果解析到multi(后面可能有一个回滚, 不能简单丢弃multi)&lt;/li&gt;
&lt;li&gt;测试可以通过回回放一个现有库, 然后对比&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="tail-f"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;tail -f&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里要实现tail -f 的功能, 需要一个readline 的功能(因为fgets在EOF的时候直接返回, 不能用fgets)&lt;/p&gt;
&lt;p&gt;对 &lt;tt class="docutils literal"&gt;read&lt;/tt&gt; 做了几个测试, 发现:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;如果fd是文件, 文件在变化的情况下, 用read() 系统调用, 如果到达文件尾, 会直接返回, 而不会等待.&lt;/li&gt;
&lt;li&gt;如果fd是网络, read() 如果没有可读, 就会阻塞.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="fdselect"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id24"&gt;4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;尝试在fd上做select&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;tail -f 有这样的逻辑, 但是我试了, select 就算在文件尾也总是返回可读. 查了一下:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/11901884/how-can-select-wait-on-regular-file-descriptors-non-sockets"&gt;http://stackoverflow.com/questions/11901884/how-can-select-wait-on-regular-file-descriptors-non-sockets&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Disk files are always ready to read (but the read might return 0 bytes if you're already at the end of the file), so you can't use select() on a disk file to find out when new data is added to the file.
&lt;/pre&gt;
&lt;p&gt;POSIX says:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error conditions.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="poll"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id25"&gt;4.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;用poll 呢?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这里有一个详细的测试: &lt;a class="reference external" href="http://www.greenend.org.uk/rjk/tech/poll.html"&gt;http://www.greenend.org.uk/rjk/tech/poll.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;依然显示 对于regular file, 在到达EOF时, poll总是返回POLLIN.&lt;/p&gt;
&lt;p&gt;这就是说, select/poll 只对 pipes/sockets 这样会发生阻塞读写的介质有效.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id26"&gt;4.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;tail -f 怎么做的&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;看源码:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;coreutils-8.12/src/tail.c 用了 &lt;tt class="docutils literal"&gt;inotify&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;coreutils-8.12/src/tail.c 在用pipe方式 的时候(作为另一个程序的输出的下游), 用了 &lt;tt class="docutils literal"&gt;select&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;比较老的版本(7.4) 用sleep&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用sleep的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c$ tail --version
tail (GNU coreutils) 7.4

ning&amp;#64;ning-laptop:~/idning/langtest/c$ strace tail -f common.h
execve(&amp;quot;/usr/bin/tail&amp;quot;, [&amp;quot;tail&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;common.h&amp;quot;], [/* 69 vars */]) = 0
brk(0)                                  = 0xd1a000
...
nanosleep({1, 0}, NULL)                 = 0
fstat(3, {st_mode=S_IFREG|0644, st_size=635, ...}) = 0
nanosleep({1, 0}, NULL)                 = 0
fstat(3, {st_mode=S_IFREG|0644, st_size=635, ...}) = 0
nanosleep({1, 0}, NULL)                 = 0
fstat(3, {st_mode=S_IFREG|0644, st_size=635, ...}) = 0
&lt;/pre&gt;
&lt;p&gt;用sleep的代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Tail NFILES files forever, or until killed.
   The pertinent information for each file is stored in an entry of F.
   Loop over each of them, doing an fstat to see if they have changed size,
   and an occasional open/fstat to see if any dev/ino pair has changed.
   If none of them have changed size in one iteration, sleep for a
   while and try again.  Continue until the user interrupts us.  */


static void tail_forever (struct File_spec *f, int nfiles, double sleep_interval)
{

    ...

    if (fstat (fd, &amp;amp;stats) != 0)
    {
      f[i].fd = -1;
      f[i].errnum = errno;
      error (0, errno, &amp;quot;%s&amp;quot;, name);
      continue;
    }

      if (f[i].mode == stats.st_mode
      &amp;amp;&amp;amp; (! S_ISREG (stats.st_mode) || f[i].size == stats.st_size)
      &amp;amp;&amp;amp; timespec_cmp (f[i].mtime, get_stat_mtime (&amp;amp;stats)) == 0)
    {
        //not change
    }
    change
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id27"&gt;4.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;通过sleep实现tail -f&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="twemproxypipeline"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;twemproxy对pipeline支持不好和性能&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-cli&lt;/span&gt; &lt;span class="pre"&gt;--pipe&lt;/span&gt;&lt;/tt&gt; 是使用pipeline 模式的, 只要server端可写, 就会不停的写,&lt;/p&gt;
&lt;p&gt;但是twemproxy总是尽最大能力的读, 把消息放在内存中, 这样消息都会堆在twemproxy, 并且超时.&lt;/p&gt;
&lt;p&gt;这个问题的讨论见: &lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/203"&gt;https://github.com/twitter/twemproxy/issues/203&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;safe模式, 一条一条写，写成功再写下一条.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;batch模式, 为了保证尽量写成功, 此时需要&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;加大twemproxy 的timeout.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;有某种block机制, 确保不会有大量请求堆在twemproxy.&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;比如客户端计数, 发出的req - 收到的resp &amp;lt; 1024&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="safe"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id29"&gt;4.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;safe模式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;用redisCommandArgv:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
while(1){
    msg = readMsg(fp);
    reply = redisCommandArgv(context, msg-&amp;gt;argc, (const char **)msg-&amp;gt;argv, msg-&amp;gt;argvlen);
    freeReplyObject(reply);
    freeMsg(msg);
}
&lt;/pre&gt;
&lt;p&gt;发现性能不好: 后端为twemproxy时大约7000/s, 后端为redis大约10000/s.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id30"&gt;4.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;测试几种方式的性能&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="bench"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id31"&gt;4.3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞式简单bench&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;直接调用redisCommand 性能如何:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat bench1.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include &amp;quot;hiredis.h&amp;quot;

int main(void) {
    unsigned int i;
    redisContext *c;
    redisReply *reply;

    struct timeval timeout = { 1, 500000 }; // 1.5 seconds
    c = redisConnectWithTimeout((char*)&amp;quot;127.0.0.5&amp;quot;, 22000, timeout);
    if (c-&amp;gt;err) {
        printf(&amp;quot;Connection error: %s\n&amp;quot;, c-&amp;gt;errstr);
        exit(1);
    }
    for(i=0; i&amp;lt;100*1000; i++){
        reply = redisCommand(c,&amp;quot;SET %s %s&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;hello world&amp;quot;);
        freeReplyObject(reply);
    }
    return 0;
}
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cc bench1.c -I ./ -L ./ -l hiredis   (或cc bench1.c libhiredis.a)
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ time ./a.out

real        0m6.945s
user        0m0.710s
sys 0m1.710s
&lt;/pre&gt;
&lt;p&gt;100*1000/6.9 = 1.4w/s&lt;/p&gt;
&lt;div class="section" id="gprof"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id32"&gt;4.3.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;gprof结果&lt;/a&gt;&lt;/h6&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cc bench1.c libhiredis.a -pg
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ ./a.out
$ gprof  ./a.out ./gmon.out  | vim -

Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
 22.23      0.04     0.04                             redisReaderGetReply
 16.67      0.07     0.03                             redisvFormatCommand
 11.12      0.09     0.02                             redisGetReply
 11.12      0.11     0.02                             sdscatlen
  5.56      0.12     0.01                             main
  5.56      0.13     0.01                             redisBufferRead
  5.56      0.14     0.01                             redisBufferWrite
  5.56      0.15     0.01                             sdsIncrLen
  5.56      0.16     0.01                             sdsempty
  5.56      0.17     0.01                             sdsnewlen
  2.78      0.18     0.01                             sdsMakeRoomFor
  2.78      0.18     0.01                             sdsRemoveFreeSpace
&lt;/pre&gt;
&lt;p&gt;总共7s, 为啥self seconds 加起来不是7s&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="write-read"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id33"&gt;4.3.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞改为直接write/read&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;依然很慢:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cat bench3.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

#include &amp;quot;hiredis.h&amp;quot;

int main(void) {
    unsigned int i;
    redisContext *c;
    redisReply *reply;
    int ret;

    struct timeval timeout = { 1, 500000 }; // 1.5 seconds
    c = redisConnectWithTimeout((char*)&amp;quot;127.0.0.5&amp;quot;, 22000, timeout);
    if (c-&amp;gt;err) {
        printf(&amp;quot;Connection error: %s\n&amp;quot;, c-&amp;gt;errstr);
        exit(1);
    }

    char *cmd = &amp;quot;*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$9\r\nbarbarbar\r\n&amp;quot;;
    int len = strlen(cmd);

    char buf[1024];
    for(i=0; i&amp;lt;100*1000; i++){
        ret = write(c-&amp;gt;fd, cmd, len);
        assert(len == ret);

        /*fprintf(stderr, &amp;quot;read\n&amp;quot;);*/
        ret = read(c-&amp;gt;fd, buf, 5);
        assert(5 == ret);

        buf[5] = 0;
        /*fprintf(stderr, &amp;quot;%d: %s\n&amp;quot;, i, buf);*/
        /*assert(0 == strcmp(buf, &amp;quot;+OK\r\n&amp;quot;));*/
    }
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;还是要5s. (2w/s)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pipeline"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id34"&gt;4.3.2.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;改成pipeline:&lt;/a&gt;&lt;/h6&gt;
&lt;pre class="literal-block"&gt;
for(i=0; i&amp;lt;100*1000; i++){
    ret = twrite(c-&amp;gt;fd, cmd, len);
    assert(len == ret);

}
for(i=0; i&amp;lt;100*1000; i++){
    ret = tread(c-&amp;gt;fd, buf, 5);
    assert(5 == ret);
}
&lt;/pre&gt;
&lt;p&gt;只需要0.4s&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id35"&gt;4.3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;异步bench&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cat bench2.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;quot;hiredis.h&amp;quot;
#include &amp;quot;async.h&amp;quot;
#include &amp;quot;adapters/ae.h&amp;quot;

/* Put event loop in the global scope, so it can be explicitly stopped */
static aeEventLoop *loop;

void setCallback(redisAsyncContext *c, void *r, void *privdata) {
    redisReply *reply = r;
    if (reply == NULL) return;
    int * pi = (int*) privdata;

    printf(&amp;quot;argv[%d]: %s\n&amp;quot;, *pi, reply-&amp;gt;str);

    (*pi)++;
    if (*pi &amp;gt; 100*1000)
        exit(0);

    redisAsyncCommand(c, setCallback, (char*)pi, &amp;quot;SET thekey %s&amp;quot;, &amp;quot;xxxxxxxxxxxxxx&amp;quot;);
}

void connectCallback(const redisAsyncContext *c, int status) {
    if (status != REDIS_OK) {
        printf(&amp;quot;Error: %s\n&amp;quot;, c-&amp;gt;errstr);
        return;
    }
    printf(&amp;quot;Connected...\n&amp;quot;);
}
void disconnectCallback(const redisAsyncContext *c, int status) {
    if (status != REDIS_OK) {
        printf(&amp;quot;Error: %s\n&amp;quot;, c-&amp;gt;errstr);
        return;
    }
    printf(&amp;quot;Disconnected...\n&amp;quot;);
}

int main() {
    signal(SIGPIPE, SIG_IGN);

    redisAsyncContext *c = redisAsyncConnect(&amp;quot;127.0.0.1&amp;quot;, 6379);
    if (c-&amp;gt;err) {
        /* Let *c leak for now... */
        printf(&amp;quot;Error: %s\n&amp;quot;, c-&amp;gt;errstr);
        return 1;
    }

    loop = aeCreateEventLoop(1000);
    redisAeAttach(loop, c);
    redisAsyncSetConnectCallback(c,connectCallback);
    redisAsyncSetDisconnectCallback(c,disconnectCallback);

    int i = 0;
    redisAsyncCommand(c, setCallback, (char*)&amp;amp;i, &amp;quot;SET thekey %s&amp;quot;, &amp;quot;xxxxxxxxxxxxxx&amp;quot;);
    aeMain(loop);
    return 0;
}
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cc -I../../src ../../src/ae.o ../../src/zmalloc.o bench2.c libhiredis.a ../jemalloc/lib/libjemalloc.a -lpthread
&lt;/pre&gt;
&lt;p&gt;still 6s.(差不多还是2w/s)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-benchmark"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id36"&gt;4.3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-benchmark 的实现&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;异步.&lt;/p&gt;
&lt;p&gt;创建一些client, 每个client注册如下事件:&lt;/p&gt;
&lt;blockquote&gt;
aeCreateFileEvent(config.el,c-&amp;gt;context-&amp;gt;fd,AE_WRITABLE,writeHandler,c);&lt;/blockquote&gt;
&lt;p&gt;writeHandler:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    REDIS_NOTUSED(el);
    REDIS_NOTUSED(fd);
    REDIS_NOTUSED(mask);

    /* Initialize request when nothing was written. */
    if (c-&amp;gt;written == 0) {
        /* Enforce upper bound to number of requests. */
        if (config.requests_issued++ &amp;gt;= config.requests) {
            freeClient(c);
            return;
        }

        /* Really initialize: randomize keys and set start time. */
        if (config.randomkeys) randomizeClientKey(c);
        c-&amp;gt;start = ustime();
        c-&amp;gt;latency = -1;
    }

    if (sdslen(c-&amp;gt;obuf) &amp;gt; c-&amp;gt;written) {
        void *ptr = c-&amp;gt;obuf+c-&amp;gt;written;
        int nwritten = write(c-&amp;gt;context-&amp;gt;fd,ptr,sdslen(c-&amp;gt;obuf)-c-&amp;gt;written);
        if (nwritten == -1) {
            if (errno != EPIPE)
                fprintf(stderr, &amp;quot;Writing to socket: %s\n&amp;quot;, strerror(errno));
            freeClient(c);
            return;
        }
        c-&amp;gt;written += nwritten;
        if (sdslen(c-&amp;gt;obuf) == c-&amp;gt;written) {
            aeDeleteFileEvent(config.el,c-&amp;gt;context-&amp;gt;fd,AE_WRITABLE);
            aeCreateFileEvent(config.el,c-&amp;gt;context-&amp;gt;fd,AE_READABLE,readHandler,c);
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;每写成功一个消息, 去掉AE_WRITABLE, 加上AE_READABLE:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    if (sdslen(c-&amp;gt;obuf) == c-&amp;gt;written) {
        aeDeleteFileEvent(config.el,c-&amp;gt;context-&amp;gt;fd,AE_WRITABLE);
        aeCreateFileEvent(config.el,c-&amp;gt;context-&amp;gt;fd,AE_READABLE,readHandler,c);
    }
}
&lt;/pre&gt;
&lt;p&gt;在read完之后, 重新用激活可写事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (c-&amp;gt;pending == 0) {
    clientDone(c); //里面会加AE_WRITABLE
    break;
}
&lt;/pre&gt;
&lt;p&gt;redis-benchmark 默认是不用pipeline 的. 写一个, 读一个, 但是是用异步api.&lt;/p&gt;
&lt;p&gt;如果pipeline模式benchmark, 它在准备数据的时候就一次性把多个命令写道obuf里面去:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
for (j = 0; j &amp;lt; config.pipeline; j++)
    c-&amp;gt;obuf = sdscatlen(c-&amp;gt;obuf,cmd,len);
c-&amp;gt;pending = config.pipeline;
&lt;/pre&gt;
&lt;p&gt;发现用redis-benchmark性能能达到5w左右, 后来发现是因为redis-benchmark默认-c 50, 就是50个client并发, 如果用-c 1的话, 性能还是比较差:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/src$ time redis-benchmark -h 127.0.0.5 -p 22000 -c 1 -t set -n 100000
====== SET ======
  100000 requests completed in 8.64 seconds
  1 parallel clients
  3 bytes payload
  keep alive: 1

99.99% &amp;lt;= 1 milliseconds
100.00% &amp;lt;= 2 milliseconds
100.00% &amp;lt;= 3 milliseconds
100.00% &amp;lt;= 7 milliseconds
11579.44 requests per second



real        0m8.651s
user        0m0.570s
sys 0m2.390s
&lt;/pre&gt;
&lt;p&gt;大约8s, (1.2w/s)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id37"&gt;4.3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h4&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;为什么这里的非阻塞调用benchmark性能很差?&lt;/li&gt;
&lt;li&gt;问什么redis-benmark的写法, 性能好?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三种方式:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;阻塞: 慢&lt;/li&gt;
&lt;li&gt;自己的非阻塞写法: 慢&lt;/li&gt;
&lt;li&gt;redis-benchmark写法: 慢&lt;/li&gt;
&lt;li&gt;redis-cli的pipe写法: 快&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TODO: &lt;strong&gt;这里的原因, 还是不清楚..&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;难道是, 如果read系统调用时, 数据准备好, 则很快, 没准备好, 则很慢.&lt;/p&gt;
&lt;p&gt;同样都是发送, 等待响应, 解析响应.&lt;/p&gt;
&lt;p&gt;貌似只能理解为用阻塞方式等待响应很耗时.&lt;/p&gt;
&lt;p&gt;这个问题, 可以把服务器抽象为一个简单的echo-server, 此时客户端一问一答的形式, 最大能达到多大的qps.&lt;/p&gt;
&lt;p&gt;用strace发现一个共同点: 2,3都是用epoll异步, 一次epoll_wait 做一次write, 在epoll_wait, 再一次read:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
epoll_ctl(3, EPOLL_CTL_MOD, 4, {EPOLLIN, {u32=4, u64=4}}) = 0
epoll_ctl(3, EPOLL_CTL_DEL, 4, {0, {u32=4, u64=4}}) = 0
epoll_ctl(3, EPOLL_CTL_ADD, 4, {EPOLLOUT, {u32=4, u64=4}}) = 0
epoll_wait(3, {{EPOLLOUT, {u32=4, u64=4}}}, 10240, 240) = 1
write(4, &amp;quot;*3\r\n$3\r\nSET\r\n$16\r\nkey:__rand_int&amp;quot;..., 45) = 45
epoll_ctl(3, EPOLL_CTL_DEL, 4, {0, {u32=4, u64=4}}) = 0
epoll_ctl(3, EPOLL_CTL_ADD, 4, {EPOLLIN, {u32=4, u64=4}}) = 0
epoll_wait(3, {{EPOLLIN, {u32=4, u64=4}}}, 10240, 239) = 1
read(4, &amp;quot;+OK\r\n&amp;quot;, 16384)               = 5
&lt;/pre&gt;
&lt;p&gt;4是用pool, 而且一个pool就能做一次read, 一次write:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/src$ strace ./redis-cli  -h 127.0.0.5 -p 22000 --replay ~/Desktop/t/appendonly.aof
poll([{fd=3, events=POLLIN|POLLOUT}], 1, 1000) = 1 ([{fd=3, revents=POLLIN|POLLOUT}])
read(3, &amp;quot;+OK\r\n&amp;quot;, 16384)               = 5
read(3, 0x7fff7d548f10, 16384)          = -1 EAGAIN (Resource temporarily unavailable)
write(3, &amp;quot;*3\r\n$3\r\nSET\r\n$13\r\nkkk-100000756\r&amp;quot;..., 53) = 53
poll([{fd=3, events=POLLIN|POLLOUT}], 1, 1000) = 1 ([{fd=3, revents=POLLIN|POLLOUT}])
read(3, &amp;quot;+OK\r\n&amp;quot;, 16384)               = 5
read(3, 0x7fff7d548f10, 16384)          = -1 EAGAIN (Resource temporarily unavailable)
write(3, &amp;quot;*3\r\n$3\r\nSET\r\n$13\r\nkkk-100000757\r&amp;quot;..., 53) = 53
&lt;/pre&gt;
&lt;div class="section" id="id10"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id38"&gt;4.3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;具体实现&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;当前我的写法相当于长度为1的pipe, 本质和 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-cli&lt;/span&gt;&lt;/tt&gt; 写法一样. 性能挺好(5w/s)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="update-2014-03-13-10-13-19"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id39"&gt;4.3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;update &amp;#64;2014-03-13 10:13:19&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;后来发现, 我当时写的--replay 有bug, 相当于用了长度为 100左右的pipe. 所以表现的性能很好. 代码是在这个commit:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/idning/redis/commit/b122ab0c749f2a93bb514ae07ba73739690ab46e"&gt;https://github.com/idning/redis/commit/b122ab0c749f2a93bb514ae07ba73739690ab46e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改了这个bug后:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/idning/redis/commit/b956e2cf92feb510f7d1a2f158a8eafe907d9ae1"&gt;https://github.com/idning/redis/commit/b956e2cf92feb510f7d1a2f158a8eafe907d9ae1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现如果定义pipe长度是1, 性能就在1w左右. 改为10, 就在5w左右(laptop测试)&lt;/p&gt;
&lt;p&gt;如果用线上机器:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pipesize    1    10  100  1000
loclhost:   1w   4w  5w   5w
online:     0.3  1w  10w  12w
&lt;/pre&gt;
&lt;p&gt;线上pipeline为1时, 只有0.3, 原因是线上网络RTT大, (这么看每个请求3ms), 用的是压力较大的线上机器.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;其它&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="clean"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id41"&gt;4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;clean脚本&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;需要一个脚本, 如果重放到一半出错, 需要清除所有前缀为xxx的key&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id42"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
https://github.com/idning/redis/blob/replay/src/redis-cli.c
https://github.com/cen-li/redis/blob/redis-2.8.3_replay-aof/src/redis-replay-aof.c
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>mongodb 不同数据类型磁盘占用的情况分析</title><link href="/mongo-disk-usage.html" rel="alternate"></link><updated>2014-02-21T11:52:05+08:00</updated><author><name>ning</name></author><id>tag:,2014-02-21:mongo-disk-usage.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id2"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mongolong" id="id3"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mongo中如何存long&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;测试代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
t1 = db.storage_size;

test = function(cnt, obj, index){
    t1.drop()
    t1.ensureIndex(index);

    docs1 = new Array();
    for (var i = 0; i &amp;lt; cnt; ++ i){
        docs1[i] = obj;
    }

    t1.insert(docs1);
    print('db.stats() ' + cnt + ' ' + tojson(obj));
    printjson(t1.stats());
    stats = t1.stats();
    print( 'NOTICE: ' + cnt + ' ' + tojson(obj) + ' record_size:' +  stats[&amp;quot;avgObjSize&amp;quot;]  + ' index_size: ' + stats[&amp;quot;indexSizes&amp;quot;][&amp;quot;x_1&amp;quot;] / 1000 + ' ' +  stats[&amp;quot;indexSizes&amp;quot;][&amp;quot;xxxxxxxxxx_1&amp;quot;] / 1000 );
    tojson(t1.stats());
}

test(1, {x: 1}, {x:1});
test(1, {x: 1024*1024*1024*8}, {x:1});
test(1, {x: ''}, {x:1});
test(1, {x: 'a'}, {x:1});
test(1, {x: 'aaa'}, {x:1});
test(1, {x: '好'}, {x:1});
test(1, {x: '中国'}, {x:1});
test(1, {x: '北京市'}, {x:1});
test(1, {x: '我爱北京天安门'}, {x:1});

print( 'NOTICE: ---------------------------- ' );

test(1000, {x: 1}, {x:1});
test(1000, {x: 1024*1024*1024*8}, {x:1});
test(1000, {x: ''}, {x:1});
test(1000, {x: 'a'}, {x:1});
test(1000, {x: 'aaa'}, {x:1});
test(1000, {x: '好'}, {x:1});
test(1000, {x: '中国'}, {x:1});
test(1000, {x: '北京市'}, {x:1});
test(1000, {x: '我爱北京天安门'}, {x:1});

print( 'NOTICE: ---------------------------- ' );

test(1000, {xxxxxxxxxx: 1}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: 1024*1024*1024*8}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: ''}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: 'a'}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: 'aaa'}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: '好'}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: '中国'}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: '北京市'}, {xxxxxxxxxx:1});
test(1000, {xxxxxxxxxx: '我爱北京天安门'}, {xxxxxxxxxx:1});

...
&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
NOTICE: 1 { &amp;quot;x&amp;quot; : 1 } record_size:36 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : 8589934592 } record_size:36 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;&amp;quot; } record_size:32 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;a&amp;quot; } record_size:32 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;aaa&amp;quot; } record_size:36 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;好&amp;quot; } record_size:36 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;中国&amp;quot; } record_size:36 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;北京市&amp;quot; } record_size:40 index_size: 8.176 NaN
NOTICE: 1 { &amp;quot;x&amp;quot; : &amp;quot;我爱北京天安门&amp;quot; } record_size:52 index_size: 8.176 NaN
NOTICE: ----------------------------
NOTICE: 1000 { &amp;quot;x&amp;quot; : 1 } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : 8589934592 } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;&amp;quot; } record_size:32 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;a&amp;quot; } record_size:32 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaa&amp;quot; } record_size:36.008 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;好&amp;quot; } record_size:36.008 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;中国&amp;quot; } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;北京市&amp;quot; } record_size:40.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;我爱北京天安门&amp;quot; } record_size:52.02 index_size: 57.232 NaN
NOTICE: ----------------------------
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : 1 } record_size:44.012 index_size: NaN 40.88
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : 8589934592 } record_size:44.012 index_size: NaN 40.88
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;&amp;quot; } record_size:40.008 index_size: NaN 32.704
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;a&amp;quot; } record_size:40.008 index_size: NaN 32.704
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;aaa&amp;quot; } record_size:44.012 index_size: NaN 32.704
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;好&amp;quot; } record_size:44.012 index_size: NaN 32.704
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;中国&amp;quot; } record_size:48.032 index_size: NaN 40.88
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;北京市&amp;quot; } record_size:48.032 index_size: NaN 40.88
NOTICE: 1000 { &amp;quot;xxxxxxxxxx&amp;quot; : &amp;quot;我爱北京天安门&amp;quot; } record_size:60 index_size: NaN 57.232
NOTICE: ----------------------------
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;&amp;quot; } record_size:32 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;a&amp;quot; } record_size:32 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aa&amp;quot; } record_size:32 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaa&amp;quot; } record_size:36.008 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaa&amp;quot; } record_size:36.008 index_size: 32.704 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaa&amp;quot; } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaa&amp;quot; } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaa&amp;quot; } record_size:40.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaaa&amp;quot; } record_size:40.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaaaa&amp;quot; } record_size:40.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaaaaa&amp;quot; } record_size:40.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaaaaaa&amp;quot; } record_size:44.012 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;x&amp;quot; : &amp;quot;aaaaaaaaaaaa&amp;quot; } record_size:44.012 index_size: 40.88 NaN
NOTICE: ----------------------------
NOTICE: 1000 { &amp;quot;x&amp;quot; : 1 } record_size:36.008 index_size: 40.88 NaN
NOTICE: 1000 { &amp;quot;xx&amp;quot; : 1 } record_size:36.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxx&amp;quot; : 1 } record_size:36.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxx&amp;quot; : 1 } record_size:36.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxxx&amp;quot; : 1 } record_size:40.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxxxx&amp;quot; : 1 } record_size:40.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxxxxx&amp;quot; : 1 } record_size:40.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxxxxxx&amp;quot; : 1 } record_size:40.008 index_size: NaN NaN
NOTICE: 1000 { &amp;quot;xxxxxxxxx&amp;quot; : 1 } record_size:44.012 index_size: NaN NaN
&lt;/pre&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;整数:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;小整数(1) 和长整数(8589934592) 占用字节数一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;字符串:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;字符串按照4字节对齐: aaa, aaaa, aaaaa, aaaaaa 占用存储一样&lt;/li&gt;
&lt;li&gt;key 和value 都是4字节对齐 &lt;tt class="docutils literal"&gt;所以这里建议key&amp;lt;4字节即可&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;整数vs字符串:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;短字符(0,1,2字节)串占用存储小于 整数, 3字节的字符串存储大小和整数一样, 3字节以上字符串存储大于整数.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;中文:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;每个中文字符(utf8)占用存储3字节.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;key:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;key越长, 占用存储越大, key长度不影响索引大小.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="mongolong"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mongo中如何存long&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;mongo中所有的数字都是都是按照 double (8 byte) 存的,&lt;/p&gt;
&lt;p&gt;int64 的范围中, 2^52 以下表达为double是不损失精度的, 2^52以上, 表达为double就会丢失精度, 所以如果需要存int64, 就需要显示使用NumberLong(&amp;quot;2090845886852&amp;quot;)&lt;/p&gt;
&lt;p&gt;注意int64是带符号的.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category><category term="mongo"></category></entry><entry><title>redis-mgr 中redis实例的迁移</title><link href="/redis-instance-migrate.html" rel="alternate"></link><updated>2014-02-11T10:29:10+08:00</updated><author><name>ning</name></author><id>tag:,2014-02-11:redis-instance-migrate.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;两种方法:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-mgr" id="id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-mgr中如何操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;实现细节:主从同步的步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;两种扩容思路:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;一个是 redis-mgr 中redis实例的迁移, 迁到一个内存大的机器&lt;/li&gt;
&lt;li&gt;另外一个是新搭建集群, 把数据迁移过去.&lt;/li&gt;
&lt;li&gt;和2类似, 把旧集群中某个业务(一定前缀)的数据迁移到新集群.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里说的是思路1&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;两种方法:&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;冷迁移&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;步骤&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;拷贝rdb/aof文件,&lt;/li&gt;
&lt;li&gt;搭建新的master-slave&lt;/li&gt;
&lt;li&gt;更新twemproxy配置 重启&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;问题&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;丢失部分到老master/slave的写&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;热迁移&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;场景:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;集群维护(如部分机器下线)&lt;/li&gt;
&lt;li&gt;集群扩容, 如2*32 实例原来部署在16 机器上,  可以扩容到 32/64 机器上.&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;步骤, 假设老的master/slave 为m,s, 新的为n1, n2&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;搭建n1, n1 SLAVEOF m, 等待同步完成.&lt;/li&gt;
&lt;li&gt;kill s&lt;/li&gt;
&lt;li&gt;kill m, n1成为master.&lt;/li&gt;
&lt;li&gt;搭建n2, n2 SLAVEOF n1&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果服务down了, 起不来(主从都down了起不来的可能性较小), 只能使用冷迁移&lt;/p&gt;
&lt;p&gt;下面是热迁移的方法.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-mgr"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;redis-mgr中如何操作&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;config中写操作步骤:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cluster0 = {
    'migrate' : [
        'host1:port' =&amp;gt; 'host2:port'
    ],
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;直接修改 cluster 中redis 这一节的配置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./bin/deploy.py cluster0 migrate xxxx  xxx
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后选择了3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;实现细节:主从同步的步骤&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过观察 现在 集群中杀掉从库重启后, 通过redis 的INFO命令观察主/从的表现:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;slave 启动, load 本地的aof文件, load完成后:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
used_memory_peak_human CHANGE FROM 2.32G to 2.33G
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;收到sentinel 发来的SLAVEOF命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
master_host CHANGE FROM  to 127.0.0.5
master_port CHANGE FROM  to 22000
master_link_status CHANGE FROM  to down
slave_repl_offset CHANGE FROM  to -1
&lt;/pre&gt;
&lt;p&gt;此时 master 这边的状态变化:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
slave0 CHANGE FROM  to ip=127.0.0.5,port=23000,state=wait_bgsave,offset=0,lag=0
&lt;/pre&gt;
&lt;p&gt;master 开始做一次bgsave.  slave 等待bgsave(wait_bgsave)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;master bgsave 完成, 开始传送数据:&lt;/p&gt;
&lt;p&gt;master:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
slave0 CHANGE FROM ip=127.0.0.5,port=23000,state=wait_bgsave,offset=0,lag=0 to ip=127.0.0.5,port=23000,state=send_bulk,offset=0,lag=0
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;rdb 传送完成后, slave load 获得的数据:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
master_sync_left_bytes CHANGE FROM 47165401 to 0
mem_fragmentation_ratio CHANGE FROM 1.01 to 1.21
used_memory_human CHANGE FROM 2.33G to 18.79M


开始load 新的db:
used_memory_human CHANGE FROM 18.79M to 116.79M
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;load完成:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
aof_rewrite_in_progress CHANGE FROM 0 to 1
master_link_status CHANGE FROM down to up
slave_repl_offset CHANGE FROM -1 to 995178543
used_memory_human CHANGE FROM 2.29G to 2.33G
loading CHANGE FROM 1 to 0
&lt;/pre&gt;
&lt;p&gt;此时:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
slave0 CHANGE FROM ip=127.0.0.5,port=23000,state=send_bulk,offset=0,lag=0 to ip=127.0.0.5,port=23000,state=online,offset=0,lag=1
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;基准数据同步完成的标志&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;master 上看对应slave的 &lt;tt class="docutils literal"&gt;status=online&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;slave 上看 &lt;tt class="docutils literal"&gt;master_link_status = up&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;实时同步跟上的标志&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;从master 上看 &lt;tt class="docutils literal"&gt;lag=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;master 的 &lt;tt class="docutils literal"&gt;master_repl_offset&lt;/tt&gt; : 和slave 的 &lt;tt class="docutils literal"&gt;slave_repl_offset&lt;/tt&gt;  一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;进度信息获取:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;slave 的内存/master 的内存&lt;/li&gt;
&lt;li&gt;db0:keys 在master/slave 上对比.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最终实现了下面命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
migrate src dst : migrate a redis instance to another machine
&lt;/pre&gt;
&lt;p&gt;步骤:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pre_check,
force_src_be_slave,
deploy_dst,
add_dst_as_slave,
cleanup,
sentinel_reset,
update_config,
&lt;/pre&gt;
&lt;p&gt;使用方法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/deploy.py cluster0 migrate cluster0-22000:127.0.0.5:23000:/tmp/r/redis-23000 cluster0-22000:127.0.0.5:50015:/tmp/r/redis-50015
...
2014-02-27 19:21:58,667 [MainThread] [INFO] deploy [redis:127.0.0.5:50015]
2014-02-27 19:21:59,774 [MainThread] [INFO] [redis:127.0.0.5:50015] start ok in 0.19 seconds
2014-02-27 19:21:59,775 [MainThread] [NOTICE] add_dst_as_slave
2014-02-27 19:21:59,790 [MainThread] [INFO] [redis:127.0.0.5:50015] /home/ning/idning-github/redis/src/redis-cli -h 127.0.0.5 -p 50015 SLAVEOF 127.0.0.5 22000
OK
2014-02-27 19:21:59,801 [MainThread] [INFO] [redis:127.0.0.5:50015]: {'used_memory': '342432', 'master_link_status': 'down', 'slave_repl_offset': '-1'}
2014-02-27 19:22:00,811 [MainThread] [INFO] [redis:127.0.0.5:50015]: {'used_memory': '342464', 'master_link_status': 'down', 'slave_repl_offset': '-1'}
2014-02-27 19:22:01,820 [MainThread] [INFO] [redis:127.0.0.5:50015]: {'used_memory': '363456', 'master_link_status': 'up', 'slave_repl_offset': '5998625'}
2014-02-27 19:22:01,821 [MainThread] [NOTICE] cleanup
2014-02-27 19:22:02,156 [MainThread] [INFO] [redis:127.0.0.5:23000] stop ok in 0.11 seconds
2014-02-27 19:22:02,156 [MainThread] [NOTICE] sentinel_reset
2014-02-27 19:22:02,165 [MainThread] [NOTICE] update_config
2014-02-27 19:22:02,166 [MainThread] [INFO] AppendConfig:cluster0['migration'] = []
2014-02-27 19:22:02,166 [MainThread] [INFO] AppendConfig:cluster0['migration'].append('cluster0-22000:127.0.0.5:23000:/tmp/r/redis-23000=&amp;gt;cluster0-22000:127.0.0.5:50015:/tmp/r/redis-50015')
&lt;/pre&gt;
&lt;p&gt;它会修改conf.py, 在末尾增加替换信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cluster0['migration'] = []
cluster0['migration'].append('cluster0-22000:127.0.0.5:23000:/tmp/r/redis-23000=&amp;gt;cluster0-22000:127.0.0.5:50015:/tmp/r/redis-50015')
&lt;/pre&gt;
&lt;p&gt;当下一次用redis-mgr操作这个集群时, 老的instace信息就会被新instance替代:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/deploy.py cluster0 status
2014-02-27 19:24:24,815 [MainThread] [NOTICE] start running: ./bin/deploy.py -v cluster0 status
2014-02-27 19:24:24,820 [MainThread] [NOTICE] status redis
2014-02-27 19:24:24,825 [MainThread] [INFO] [redis:127.0.0.5:22000] uptime 29815 seconds
2014-02-27 19:24:24,831 [MainThread] [INFO] [redis:127.0.0.5:50015] uptime 145 seconds
...
2014-02-27 19:24:24,893 [MainThread] [NOTICE] status master-slave
cluster0-22000 [redis:127.0.0.5:22000] &amp;lt;- 127.0.0.5:50015
cluster0-22001 [redis:127.0.0.5:22001] &amp;lt;- 127.0.0.5:23001
cluster0-22002 [redis:127.0.0.5:22002] &amp;lt;- 127.0.0.5:23002
cluster0-22003 [redis:127.0.0.5:22003] &amp;lt;- 127.0.0.5:23003
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy-benchmark</title><link href="/twemproxy-benchmark.html" rel="alternate"></link><updated>2014-02-10T16:04:26+08:00</updated><author><name>ning</name></author><id>tag:,2014-02-10:twemproxy-benchmark.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id7"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id8"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;具体性能分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在我们用 redis-mgr 部署的集群里面, 使用 benchmark测试:&lt;/p&gt;
&lt;p&gt;以比较典型的部署:&lt;/p&gt;
&lt;p&gt;4台机器,&lt;/p&gt;
&lt;p&gt;每台机器2个redis-master, 2个nutcracker:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
'redis': [
    ('m-01:2200', '/home/ning/redis-sandbox2/redis-2200'), ('m-02:3200', '/home/ning/redis-sandbox2/redis-3200'),
    ('m-01:2201', '/home/ning/redis-sandbox2/redis-2201'), ('m-02:3201', '/home/ning/redis-sandbox2/redis-3201'),
    ('m-02:2202', '/home/ning/redis-sandbox2/redis-2202'), ('m-03:3202', '/home/ning/redis-sandbox2/redis-3202'),
    ('m-02:2203', '/home/ning/redis-sandbox2/redis-2203'), ('m-03:3203', '/home/ning/redis-sandbox2/redis-3203'),
    ('m-03:2204', '/home/ning/redis-sandbox2/redis-2204'), ('m-04:3204', '/home/ning/redis-sandbox2/redis-3204'),
    ('m-03:2205', '/home/ning/redis-sandbox2/redis-2205'), ('m-04:3205', '/home/ning/redis-sandbox2/redis-3205'),
    ('m-04:2206', '/home/ning/redis-sandbox2/redis-2206'), ('m-01:3206', '/home/ning/redis-sandbox2/redis-3206'),
    ('m-04:2207', '/home/ning/redis-sandbox2/redis-2207'), ('m-01:3207', '/home/ning/redis-sandbox2/redis-3207'),
],
'nutcracker': [
    ('m-01:4200', '/home/ning/redis-sandbox2/nutcracker-4200'),
    ('m-01:4201', '/home/ning/redis-sandbox2/nutcracker-4201'),
    ('m-02:4200', '/home/ning/redis-sandbox2/nutcracker-4200'),
    ('m-02:4201', '/home/ning/redis-sandbox2/nutcracker-4201'),
    ('m-03:4200', '/home/ning/redis-sandbox2/nutcracker-4200'),
    ('m-03:4201', '/home/ning/redis-sandbox2/nutcracker-4201'),
    ('m-04:4200', '/home/ning/redis-sandbox2/nutcracker-4200'),
    ('m-04:4201', '/home/ning/redis-sandbox2/nutcracker-4201'),
],
&lt;/pre&gt;
&lt;p&gt;使用如下benchmark:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/deploy.py cluster_sandbox2 nbench 1000000
2014-02-10 16:15:52,758 [MainThread] [INFO] start running: ./bin/deploy.py -v cluster_sandbox2 nbench 1000000
2014-02-10 16:15:52,783 [Thread-1] [INFO] ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2200 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.52 -p 4200 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,799 [Thread-2] [INFO] ssh -n -f ning&amp;#64;10.65.19.26 &amp;quot;cd /home/ning/redis-sandbox2/redis-2202 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.52 -p 4201 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,814 [Thread-3] [INFO] ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2200 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.26 -p 4200 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,831 [Thread-4] [INFO] ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2201 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.26 -p 4201 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,843 [Thread-5] [INFO] ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2201 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.27 -p 4200 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,855 [Thread-6] [INFO] ssh -n -f ning&amp;#64;10.65.19.26 &amp;quot;cd /home/ning/redis-sandbox2/redis-2202 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.27 -p 4201 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,870 [Thread-7] [INFO] ssh -n -f ning&amp;#64;10.65.19.26 &amp;quot;cd /home/ning/redis-sandbox2/redis-2203 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.15.234 -p 4200 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
2014-02-10 16:15:52,887 [Thread-8] [INFO] ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2201 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.15.234 -p 4201 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
&lt;/pre&gt;
&lt;p&gt;想当于起8个worker, 随机登录到这4台机器上, 用redis-benchmark向随机一个nutcracker 发:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bin/redis-benchmark --csv -h 10.65.19.52 -p 4200 -r 100000 -t set,get -n 1000000 -c 100
&lt;/pre&gt;
&lt;p&gt;实际效果, 从redis-master 观察到的 qps 如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_2200  2201  2202  2203  2204  2205  2206  2207
31070 31187 31330 31143 31129 30843 30561 31198 16:10:27
28709 28226 28184 28054 27960 27934 27763 28227 16:10:28
28039 28104 28076 28148 28140 28065 28108 28429 16:10:29
28060 28026 27791 27938 28006 27968 27901 28236 16:10:31
27277 27314 27120 26693 27308 26892 26961 27100 16:10:32
&lt;/pre&gt;
&lt;p&gt;这些redis-benchmark跑完结果如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Warning: Permanently added '10.65.19.26' (RSA) to the list of known hosts.
&amp;quot;SET&amp;quot;,&amp;quot;32128.51&amp;quot;
&amp;quot;GET&amp;quot;,&amp;quot;32101.70&amp;quot;
Warning: Permanently added '10.65.19.26' (RSA) to the list of known hosts.
&amp;quot;SET&amp;quot;,&amp;quot;28050.49&amp;quot;
&amp;quot;GET&amp;quot;,&amp;quot;37503.75&amp;quot;
&lt;/pre&gt;
&lt;p&gt;此时目标机器上nutcracker进程占cpu 50%左右&lt;/p&gt;
&lt;p&gt;总的来说, 单个redis实例, qps只能到2.5w左右, 并不能发挥全部潜力&lt;/p&gt;
&lt;p&gt;如果直接向redis-master 发benchmark:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./bin/deploy.py cluster_sandbox2 mbench 1000000

_2200  2201  2202  2203  2204  2205  2206  2207
65403 52966 72511 59942 56849 67403 73925 73807 16:14:29
59207 59013 72661 59847 62023 70425 73797 73419 16:14:30
61209 64150 72458 59782 61011 71315 73880 57140 16:14:31
61558 69808 63582 57293 58958 71804 73205 70450 16:14:32
61728 70484 60712 61016 58986 64976 73757 73305 16:14:33

Warning: Permanently added '10.65.19.26' (RSA) to the list of known hosts.
&amp;quot;SET&amp;quot;,&amp;quot;63123.34&amp;quot;
&amp;quot;GET&amp;quot;,&amp;quot;72854.44&amp;quot;
&lt;/pre&gt;
&lt;p&gt;看到每个redis实例的qps约7w/s.&lt;/p&gt;
&lt;p&gt;为什么经过了一个nutcracker, pqs就从 7w下降到2.5w呢?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;过程&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;试试单个benchmark进程:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssh -n -f ning&amp;#64;10.65.19.52 &amp;quot;cd /home/ning/redis-sandbox2/redis-2200 &amp;amp;&amp;amp; bin/redis-benchmark --csv -h 10.65.19.52 -p 4200 -r 100000 -t set,get -n 1000000 -c 100 &amp;quot;
&amp;quot;SET&amp;quot;,&amp;quot;70185.29&amp;quot;
&amp;quot;GET&amp;quot;,&amp;quot;67449.08&amp;quot;
每个master上的压力大约9k, 总压力能到7w左右
 2200  2201  2202  2203  2204  2205  2206  2207
 9320  9233  9144  9256  9128  9191  9296  9239 16:19:56
&lt;/pre&gt;
&lt;p&gt;能到7w左右, 是没有问题的, 此时目标机器上nutcracker进程占cpu 90%-99%.&lt;/p&gt;
&lt;p&gt;发现问题, 用自己的nbench命令, 是随机选择一个机器作为压力发起的机器, 存在很大的不均匀现象:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssh -n -f ning&amp;#64;10.65.19.52
ssh -n -f ning&amp;#64;10.65.19.52
ssh -n -f ning&amp;#64;10.65.19.52
ssh -n -f ning&amp;#64;10.65.19.52
ssh -n -f ning&amp;#64;10.65.19.52
ssh -n -f ning&amp;#64;10.65.19.26
ssh -n -f ning&amp;#64;10.65.19.26
ssh -n -f ning&amp;#64;10.65.19.26
&lt;/pre&gt;
&lt;p&gt;因为每台机器上有4个redis, 2个proxy, 再开2个benchmark 进程, 就会打满8个核(总共就8个核)&lt;/p&gt;
&lt;p&gt;如果有3个benchmark进程在同一个机器上, 多余的benchmark进程的压力就上不来 (benchmark进程也占87%左右的cpu)&lt;/p&gt;
&lt;p&gt;原来发benchmark的任务实现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def nbench(self, cnt=100000):
    '''
    run benchmark against nutcracker
    '''
    for s in self.all_nutcracker:
        args = copy.deepcopy(s.args)
        args['cnt'] = cnt
        cmd = TT('bin/redis-benchmark --csv -h $host -p $port -r 100000 -t set,get -n $cnt -c 100 ', args)
        BenchThread(random.choice(self._active_masters()), cmd).start()
&lt;/pre&gt;
&lt;p&gt;修改了一下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def nbench(self, cnt=100000):
    '''
    run benchmark against nutcracker
    '''
    i = 0
    masters= self._active_masters()
    for s in self.all_nutcracker:
        args = copy.deepcopy(s.args)
        args['cnt'] = cnt
        cmd = TT('bin/redis-benchmark --csv -h $host -p $port -r 100000 -t set,get -n $cnt -c 100 ', args)

        BenchThread(masters[i], cmd).start()
        i += 1
        i %= len(masters)
&lt;/pre&gt;
&lt;p&gt;保证均匀的在各个机器上起benchmark进程, 就能得到很高的qps, 和直连差别已经很小:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_2200  2201  2202  2203  2204  2205  2206  2207
63227 62220 63270 63240 61574 62673 62855 62078 16:43:34
63889 64202 64157 63754 63181 63986 64152 64234 16:43:35
66386 66852 66858 66445 66835 66672 66700 67084 16:43:36
&lt;/pre&gt;
&lt;p&gt;此时几个核的压力分布:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PID   USER     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
14903 ning     16   0 18928 1908  708 R 90.4  0.0   6:05.93 nutcracker
14865 ning     16   0 22328 2968  712 R 88.8  0.0  10:53.54 nutcracker
517   ning     16   0 22924 6432  680 S 87.8  0.0   0:09.84 redis-benchmark
519   ning     16   0 22924 6136  680 R 87.1  0.0   0:09.33 redis-benchmark
30753 ning     16   0  118m  82m 1116 S 70.9  0.1  18:31.10 redis-server
10746 ning     16   0  126m  87m 1112 R 70.0  0.1  13:40.51 redis-server
21287 ning     16   0 52196  17m 1132 R 38.6  0.0  12:24.57 redis-server
28560 ning     16   0 55420  17m 1240 R 37.0  0.0  17:27.72 redis-server
&lt;/pre&gt;
&lt;p&gt;可以看出, 满负荷的时候, nutcracker占满cpu, benchmark也很消耗cpu,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;结论&lt;/a&gt;&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;看到的nutcracker导致集群性能下降, 其实是自己的benchmark方法不合理, 客户端性能受限导致&lt;/li&gt;
&lt;li&gt;如果在cpu很空闲的机器上发benchmark, qps应该更高.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;具体性能分析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;火焰图:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy_flame.png" style="width: 600px; height: 145px;" /&gt;
&lt;p&gt;&lt;a class="reference external" href="imgs/twemproxy-flame.svg"&gt;svg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;程序逻辑:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;event_wait&lt;/li&gt;
&lt;li&gt;msg_recv&lt;/li&gt;
&lt;li&gt;msg_send&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;conn_recv: 18.4% , conn_sendv 36.9% 这基本等于调用系统调用read/write 的时间
总共占 55%. 这一部分时间是不可能被优化的了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;event_add_out, event_del_out, 下面都是epoll_ctl, 在不同场景下调用, 大约有4种情况,
占用时间18%左右&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;event_wait 占用 &lt;tt class="docutils literal"&gt;2.9%&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;redis_parse_req &lt;tt class="docutils literal"&gt;2.6%&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;parse_req, 队列的enqueue, dequeue 操作合起来占5%左右.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;其它&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可优化的空间较小了.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>Understanding the Linux Kernel(notes)</title><link href="/ulk.html" rel="alternate"></link><updated>2014-01-05T11:54:31+08:00</updated><author><name>ning</name></author><id>tag:,2014-01-05:ulk.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c1" id="id48"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c1&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id49"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;微内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#user-mode-kernel-mode" id="id50"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;user mode &amp;amp; kernel mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id51"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;内核可重入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id52"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id53"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核和用户内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#zombie" id="id54"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;僵尸进程 (zombie)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#init" id="id55"&gt;1.6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;如果父进程先结束, 子进程会继续, 并且挂到init上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id56"&gt;1.6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;清除僵尸进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id57"&gt;1.6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c2" id="id58"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c2 内存寻址(段页管理)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id59"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;逻辑地址, 线性地址, 物理地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id60"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分段&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id61"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;80286 后的实模式/保护模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id62"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;保护模式中的地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#segment-selectors" id="id63"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器(Segment Selectors)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id64"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;段寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#segment-descriptors" id="id65"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;段描述符(Segment Descriptors)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gdt-ldt" id="id66"&gt;2.2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;GDT/LDT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id67"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器, 段描述符的关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id68"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;分段单元: 从逻辑地址到线性地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linux" id="id69"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分段&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linux-gdt" id="id70"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的GDT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linuxldt" id="id71"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux中的LDT:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id72"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分页&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id73"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;常规分页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id74"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;扩展分页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pae-324g" id="id75"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;PAE: 允许在32位系统上访问大于4G内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id17" id="id76"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;64位架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-cache" id="id77"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Cache&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cache-snooping" id="id78"&gt;2.4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;cache snooping:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tlb-translation-lookaside-buffers" id="id79"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;TLB(Translation Lookaside Buffers)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id18" id="id80"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分页&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#layout" id="id81"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;物理内存Layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-page-table" id="id82"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Page Table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kernel-page-table" id="id83"&gt;2.5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Page Table&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id19" id="id84"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c3-processes" id="id85"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c3 Processes&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#processes-lightweight-processes-and-threads" id="id86"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Processes, Lightweight Processes, and Threads&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pthread" id="id87"&gt;3.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于pthread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#linuxthreads-nptl" id="id88"&gt;3.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;LinuxThreads 和NPTL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id20" id="id89"&gt;3.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-descriptor" id="id90"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Descriptor&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id21" id="id91"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;能有多少个进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pidthread-group" id="id92"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;pid在thread group中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-list" id="id93"&gt;3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;process list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process" id="id94"&gt;3.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Process 资源限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#process-switch" id="id95"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Switch&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-context" id="id96"&gt;3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Context 切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#schedule" id="id97"&gt;3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;schedule()  函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#create-processes" id="id98"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Create Processes&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clone" id="id99"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核底层的clone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clone-fork-and-vfork" id="id100"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;clone( ), fork( ), and vfork( )&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#man-clone" id="id101"&gt;3.4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;man clone(库函数)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#do-fork" id="id102"&gt;3.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;do_fork() 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id22" id="id103"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pdflush" id="id104"&gt;3.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pdflush&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id23" id="id105"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;进程0 &amp;amp; 进程1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#destorying-processes" id="id106"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Destorying Processes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c4-interrupts-and-exceptions" id="id107"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 Interrupts and Exceptions&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupts-and-exceptions" id="id108"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupts and Exceptions&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupt" id="id109"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#interrupt-handling" id="id110"&gt;4.1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#irqs-interrupt-requests" id="id111"&gt;4.1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQs (Interrupt ReQuests)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pic" id="id112"&gt;4.1.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;老的PIC 的硬件结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pic-the-advanced-programmable-interrupt-controller-apic" id="id113"&gt;4.1.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;新的PIC 的硬件结构 The Advanced Programmable Interrupt Controller (APIC)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#exceptions" id="id114"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#idt" id="id115"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;中断描述符表IDT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nested-execution-of-exception-and-interrupt-handlers" id="id116"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Nested Execution of Exception and Interrupt Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#initializing-the-interrupt-descriptor-table" id="id117"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Initializing the Interrupt Descriptor Table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#exception-handling" id="id118"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id24" id="id119"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt Handling(硬件产生的)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#irq" id="id120"&gt;4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQ在多处理器系统上的分发&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cpuirq" id="id121"&gt;4.5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;CPU的IRQ亲和力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id25" id="id122"&gt;4.5.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;例子:网卡多队列的中断绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id26" id="id123"&gt;4.5.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;把进程绑在核上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id27" id="id124"&gt;4.5.1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;网卡多队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id28" id="id125"&gt;4.5.1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;千兆网卡多队列&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id29" id="id126"&gt;4.5.1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;是否支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id30" id="id127"&gt;4.5.1.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;开启多队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#proc-softirqs" id="id128"&gt;4.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;/proc/softirqs&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mpstat" id="id129"&gt;4.5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mpstat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vmstat" id="id130"&gt;4.5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;vmstat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#softirqs-and-tasklets" id="id131"&gt;4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Softirqs and Tasklets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#work-queues" id="id132"&gt;4.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Work Queues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#returning-from-interrupts-and-exceptions" id="id133"&gt;4.8&amp;nbsp;&amp;nbsp;&amp;nbsp;Returning from Interrupts and Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c5-kernel-synchronization" id="id134"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 Kernel Synchronization&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-the-kernel-services-requests" id="id135"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;How the Kernel Services Requests&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id31" id="id136"&gt;5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核抢占&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronization-primitives" id="id137"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronization Primitives(同步原语)&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cpu" id="id138"&gt;5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;每CPU变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id32" id="id139"&gt;5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;原子操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id33" id="id140"&gt;5.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障&amp;amp;内存屏障&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#optimization-barrier" id="id141"&gt;5.2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障(optimization barrier) 原语保证编译程序不会混淆原语前后的汇编指令.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id34" id="id142"&gt;5.2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;内存屏障确保原语之后的操作开始执行之前, 原语之前的操作已完成.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id35" id="id143"&gt;5.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id36" id="id144"&gt;5.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;读/写自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id37" id="id145"&gt;5.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;顺序锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rcu" id="id146"&gt;5.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;读-拷贝-更新 (RCU通过指针而不是锁)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id38" id="id147"&gt;5.2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;信号量&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#completion" id="id148"&gt;5.2.8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;补充原语(completion)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id39" id="id149"&gt;5.2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;本地中断禁止&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id40" id="id150"&gt;5.2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;本地软中断禁止&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronizing-accesses-to-kernel-data-structures" id="id151"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronizing Accesses to Kernel Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#examples-of-race-condition-prevention" id="id152"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Examples of Race Condition Prevention&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c6-timing-measurements" id="id153"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;c6 Timing Measurements&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#clock-and-timer-circuits" id="id154"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Clock and Timer Circuits (几种硬件计时器)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-linux-timekeeping-architecture" id="id155"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Linux Timekeeping Architecture&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id41" id="id156"&gt;6.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;时钟中断时处理&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id42" id="id157"&gt;6.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;系统负载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id43" id="id158"&gt;6.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;监管内核代码&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#readprofiler-hot-spot" id="id159"&gt;6.2.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;readprofiler, 用于确定内核热点(hot spot).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#oprofile" id="id160"&gt;6.2.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;oprofile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id44" id="id161"&gt;6.2.1.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;检测死锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id45" id="id162"&gt;6.2.1.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;蒙特卡洛:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-the-time-and-date" id="id163"&gt;6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating the Time and Date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-system-statistics" id="id164"&gt;6.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating System Statistics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#software-timers-and-delay-functions" id="id165"&gt;6.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Software Timers and Delay Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-timing-measurements" id="id166"&gt;6.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Timing Measurements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c7-process-scheduling" id="id167"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;c7 Process Scheduling&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#scheduling-policy" id="id168"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Scheduling Policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-scheduling-algorithm" id="id169"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Scheduling Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#data-structures-used-by-the-scheduler" id="id170"&gt;7.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Data Structures Used by the Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#functions-used-by-the-scheduler-schedule" id="id171"&gt;7.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Functions Used by the Scheduler(schedule)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id46" id="id172"&gt;7.5&amp;nbsp;&amp;nbsp;&amp;nbsp;多处理器系统中 执行队列的平衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-scheduling" id="id173"&gt;7.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Scheduling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c8-memory-management" id="id174"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 Memory Management&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#page-frame-management" id="id175"&gt;8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Frame Management&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#numa" id="id176"&gt;8.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;非一致内存访问(NUMA)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-area-management" id="id177"&gt;8.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Area Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#noncontiguous-memory-area-management" id="id178"&gt;8.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Noncontiguous Memory Area Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c9-process-address-space" id="id179"&gt;9&amp;nbsp;&amp;nbsp;&amp;nbsp;c9. Process Address Space&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-processs-address-space" id="id180"&gt;9.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Process’s Address Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-memory-descriptor" id="id181"&gt;9.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Memory Descriptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-regions" id="id182"&gt;9.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Regions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#page-fault-exception-handler" id="id183"&gt;9.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Fault Exception Handler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-and-deleting-a-process-address-space" id="id184"&gt;9.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating and Deleting a Process Address Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#managing-the-heap" id="id185"&gt;9.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing the Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c10-system-calls" id="id186"&gt;10&amp;nbsp;&amp;nbsp;&amp;nbsp;c10 System Calls&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#posix-apis-and-system-calls" id="id187"&gt;10.1&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX APIs and System Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-call-handler-and-service-routines" id="id188"&gt;10.2&amp;nbsp;&amp;nbsp;&amp;nbsp;System Call Handler and Service Routines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#entering-and-exiting-a-system-call" id="id189"&gt;10.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Entering and Exiting a System Call&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#parameter-passing" id="id190"&gt;10.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Parameter Passing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kernel-wrapper-routines" id="id191"&gt;10.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Wrapper Routines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c11-signals" id="id192"&gt;11&amp;nbsp;&amp;nbsp;&amp;nbsp;c11. Signals&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-role-of-signals" id="id193"&gt;11.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of Signals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#generating-a-signal" id="id194"&gt;11.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Generating a Signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#delivering-a-signal" id="id195"&gt;11.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Delivering a Signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-calls-related-to-signal-handling" id="id196"&gt;11.4&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Signal Handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c12-the-virtual-filesystem" id="id197"&gt;12&amp;nbsp;&amp;nbsp;&amp;nbsp;c12 The Virtual Filesystem&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-role-of-the-virtual-filesystem-vfs" id="id198"&gt;12.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of the Virtual Filesystem (VFS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vfs-data-structures" id="id199"&gt;12.2&amp;nbsp;&amp;nbsp;&amp;nbsp;VFS Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#filesystem-types" id="id200"&gt;12.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#filesystem-handling" id="id201"&gt;12.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pathname-lookup" id="id202"&gt;12.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Pathname Lookup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementations-of-vfs-system-calls" id="id203"&gt;12.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementations of VFS System Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#file-locking" id="id204"&gt;12.7&amp;nbsp;&amp;nbsp;&amp;nbsp;File Locking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c13-i-o-architecture-and-device-drivers" id="id205"&gt;13&amp;nbsp;&amp;nbsp;&amp;nbsp;c13. I/O Architecture and Device Drivers&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#i-o-architecture" id="id206"&gt;13.1&amp;nbsp;&amp;nbsp;&amp;nbsp;I/O Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-device-driver-model" id="id207"&gt;13.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Device Driver Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#device-files" id="id208"&gt;13.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#device-drivers" id="id209"&gt;13.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#character-device-drivers" id="id210"&gt;13.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Character Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c14-block-device-drivers" id="id211"&gt;14&amp;nbsp;&amp;nbsp;&amp;nbsp;c14. Block Device Drivers&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block-devices-handling" id="id212"&gt;14.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Devices Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-generic-block-layer" id="id213"&gt;14.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Generic Block Layer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-i-o-scheduler" id="id214"&gt;14.3&amp;nbsp;&amp;nbsp;&amp;nbsp;The I/O Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block-device-drivers" id="id215"&gt;14.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Device Drivers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#opening-a-block-device-file" id="id216"&gt;14.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Opening a Block Device File&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c15-the-page-cache" id="id217"&gt;15&amp;nbsp;&amp;nbsp;&amp;nbsp;c15. The Page Cache&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-page-cache" id="id218"&gt;15.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#storing-blocks-in-the-page-cache" id="id219"&gt;15.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Storing Blocks in the Page Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#writing-dirty-pages-to-disk" id="id220"&gt;15.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Writing Dirty Pages to Disk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-sync-fsync-and-fdatasync-system-calls" id="id221"&gt;15.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The sync( ), fsync( ), and fdatasync() System Calls&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c16-accessing-files" id="id222"&gt;16&amp;nbsp;&amp;nbsp;&amp;nbsp;c16. Accessing Files&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reading-and-writing-a-file" id="id223"&gt;16.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Reading and Writing a File&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#memory-mapping" id="id224"&gt;16.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#direct-i-o-transfers" id="id225"&gt;16.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Direct I/O Transfers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#asynchronous-i-o" id="id226"&gt;16.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Asynchronous I/O&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c17-page-frame-reclaiming" id="id227"&gt;17&amp;nbsp;&amp;nbsp;&amp;nbsp;c17. Page Frame Reclaiming&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-page-frame-reclaiming-algorithm" id="id228"&gt;17.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Frame Reclaiming Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reverse-mapping" id="id229"&gt;17.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Reverse Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#implementing-the-pfra" id="id230"&gt;17.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing the PFRA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#swapping" id="id231"&gt;17.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Swapping&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c18-the-ext2-and-ext3-filesystems" id="id232"&gt;18&amp;nbsp;&amp;nbsp;&amp;nbsp;c18. The Ext2 and Ext3 Filesystems&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#general-characteristics-of-ext2" id="id233"&gt;18.1&amp;nbsp;&amp;nbsp;&amp;nbsp;General Characteristics of Ext2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-disk-data-structures" id="id234"&gt;18.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Disk Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-memory-data-structures" id="id235"&gt;18.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Memory Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-the-ext2-filesystem" id="id236"&gt;18.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating the Ext2 Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ext2-methods" id="id237"&gt;18.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#managing-ext2-disk-space" id="id238"&gt;18.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing Ext2 Disk Space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-ext3-filesystem" id="id239"&gt;18.7&amp;nbsp;&amp;nbsp;&amp;nbsp;The Ext3 Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c19-process-communication" id="id240"&gt;19&amp;nbsp;&amp;nbsp;&amp;nbsp;c19. Process Communication&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pipes" id="id241"&gt;19.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Pipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fifos" id="id242"&gt;19.2&amp;nbsp;&amp;nbsp;&amp;nbsp;FIFOs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-v-ipc" id="id243"&gt;19.3&amp;nbsp;&amp;nbsp;&amp;nbsp;System V IPC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#posix-message-queues" id="id244"&gt;19.4&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX Message Queues&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#c20-program-execution" id="id245"&gt;20&amp;nbsp;&amp;nbsp;&amp;nbsp;c20. Program Execution&lt;/a&gt;&lt;ul class="auto-toc"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#executable-files" id="id246"&gt;20.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#executable-formats" id="id247"&gt;20.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Formats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#execution-domains" id="id248"&gt;20.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Execution Domains&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-exec-functions" id="id249"&gt;20.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The exec Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id47" id="id250"&gt;21&amp;nbsp;&amp;nbsp;&amp;nbsp;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
内存 c2, c8, c9
进程 c3, c7
中断 c4,
IO: 12, 13, 14, 15, 16, 17, 18
其它: 5, 6, 10, 11, 19, 20
&lt;/pre&gt;
&lt;p&gt;内存和io是重点, 没有网络中, 如epoll的实现.&lt;/p&gt;
&lt;p&gt;c1-c9看的比较认真, 有笔记, 后面看的比较粗.&lt;/p&gt;
&lt;div class="section" id="c1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id48"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;c1&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;微内核&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;微内核vs巨内核 微内核慢，linux就是微内核&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="user-mode-kernel-mode"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id50"&gt;1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;user mode &amp;amp; kernel mode&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;两个模式是cpu提供的功能。应该理解为在两个模式下cpu可以使用的指令是不同的。或者说可以访问的内存区是不同的。&lt;/li&gt;
&lt;li&gt;用户程序调用系统调用，然后系统调用的使用cpu的指令进行切换到内核模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt; : 这是同一个进程, 一个进程可以运行在用户模式也可以在内核模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_mode.png" /&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_mode_2.png" /&gt;
&lt;p&gt;这个图很好的解释了什么情况下会从user mode 进入kernel mode:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;user mode 程序调用系统调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;时钟中断(此时内核会调用scheduler, 找一个程序来run)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;设备中断(此时内核处理设备响应)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如对读磁盘操作, 这里把磁盘缓冲区的内容读到内存&lt;/li&gt;
&lt;li&gt;对写磁盘操作, 这里检查写是否成功.&lt;/li&gt;
&lt;li&gt;接下来可以调用scheduler, 把那个Process 唤起就是 scheduler 的问题了&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;内存越界等(Excption)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id51"&gt;1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;内核可重入&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核是可重入的, 意思就是说, 在中断中处理中, 可以再接受中断(某些中断当然是不可重入的)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如oom killer&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核和用户内存&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在的理解是这样的:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk_user_and_kernel_space.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="zombie"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id54"&gt;1.6&amp;nbsp;&amp;nbsp;&amp;nbsp;僵尸进程 (zombie)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这样产生的:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;父进程fork后, 不去wait它(比如父进程在做sleep() 或其它操作, 总之就是没有调用wait()). 这也就产生了僵尸进程&lt;/li&gt;
&lt;li&gt;如果父进程挂掉, 这个进程就会被挂到init(1), init总是会wait() 它, 所以不会产生僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码, 子进程退出后, 父进程没去wait它:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int main(){
    int pid = fork();
    if(pid== 0) {
        fprintf(stderr, &amp;quot;child pid: %d\n&amp;quot;, getpid());
        sleep(1);
        fprintf(stderr, &amp;quot;child finish\n&amp;quot;);
    } else {                //Parent
        fprintf(stderr, &amp;quot;parent pid: %d\n&amp;quot;, getpid());
        sleep(100);
        fprintf(stderr, &amp;quot;parent finish\n&amp;quot;);
    }
    return 0;
}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
$ ./a.out
parent pid: 1221
child pid: 1222
child finish
&lt;/pre&gt;
&lt;p&gt;此时pstree看, 子进程挂到 父进程, 状态已经变成Z:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
init(1)-+-NetworkManager(1022)-+-dhclient(28101)
        |                      |-bash(31597)---a.out(1221)---a.out(1222)

$ ps  -elF
1 Z ning      1222  1221  0  80   0 -     0 exit       0   1 13:16 pts/1    00:00:00 [a.out] &amp;lt;defunct&amp;gt;
&lt;/pre&gt;
&lt;div class="section" id="init"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id55"&gt;1.6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;如果父进程先结束, 子进程会继续, 并且挂到init上&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int main(){
    int pid = fork();
    if(pid== 0) {
        fprintf(stderr, &amp;quot;child pid: %d\n&amp;quot;, getpid());
        sleep(2*100);
        fprintf(stderr, &amp;quot;child finish\n&amp;quot;);
    } else {                //Parent
        fprintf(stderr, &amp;quot;parent pid: %d\n&amp;quot;, getpid());
        sleep(1);
        fprintf(stderr, &amp;quot;parent finish\n&amp;quot;);
    }
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;父进程先退出, 子进程后退出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./a.out
parent pid: 928
child pid: 929
parent finish
&lt;/pre&gt;
&lt;p&gt;此时pstree看, 子进程已经挂到 init上了, 但是这时状态不是Z:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
init(1)-+-NetworkManager(1022)-+-dhclient(28101)
        |                      `-{NetworkManager}(1851)
        |-a.out(929)

$ ps  -elF
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  5961 poll_s  1888   0 Jan03 ?        00:00:01 /sbin/init
1 S ning       929     1  0  80   0 -  2936 hrtime   320   3 13:11 pts/1    00:00:00 ./a.out
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id56"&gt;1.6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;清除僵尸进程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;僵尸进程本身是不能被kill的(因为本来就是死的):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
0 S ning     20696 20023  0  80   0 -   969 hrtime   428   1 08:53 pts/16   00:00:00 ./a.out
1 Z ning     20697 20696  0  80   0 -     0 exit       0   3 08:53 pts/16   00:00:00 [a.out] &amp;lt;defunct&amp;gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ kill 20697                                           (不能kill掉)
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
0 S ning     20696 20023  0  80   0 -   969 hrtime   428   1 08:53 pts/16   00:00:00 ./a.out
1 Z ning     20697 20696  0  80   0 -     0 exit       0   3 08:53 pts/16   00:00:00 [a.out] &amp;lt;defunct&amp;gt;
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ kill 20696                                           (解决方法是kill掉附进程)
ning&amp;#64;ning-laptop:~/idning/langtest/c/zombie-processes$ ps -elF | grep a.out
nothing
&lt;/pre&gt;
&lt;p&gt;解决方法是kill掉父进程, 这样子进程会挂到 init, 并被init wait()&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id57"&gt;1.6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;注意&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;父进程不一定非要调用wait, 忽略 &lt;tt class="docutils literal"&gt;SIGCHILD&lt;/tt&gt; 也可以(wait就是等待 &lt;tt class="docutils literal"&gt;SIGCHILD&lt;/tt&gt; ) 参考:&lt;/p&gt;
&lt;p&gt;引用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
僵尸进程简而言之就是：子进程退出时，父进程并未对其发出的SIGCHILD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵死进程。

在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵死进程，无法正常结束，此时即使是root身份kill -9也不能杀死僵死进程。补救办法是杀死僵尸进程的父进程(僵死进程的父进程必然存在)，僵死进程成为&amp;quot;孤儿进程&amp;quot;，过继给1号进程init，init始终会负责清理僵死进程。

在unix术语中，一个已经终止但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程称为僵尸进程(zombie)。
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id58"&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;c2 内存寻址(段页管理)&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;段主要是 隔离的作用!&lt;/li&gt;
&lt;li&gt;linux里面用的段主要是4个:
用户代码段, 用户数据段, 内核代码段, 内核数据段&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id59"&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;逻辑地址, 线性地址, 物理地址&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
+-----------------+               +-----------------+            +-----------------+
|                 |   分段单元    |                 |  分页单元  |                 |
|  逻辑地址       |  ----------&amp;gt;  |     线性地址    | ---------&amp;gt; |    物理地址     |
|                 |               |                 |            |                 |
+-----------------+               +-----------------+            +-----------------+
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id60"&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分段&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id61"&gt;2.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;80286 后的实模式/保护模式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一般系统刚启动的时候是在实模式,&lt;/p&gt;
&lt;p&gt;正常运行中, 是保护模式,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id62"&gt;2.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;保护模式中的地址&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;逻辑地址是段选择器和offset的组合:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="segment-selectors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id63"&gt;2.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器(Segment Selectors)&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
+------------------+                +----------------+
|                  |                |                |
|    段选择器      |       +        |   offset       |
|                  |                |                |
+------------------+                +----------------+
&lt;/pre&gt;
&lt;p&gt;段选择器有16 bit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
15                                        3   2   1  0
+-------------------------------------------+---+------+
|                   index                   |TI | RPL  |
+-------------------------------------------+---+------+

TI: Table Indicator
RPL Requestor Privilege Level
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id64"&gt;2.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;段寄存器&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在cpu中有专门设置的段寄存器, 用于存放段选择器:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cs: 代码段 (code)
    有两个bit表示 CPU Privilege Level(CPL)   &amp;lt;Linux 只用了0和3 (内核态/用户态)&amp;gt;
ss: 栈段   (stack)
ds: 数据段 (全局和static数据)
es
fs
gs
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="segment-descriptors"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id65"&gt;2.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;段描述符(Segment Descriptors)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;存放在 &lt;tt class="docutils literal"&gt;GDT/LDT&lt;/tt&gt; 中.&lt;/p&gt;
&lt;p&gt;8byte的段描述符:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-Segment-Descriptors.png" /&gt;
&lt;div class="section" id="gdt-ldt"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id66"&gt;2.2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;GDT/LDT&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
GDT: 通常一个系统只有一个
LDT: 如果每个进程需要额外的段
&lt;/pre&gt;
&lt;p&gt;gdtr寄存器: 指向内存中存放的GDT
ldtr集群器: 指向内存中存放的LDT&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id67"&gt;2.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;段选择器, 段描述符的关系&lt;/a&gt;&lt;/h4&gt;
&lt;img alt="" src="/imgs/ulk-Segment-Descriptors-and-Segment-Selector.png" /&gt;
&lt;p&gt;段选择器的字段:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;index:&lt;/th&gt;&lt;td class="field-body"&gt;Identifies the Segment Descriptor entry contained in the GDT or in the LDT (described further in the text following this table).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;TI:&lt;/th&gt;&lt;td class="field-body"&gt;Table Indicator: specifies whether the Segment Descriptor is included in the GDT (TI = 0) or in the LDT (TI = 1).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RPL:&lt;/th&gt;&lt;td class="field-body"&gt;Requestor Privilege Level: specifies the Current Privilege Level of the CPU when the corresponding Segment Selector is loaded into the cs register; it also may be used to selectively weaken the processor privilege level when accessing data segments (see Intel documentation for details).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;计算:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gdtr 中存放的地址 +  段选择器中index*8 = 段描述符的位置.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id68"&gt;2.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;分段单元: 从逻辑地址到线性地址&lt;/a&gt;&lt;/h4&gt;
&lt;img alt="" src="/imgs/ulk-Translating-a-logical-address.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id69"&gt;2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分段&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为分段和分页功能上比较重复, Linux实现中对分段用的很少&lt;/p&gt;
&lt;p&gt;Linux 2.6 只在80x86架构下使用分段, 只使用4个段:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-linux-segment.png" /&gt;
&lt;p&gt;这4个段的线性地址空间都是 &lt;tt class="docutils literal"&gt;0 - &lt;span class="pre"&gt;2^32-1&lt;/span&gt;&lt;/tt&gt; , 意味着&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;所有的进程(不管用户模式还是内核模式) 都使用相同的线性地址空间.&lt;/li&gt;
&lt;li&gt;因为开始于0x0000000, 线性地址 = 逻辑地址是一样的&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="linux-gdt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id70"&gt;2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的GDT&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;单核系统只有一个GDT&lt;/li&gt;
&lt;li&gt;多核系统, 对每个核有一个GDT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each GDT includes 18 segment descriptors and 14 null, unused, or reserved entries&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linuxldt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id71"&gt;2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux中的LDT:&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;User Application 不使用LDT, 大家共享一个 &lt;tt class="docutils literal"&gt;default_ldt&lt;/tt&gt;, 可以用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;modify_ldt()系统调用&lt;/span&gt;&lt;/tt&gt; 来修改ldt, (Wine使用, 模拟window)&lt;/p&gt;
&lt;p&gt;man modify_ldt:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;sys/types.h&amp;gt;
int modify_ldt(int func, void *ptr, unsigned long bytecount);

DESCRIPTION:
modify_ldt()  reads or writes the local descriptor table (ldt) for a process.  The ldt is a per-process memory management table used by the i386 processor.
For more information on this table, see an Intel 386 processor handbook.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id72"&gt;2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;硬件中的分页&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;检查对页的访问是否有权限, 如果没有, 产生PageFault exception&lt;/p&gt;
&lt;p&gt;page frame: 物理概念(physical page)&lt;/p&gt;
&lt;p&gt;80x86: 控制寄存器cr0中的PG标志控制是否使用硬件提供的分页机制:&lt;/p&gt;
&lt;p&gt;PG = 0: linear addresses 就是 physical addresses
PG = 1: 使用页表分页.&lt;/p&gt;
&lt;div class="section" id="id15"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id73"&gt;2.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;常规分页&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;4KB 的page, 两极页表:&lt;/p&gt;
&lt;p&gt;如果用一级页表, 当用户稀疏使用了4G线性地址空间，比如只用了0x00000000和0xFFFFFFFF, 就需要 2^20个页表项 (2^32/4k) 需要4M内存.
如果用2级页表, 如果用户实际用的内存较少, 页表所需空间就较小&lt;/p&gt;
&lt;p&gt;当然, 如果一个进程使用全部4G空间, 那么一级页表和两极页表都需要占用相同的空间, (二级页表还更多些)&lt;/p&gt;
&lt;p&gt;分页机制示意图:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging.png" /&gt;
&lt;p&gt;每个进程都必须有自己的 &lt;tt class="docutils literal"&gt;Page Dirrectory&lt;/tt&gt;, 但是只需要部分的 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; .&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Page Dirrectory&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 都是大小都是1024个页表条目. 页表条目包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;Present flag&lt;/tt&gt; : 是否在内存中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;20bit物理地址&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Dirty flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Read/Write flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;User/Supervisor&lt;/tt&gt; flag (注意, 只有两种权限级别, 不像段映射, 有4个权限级别)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;标志为0时, 只允许 CPL &amp;lt; 3 的时候访问(在Linux里面就是内核态)&lt;/li&gt;
&lt;li&gt;标志为1时, 总是允许访问.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id74"&gt;2.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;扩展分页&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;允许4M的 &lt;tt class="docutils literal"&gt;page frame&lt;/tt&gt;:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-extended-paging.png" /&gt;
&lt;p&gt;相当于省掉了 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 这一层.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pae-324g"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id75"&gt;2.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;PAE: 允许在32位系统上访问大于4G内存&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Physical Address Extension&lt;/p&gt;
&lt;p&gt;从 &lt;tt class="docutils literal"&gt;Pentium Pro&lt;/tt&gt; 开始, Intel 把地址总线宽度从 32 升级到36, 允许访问2^36=64G内存.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PAE is activated by setting the Physical Address Extension (PAE) flag in the cr4 con- trol register.
增加了:
A new level of Page Table called the Page Directory Pointer Table (PDPT)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id76"&gt;2.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;64位架构&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;64位是 256 TB 地址空间&lt;/p&gt;
&lt;p&gt;64位中, 一般使用48位, 如果依然使用4KB的页, 还剩下48-12=36 bit, 这放在两级页表中, &lt;tt class="docutils literal"&gt;Page Directory&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;Page Table&lt;/tt&gt; 就分别要有2^18条目, 得占用1M空间.&lt;/p&gt;
&lt;p&gt;所以, 64位系统中, 一般使用多级页表:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging-level.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-cache"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id77"&gt;2.4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Cache&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Today’s microprocessors have clock rates of several gigahertz, while dynamic RAM (DRAM) chips have access times in the range of hundreds of clock cycles.&lt;/p&gt;
&lt;p&gt;L1 cache, L2 cache 之类&lt;/p&gt;
&lt;div class="section" id="cache-snooping"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id78"&gt;2.4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;cache snooping:&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;在多核架构中, 每个核有自己的cache, 一个核在写数据到cache时, 需要确保另一个核没有对应着一块内存的cache.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="tlb-translation-lookaside-buffers"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id79"&gt;2.4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;TLB(Translation Lookaside Buffers)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;80x86 中: to speed up linear address translation&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id18"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id80"&gt;2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux 中的分页&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对32位架构和64位架构使用同样的分页模型&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2.6.10: 3级页表&lt;/li&gt;
&lt;li&gt;2.6.11: 4级页表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4级页表:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-paging-level-in-linux.png" /&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于32位系统: Linux直接把Upper Dirrectory 和Middle Directory 设为只有1个条目, 这样就可以变为2级页表.&lt;/li&gt;
&lt;li&gt;对于32位+PAE的系统: Linux使用3级页表,&lt;/li&gt;
&lt;li&gt;对于64位系统, 使用3或4级页表. (见前面的表格)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="layout"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id81"&gt;2.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;物理内存Layout&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Linux 内核通常在RAM的0x00100000(from the second megabyte)&lt;/p&gt;
&lt;p&gt;因为第一M通常是BIOS,&lt;/p&gt;
&lt;p&gt;启动时, 内核向BIOS查询可用物理内存大小:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
In the early stage of the boot sequence (see Appendix A), the kernel queries the BIOS and learns the size of the physical memory.
&lt;/pre&gt;
&lt;p&gt;之后内核调用 &lt;tt class="docutils literal"&gt;machine_specific_memory_setup()&lt;/tt&gt; 构造可用空间的一个列表, 例如&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Start      End        Type
0x00000000 0x0009ffff Usable
0x000f0000 0x000fffff Reserved
0x00100000 0x07feffff Usable
0x07ff0000 0x07ff2fff ACPI data
0x07ff3000 0x07ffffff ACPI NVS
0xffff0000 0xffffffff Reserved
&lt;/pre&gt;
&lt;p&gt;arch/i386/kernel/setup.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void __init setup_arch(char **cmdline_p)
{

    print_memory_map(machine_specific_memory_setup());
    max_low_pfn = setup_memory();

    paging_init();

    register_memory();
}
&lt;/pre&gt;
&lt;p&gt;内核加载后, 一般占3M空间, 也分为代码段, 数据段.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="process-page-table"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id82"&gt;2.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Page Table&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;注意这里说的是线性地址空间:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Linear addresses from 0x00000000 to 0xbfffffff can be addressed when the process runs in either User or Kernel Mode.&lt;/li&gt;
&lt;li&gt;Linear addresses from 0xc0000000 to 0xffffffff can be addressed only when the process runs in Kernel Mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel-page-table"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id83"&gt;2.5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Page Table&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The kernel maintains a set of page tables for its own use, rooted at a so-called master kernel Page Global Directory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id84"&gt;2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;小结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 中所有的进程(不管用户模式还是内核模式) 都使用相同的线性地址空间: &lt;tt class="docutils literal"&gt;0 - &lt;span class="pre"&gt;2^32-1&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c3-processes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id85"&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;c3 Processes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Processes are often called tasks or threads in the Linux source code.&lt;/p&gt;
&lt;p&gt;LWP: Lightweight Processes, Linux 的多线程就是用LWP实现的.&lt;/p&gt;
&lt;div class="section" id="processes-lightweight-processes-and-threads"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id86"&gt;3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Processes, Lightweight Processes, and Threads&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;老的Unix: 进程通过fork产生新进程, 共享代码段, 有不同的数据段(Copy on Write)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不支持multithreaded, 内核看到的都是进程, 线程的概念是在用户态实现的(pthread)&lt;/li&gt;
&lt;li&gt;老的pthread库是用这种实现.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;新的Unix: 直接支持多线程,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;user programs having many relatively independent execution flows sharing a large portion of the application data structures&lt;/li&gt;
&lt;li&gt;In such systems, a process is composed of several user threads&lt;/li&gt;
&lt;li&gt;Linux 用 &lt;tt class="docutils literal"&gt;Lightweight processes&lt;/tt&gt; 支持multithreaded&lt;/li&gt;
&lt;li&gt;Examples of POSIX-compliant pthread libraries that use Linux’s lightweight processes are LinuxThreads, Native POSIX Thread Library (NPTL), and IBM’s Next Generation Posix Threading Package (NGPT).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In Linux a thread group is basically a set of lightweight processes that implement a multithreaded application and act as a whole with regards to some system calls such as getpid(), kill(), and _exit().&lt;/p&gt;
&lt;div class="section" id="pthread"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id87"&gt;3.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;关于pthread&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
The code below comes from &amp;quot;Advanced Programing in Unix Environment&amp;quot;, it creates a new thread, and prints the process id and thread id for main and new threads.

In the book, it said that in linux, the output of this code would show that two threads have different process ids, because pthread uses lightweight process to emulate thread. But when I ran this code in Ubuntu 12.04, it has kernel 3.2, printed the same pid.

so, does the new linux kernel change the internal implementation of pthread?

#include &amp;quot;apue.h&amp;quot;
#include &amp;lt;pthread.h&amp;gt;

pthread_t ntid;

void printids(const char *s) {
  pid_t     pid;
  pthread_t tid;
  pid = getpid();
  tid = pthread_self();
  printf(&amp;quot;%s pid %u tid %u (0x%x)\n&amp;quot;,
         s, (unsigned int)pid, (unsigned int)tid, (unsigned int)tid);
}

void *thread_fn(void* arg) {
  printids(&amp;quot;new thread: &amp;quot;);
  return (void *)0;
}

int main(void) {
  int err;
  err = pthread_create(&amp;amp;ntid, NULL, thread_fn, NULL);
  if (err != 0)
    err_quit(&amp;quot;can't create thread: %s\n&amp;quot;, strerror(err));
  printids(&amp;quot;main thread: &amp;quot;);
  sleep(1);
  return 0;
}
&lt;/pre&gt;
&lt;p&gt;On Linux pthread uses the clone syscall with a special flag CLONE_THREAD.&lt;/p&gt;
&lt;p&gt;See the documentation of clone syscall:&lt;/p&gt;
&lt;p&gt;CLONE_THREAD (since Linux 2.4.0-test8):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
If CLONE_THREAD is set, the child is placed in the same thread group as the calling process. To make the remainder of the discussion of CLONE_THREAD more readable, the term &amp;quot;thread&amp;quot; is used to refer to the processes within a thread group.

Thread groups were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that share a single PID. Internally, this shared PID is the so-called thread group identifier (TGID) for the thread group. Since Linux 2.4, calls to getpid(2) return the TGID of the caller.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="linuxthreads-nptl"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id88"&gt;3.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;LinuxThreads 和NPTL&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一个系统里面的pthread实现只会是两种之一, 可以用下面这个命令查询本系统使用的pthread版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
getconf GNU_LIBPTHREAD_VERSION
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id89"&gt;3.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;参考&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads/"&gt;https://computing.llnl.gov/tutorials/pthreads/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可以参考这本书: &lt;a class="reference external" href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_47.html"&gt;http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_47.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="process-descriptor"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id90"&gt;3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Descriptor&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;进程描述符&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-process-descriptor.png" /&gt;
&lt;p&gt;注意内核里面 没有thread 的概念.&lt;/p&gt;
&lt;p&gt;进程到Process Descriptor 的一一对应关系, 是通过 Process Descriptor结构的地址值确定的.&lt;/p&gt;
&lt;div class="section" id="id21"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id91"&gt;3.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;能有多少个进程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;by default, the maximum PID number is 32,767 (PID_MAX_DEFAULT - 1) , 32位系统最多3w个进程.&lt;/p&gt;
&lt;p&gt;the system administrator may reduce this limit by writing a smaller value into the /proc/sys/kernel/pid_max file&lt;/p&gt;
&lt;p&gt;In 64-bit architectures, the system administrator can enlarge the maximum PID number up to 4,194,303&lt;/p&gt;
&lt;p&gt;因为内核分配一个pid的时候, 需要确保这个pid没有被用过, 所以需要一个bitmap, 32767个bit, 正好是4k(一个page).
在64位系统中, 如果pid_max设置为 4,194,303, 就可能需要0.5M内存做bitmap, 这些内存一旦用了就不会被释放的.&lt;/p&gt;
&lt;p&gt;我们的机器一般都是默认的32767&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pidthread-group"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id92"&gt;3.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;pid在thread group中&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在一个thread group 中的进程, 从用户看来pid相等, 实际上, 内核中它们的pid不相等, 是因为getpid 返回的是 &lt;tt class="docutils literal"&gt;tgid&lt;/tt&gt; .&lt;/p&gt;
&lt;p&gt;To comply with this standard, Linux makes use of thread groups. The identifier shared by the threads is the PID of the thread group leader, that is, the PID of the first lightweight process in the group;&lt;/p&gt;
&lt;p&gt;it is stored in the tgid field of the process descriptors. The getpid() system call returns the value of &lt;tt class="docutils literal"&gt;tgid&lt;/tt&gt; relative to the current process instead of the value of pid, so all the threads of a multithreaded application share the same identifier&lt;/p&gt;
&lt;p&gt;注意: 但是 &lt;tt class="docutils literal"&gt;kill()&lt;/tt&gt; 的时候用的是pid.&lt;/p&gt;
&lt;p&gt;因为内核中 内核栈后面有意个指向 &lt;tt class="docutils literal"&gt;Process Descriptor&lt;/tt&gt; 的指针, 所以:&lt;/p&gt;
&lt;p&gt;the kernel can easily obtain the address of the thread_info Structure of the process currently running on a CPU from the value of the esp register:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
current_thread_info()  这个函数用的非常多
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="process-list"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id93"&gt;3.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;process list&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;用内核的双链表结构&lt;/p&gt;
&lt;p&gt;不同优先级:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
truct list_head [140];  #queue The 140 heads of the priority lists
&lt;/pre&gt;
&lt;p&gt;四个hash表用于从id到 Process Descriptor 的映射:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Hash table type     Field name  Description
PIDTYPE_PID         pid         PID of the process
PIDTYPE_TGID        tgid        PID of thread group leader process
PIDTYPE_PGID        pgrp        PID of the group leader process
PIDTYPE_SID         session     PID of the session leader process
&lt;/pre&gt;
&lt;p&gt;用于pid的hash函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
unsigned long hash_long(unsigned long val, unsigned int bits)
{
    unsigned long hash = val * 0x9e370001UL;
    return hash &amp;gt;&amp;gt; (32 - bits);
}
&lt;/pre&gt;
&lt;p&gt;这个数字0x9e370001UL, 是一个质数. 而且比较容易算(二进制中1的位数较少)&lt;/p&gt;
&lt;p&gt;A process wishing to wait for a specific condition can invoke any of the functions shown in the following list.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
The sleep_on() function operates on the current process:
void sleep_on(wait_queue_head_t *wq)
{
    wait_queue_t wait;
    init_waitqueue_entry(&amp;amp;wait, current);
    current-&amp;gt;state = TASK_UNINTERRUPTIBLE;
    add_wait_queue(wq,&amp;amp;wait); /* wq points to the wait queue head */
    schedule();
    remove_wait_queue(wq, &amp;amp;wait);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="process"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id94"&gt;3.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Process 资源限制&lt;/a&gt;&lt;/h4&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_AS:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum size of process address space, in bytes. The kernel checks this value when the
process uses malloc( ) or a related function to enlarge its address space (see the section
The Process’s Address Space” in Chapter 9).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_CORE:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum core dump file size, in bytes. The kernel checks this value when a process is
aborted, before creating a core file in the current directory of the process (see the section
Actions Performed upon Delivering a Signal” in Chapter 11). If the limit is 0, the kernel
won’t create the file.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_CPU:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum CPU time for the process, in seconds. If the process exceeds the limit, the ker-
nel sends it a SIGXCPU signal, and then, if the process doesn’t terminate, a SIGKILL sig-
nal (see Chapter 11).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_DATA:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum &lt;tt class="docutils literal"&gt;heap size&lt;/tt&gt; , in bytes. The kernel checks this value before expanding the heap of
the process (see the section “Managing the Heap” in Chapter 9).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_FSIZE:&lt;/th&gt;&lt;td class="field-body"&gt;The maximum file size allowed, in bytes. If the process tries to enlarge a file to a size greater
than this value, the kernel sends it a SIGXFSZ signal.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_LOCKS:&lt;/th&gt;&lt;td class="field-body"&gt;Maximum number of file locks (currently, not enforced).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;RLIMIT_NOFILE:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="process-switch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id95"&gt;3.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Process Switch&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="hardware-context"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id96"&gt;3.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Hardware Context 切换&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;2.6以前, 使用 &lt;tt class="docutils literal"&gt;far jmp&lt;/tt&gt; 来实现硬件层次的切换, 自动保存寄存器的值.
But Linux 2.6 uses software to perform a process switch for the following reasons:&lt;/p&gt;
&lt;p&gt;总之就是保存各种寄存器. MMX&amp;lt; FPU, SSE之类.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="schedule"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id97"&gt;3.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;schedule()  函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;every process switch consists of two steps:
1. Switching the Page Global Directory to install a new address space; we’ll describe this step in Chapter 9.
2. Switching the Kernel Mode stack and the hardware context, which provides all the information needed by the kernel to execute the new process, including the CPU registers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="create-processes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id98"&gt;3.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Create Processes&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="clone"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id99"&gt;3.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核底层的clone&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;各种flag:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_VM:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the memory descriptor and all Page Tables (see Chapter 9).
共享地址空间.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_FS:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the table that identifies the root directory and the current working directory, as
well as the value of the bitmask used to mask the initial file permissions of a new file
(the so-called file umask).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_FILES:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the table that identifies the open files (see Chapter 12).
共享打开的文件fd.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_SIGHAND:&lt;/th&gt;&lt;td class="field-body"&gt;Shares the tables that identify the signal handlers and the blocked and pending signals
(see Chapter 11). If this flag is true, the CLONE_VM flag must also be set.
共享sighandler(比如nohup 先设置了SIGHANDLER, 再打开子进程的时候, 肯定就设置了这个标记)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_PTRACE:&lt;/th&gt;&lt;td class="field-body"&gt;If traced, the parent wants the child to be traced too. Furthermore, the debugger may
want to trace the child on its own; in this case, the kernel forces the flag to 1.
跟踪模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_VFORK:&lt;/th&gt;&lt;td class="field-body"&gt;Set when the system call issued is a vfork( ) (see later in this section).
...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;CLONE_STOPPED:&lt;/th&gt;&lt;td class="field-body"&gt;Forces the child to start in the TASK_STOPPED state.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="clone-fork-and-vfork"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id100"&gt;3.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;clone( ), fork( ), and vfork( )&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;clone 创建线程, 基本上就是上面sys_clone系统调用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;fork: 用clone实现, 设置了SIGCHILD, 所有的flag都未设置 (TODO: ? 难道CLONE_SIGHAND也没设置?)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;它的chile_stack参数是父进程当前堆栈指针(所以创建完成后, 父子两个进程的堆栈指针是一样的.)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;copy on write&lt;/tt&gt; 保证堆栈上有写操作的时候, 父子进程就会使用不同的堆栈.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;vfork (create a child process and block parent)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;设置SIGCHILD, CLONE_VM, CLONE_VFORK,&lt;/li&gt;
&lt;li&gt;vfork 阻塞父进程的执行, 一直到子进程退出或执行一个新的程序为止.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="man-clone"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id101"&gt;3.4.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;man clone(库函数)&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;

int clone(int (*fn)(void *), void *child_stack,
          int flags, void *arg, ...
          /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );

 It is actually a library function layered on top of the underlying clone() system call, hereinafter referred to as sys_clone.
 (这个clone是一个library函数, 下层是通过sys_clone系统调用实现, sys_clone没有 fn, arg参数, 这两个参数是 clone这个库函数加上的.)

 这个clone是用于实现thread的. 允许设置共享内存, 栈空间, 栈位置等.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="do-fork"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id102"&gt;3.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;do_fork() 函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;do_fork() 负责处理clone(), fork(), vfork() 系统调用.&lt;/p&gt;
&lt;p&gt;几个重要步骤:
1. 查找pidmap_array 位图, 为子进程分配新的pid
2. If the child will run on the &lt;strong&gt;same CPU&lt;/strong&gt; as the parent, and parent and child do not share the same set of page tables (CLONE_VM flag cleared), it then forces the child to run before the parent by inserting it into the parent’s runqueue right before the parent.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This simple step yields better performance if the child flushes its address space and executes a new program right after the forking. If we let the parent run first, the Copy On Write mechanism would give rise to a series of unnecessary page duplications.&lt;/p&gt;
&lt;p&gt;这种情况, 强迫 子进程先运行,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id103"&gt;3.5&amp;nbsp;&amp;nbsp;&amp;nbsp;内核线程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核中, 周期性执行, 只运行在内核态, 用kernel_thread() 函数创建.&lt;/p&gt;
&lt;p&gt;The function essentially invokes do_fork() as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, pregs, 0, NULL, NULL);
&lt;/pre&gt;
&lt;p&gt;常见的内核线程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;keventd (also called events)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Executes the functions in the keventd_wq workqueue (see Chapter 4).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kapmd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Handles the events related to the Advanced Power Management (APM).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kswapd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Reclaims memory, as described in the section “Periodic Reclaiming” in Chapter 17.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pdflush&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Flushes “dirty” buffers to disk to reclaim memory, as described in the section “The pdflush Kernel Threads” in Chapter 15.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;kblockd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Executes the functions in the kblockd_workqueue workqueue. Essentially, it periodically activates the block device drivers, as described in the section “Activating the Block Device Driver” in Chapter 14.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;ksoftirqd&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Runs the tasklets (see section “Softirqs and Tasklets” in Chapter 4); there is one of these kernel threads for each CPU in the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="pdflush"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id104"&gt;3.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;pdflush&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;参考: &lt;a class="reference external" href="http://www.westnet.com/~gsmith/content/linux-pdflush.htm"&gt;http://www.westnet.com/~gsmith/content/linux-pdflush.htm&lt;/a&gt;
&lt;a class="reference external" href="http://www.linuxjournal.com/article/6931"&gt;http://www.linuxjournal.com/article/6931&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可能有 2 - 8 个pdflush threads.&lt;/p&gt;
&lt;p&gt;You can monitor how many are active by looking at /proc/sys/vm/nr_pdflush_threads.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Whenever all existing pdflush threads are busy for at least one second, an additional pdflush daemon is spawned.&lt;/li&gt;
&lt;li&gt;Each time a second has passed without any pdflush activity, one of the threads is removed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调优:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_writeback_centisecs (default 500):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;In hundredths of a second, this is how often pdflush wakes up to write data to disk.&lt;/li&gt;
&lt;li&gt;The default wakes up the two (or more) active threads every five seconds.&lt;/li&gt;
&lt;li&gt;减小这个值会让pdflush 更加激进.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_expire_centiseconds (default 3000):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;In hundredths of a second, how long data can be in the page cache before it's considered expired and must be written at the next opportunity. Note that this default is very long: a full 30 seconds. That means that under normal circumstances, unless you write enough to trigger the other pdflush method, Linux won't actually commit anything you write until 30 seconds later.&lt;/li&gt;
&lt;li&gt;多长时间以上的page需要flush&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_background_ratio (default 10):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Maximum percentage of active that can be filled with dirty pages before pdflush begins to write them&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;/proc/sys/vm/dirty_ratio (default 40):&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Maximum percentage of total memory that can be filled with dirty pages before processes are forced to write dirty buffers themselves during their time slice instead of being allowed to do more writes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id105"&gt;3.6&amp;nbsp;&amp;nbsp;&amp;nbsp;进程0 &amp;amp; 进程1&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;进程0: 所有进程的祖先, (idle进程)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;是一个内核线程&lt;/li&gt;
&lt;li&gt;执行 &lt;tt class="docutils literal"&gt;cpu_idle()&lt;/tt&gt; 函数, 本质上是在开中断的情况下重复执行hlt指令&lt;/li&gt;
&lt;li&gt;只有当没有其它进程处于TASK_RUNNING 状态时, 调度程序才选择进程0&lt;/li&gt;
&lt;li&gt;多核系统中, 每个核都有一个进程0 (TODO: how)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;进程1: init进程, 由进程0创建,&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;创建后调用 execve() 装载init二进制, 不是内核线程.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="destorying-processes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id106"&gt;3.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Destorying Processes&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;exit_group() 系统调用, 终止整个线程组, 对应 &lt;tt class="docutils literal"&gt;c库函数exit()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;exit() 系统调用, 终止一个线程          对应 &lt;tt class="docutils literal"&gt;pthread_exit()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c4-interrupts-and-exceptions"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id107"&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;c4 Interrupts and Exceptions&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;strong&gt;Interrupts&lt;/strong&gt; Asynchronous interrupts: &lt;strong&gt;硬件&lt;/strong&gt; 发出的.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;可屏蔽中断&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;不可屏蔽中断&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;极少数. Only a few critical events (such as hardware failures)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;Exceptions&lt;/tt&gt; Synchronous interrupts: cpu执行完一个指令后发出的&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Processor-detected exceptions (怎么翻译)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Faults&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如Page Fault Exception Handler&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Traps&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;如debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Aborts&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Programmed exceptions(程序主动触发)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;int&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;int3&lt;/tt&gt; instructions&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;into&lt;/tt&gt; (check for overflow) and &lt;tt class="docutils literal"&gt;bound&lt;/tt&gt;  (check on address bound) instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exception 和interrupt 是intel的术语.&lt;/p&gt;
&lt;div class="section" id="interrupts-and-exceptions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id108"&gt;4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupts and Exceptions&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="interrupt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id109"&gt;4.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="interrupt-handling"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id110"&gt;4.1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt handling&lt;/a&gt;&lt;/h5&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;非常轻量, 内核必须尽量处理尽量多的中断, 这样内核就必须把Interrupt Handler 做的很轻.
比如有数据ready时, 中断处理程序只是简单的做一个标记, 然后通知相应的程序, 而不会在中断处理程序里面拷贝数据到内存.&lt;/li&gt;
&lt;li&gt;可重入&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="irqs-interrupt-requests"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id111"&gt;4.1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQs (Interrupt ReQuests)&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;每个硬件都有一个 Interrupt ReQuest (IRQ) line 引脚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;所有硬件的引脚 都连到 &lt;tt class="docutils literal"&gt;Programmable Interrupt Controller(PIC)&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;PIC (Programmable Interrupt Controller)&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Monitors the IRQ lines, checking for raised signals. If two or more IRQ lines are raised, selects the one having the lower pin number.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;If a raised signal occurs on an IRQ line:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last loweralpha simple"&gt;
&lt;li&gt;Converts the raised signal received into a corresponding vector.&lt;/li&gt;
&lt;li&gt;Stores the vector in an Interrupt Controller I/O port, thus allowing the CPU to read it via the data bus.&lt;/li&gt;
&lt;li&gt;Sends a raised signal to the processor INTR pin—that is, issues an interrupt. (给CPU的INTR引脚发信号)&lt;/li&gt;
&lt;li&gt;Waits until the CPU acknowledges the interrupt signal by writing into one of the Programmable Interrupt Controllers (PIC) I/O ports; when this occurs, clears the INTR line.&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Goes back to step 1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IRQ线可以屏蔽.&lt;/p&gt;
&lt;div class="section" id="pic"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id112"&gt;4.1.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;老的PIC 的硬件结构&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;2个8259芯片, 第二个向上连在第一个的一个引脚, 可以处理15个IRQ线&lt;/p&gt;
&lt;p&gt;Traditional PICs are implemented by connecting “in cascade” two 8259A-style external chips. Each chip can handle up to eight different IRQ input lines. Because the INT output line of the slave PIC is connected to the IRQ2 pin of the master PIC, the number of available IRQ lines is limited to 15.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pic-the-advanced-programmable-interrupt-controller-apic"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id113"&gt;4.1.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;新的PIC 的硬件结构 The Advanced Programmable Interrupt Controller (APIC)&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;Pentium III 以后有APIC&lt;/p&gt;
&lt;p&gt;多核系统中, 每个核都应该可以处理中断, 所以有一个中断总线, APIC和CPU都连到这个总线上, 有总线仲裁/路由机制:&lt;/p&gt;
&lt;img alt="" src="/imgs/ulk-multi-apic.png" /&gt;
&lt;p&gt;硬件终端可以有两种处理方式:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Static distribution&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;指定中断有某个CPU处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Dynamic distribution&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;信号被分发到CPU 中 priority 最小的一个. (这个priority可以编程修改)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CPU之间也能发送中断.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exceptions"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id114"&gt;4.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Exceptions&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; “Divide error” (fault)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Raised when a program issues an integer division by 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;1&lt;/tt&gt; “Debug” (trap or fault)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Raised when the TF flag of eflags is set (quite useful to implement single-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register (see the section “Hardware Context” in Chapter 3).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;3&lt;/tt&gt; “Breakpoint” (trap)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Caused by an int3 (breakpoint) instruction (usually inserted by a debugger).&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;tt class="docutils literal"&gt;4&lt;/tt&gt; “Overflow” (trap)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;An into (check for overflow) instruction has been executed while the OF (overflow) flag of eflags is set.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;8&lt;/tt&gt; “Double fault”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;11&lt;/tt&gt; “Segment not present” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;12&lt;/tt&gt; “Stack segment fault” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;14&lt;/tt&gt; “Page Fault” (fault)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核收到中断后，通常会向进程发送信号(这就是我们段错误的时候是收到信号的原因)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Table 4-1. Signals sent by the exception handlers

# Exception                         Exception handler                  Signal
0 Divide error                      divide_error( )                    SIGFPE
1 Debug                             debug( )                           SIGTRAP
2 NMI                               nmi( )                             None
3 Breakpoint                        int3( )                            SIGTRAP
4 Overflow                          overflow( )                        SIGSEGV
5 Bounds check                      bounds( )                          SIGSEGV
6 Invalid opcode                    invalid_op( )                      SIGILL
7 Device not available              device_not_available( )            None
8 Double fault                      doublefault_fn()                   None
9 Coprocessor segment overrun       coprocessor_segment_overrun( )     SIGFPE
10 Invalid TSS                      invalid_TSS( )                     SIGSEGV
11 Segment not present              segment_not_present( )             SIGBUS
12 Stack segment fault              stack_segment( )                   SIGBUS
13 General protection               general_protection( )              SIGSEGV
14 Page Fault                       page_fault( )                      SIGSEGV
15 Intel-reserved                   None                               None
16 Floating-point error             coprocessor_error( )               SIGFPE
17 Alignment check                  alignment_check( )                 SIGBUS
18 Machine check                    machine_check()                    None
19 SIMD floating point              simd_coprocessor_error()           SIGFPE
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="idt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id115"&gt;4.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;中断描述符表IDT&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="nested-execution-of-exception-and-interrupt-handlers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id116"&gt;4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Nested Execution of Exception and Interrupt Handlers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="initializing-the-interrupt-descriptor-table"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id117"&gt;4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Initializing the Interrupt Descriptor Table&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Intel 提供三种 Interrupt, Trap, and System Gates, 权限不同, o, 比较复杂:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set_trap_gate(0,&amp;amp;divide_error);
set_trap_gate(1,&amp;amp;debug);

set_intr_gate(2,&amp;amp;nmi);
set_system_intr_gate(3,&amp;amp;int3);
set_system_gate(4,&amp;amp;overflow);
set_system_gate(5,&amp;amp;bounds);
set_trap_gate(6,&amp;amp;invalid_op);
set_trap_gate(7,&amp;amp;device_not_available);
set_task_gate(8,31);
set_trap_gate(9,&amp;amp;coprocessor_segment_overrun);
set_trap_gate(10,&amp;amp;invalid_TSS);
set_trap_gate(11,&amp;amp;segment_not_present);
set_trap_gate(12,&amp;amp;stack_segment);
set_trap_gate(13,&amp;amp;general_protection);
set_intr_gate(14,&amp;amp;page_fault);
...
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="exception-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id118"&gt;4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception Handling&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常是发信号到响应进程.&lt;/p&gt;
&lt;p&gt;Most exceptions issued by the CPU are interpreted by Linux as error conditions.
When one of them occurs, the kernel sends a signal to the process that caused the
exception to notify it of an anomalous condition.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;If, for instance, a process performs
a division by zero, the CPU raises a “Divide error” exception, and the corresponding
exception handler sends a SIGFPE signal to the current process, which then takes the
necessary steps to recover or (if no signal handler is set for that signal) abort.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
current-&amp;gt;thread.error_code = error_code;
current-&amp;gt;thread.trap_no = vector;
force_sig(sig_number, current);
&lt;/pre&gt;
&lt;p&gt;The current process takes care of the signal right after the termination of the exception handler.&lt;/p&gt;
&lt;p&gt;The signal will be handled either in User Mode by the process’s own signal handler (if it exists) or in Kernel Mode. In the latter case, the kernel usually kills the process (see Chapter 11). The signals sent by the exception handlers are listed in Table 4-1.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id119"&gt;4.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Interrupt Handling(硬件产生的)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;this approach does not hold for interrupts, because they frequently arrive long after the process to which they are related&lt;/p&gt;
&lt;p&gt;前面方法不适用, 因为当前进程和中断并没有关系.&lt;/p&gt;
&lt;p&gt;三种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;I/O interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;An I/O device requires attention; the corresponding interrupt handler must query the device to determine the proper course of action. We cover this type of interrupt in the later section “I/O Interrupt Handling.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Timer interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Some timer, either a local APIC timer or an external timer, has issued an interrupt; this kind of interrupt tells the kernel that a fixed-time interval has elapsed.  These interrupts are handled mostly as I/O interrupts; we discuss the peculiar characteristics of timer interrupts in Chapter 6.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Interprocessor interrupts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;A CPU issued an interrupt to another CPU of a multiprocessor system. We cover such interrupts in the later section “Interprocessor Interrupt Handling.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Table 4-3. An example of IRQ assignment to I/O devices:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
IRQ INT     Hardware device
0   32      Timer  Timer 必须是0号IRQ线.
1   33      Keyboard
2   34      PIC cascading
3   35      Second serial port
4   36      First serial port
6   38      Floppy disk
8   40      System clock
10  42      Network interface
11  43      USB port, sound card
12  44      PS/2 mouse
13  45      Mathematical coprocessor
14  46      EIDE disk controller’s first chain
15  47      EIDE disk controller’s second chain
&lt;/pre&gt;
&lt;div class="section" id="irq"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id120"&gt;4.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;IRQ在多处理器系统上的分发&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Linux 遵守对称多处理器模型(SMP), 这意味着， 内核对每个CPU都不应该有偏爱.&lt;/p&gt;
&lt;p&gt;内核试图以轮转的方式把来自硬件的IRQ信号在多个CPU之间分发, 所有CPU服务于I/O中断的执行时间片几乎相同.&lt;/p&gt;
&lt;p&gt;这是由硬件完成的, 但是有的硬件存在问题, Linux 使用kirqd的特殊内核线程来纠正对CPU进行的IRQ自动分配&lt;/p&gt;
&lt;div class="section" id="cpuirq"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id121"&gt;4.5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;CPU的IRQ亲和力&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;多APIC系统中, 通过修改APIC中断重定向表, 可以把指定中断发到特定的CPU上.&lt;/p&gt;
&lt;p&gt;kirqd内核线程定期执行 do_irq_balance() 函数, 它记录最近时间内每个cpu的终端次数, 如果发现负载不均衡, 就把IRQ从一个CPU转到另一个CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id122"&gt;4.5.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;例子:网卡多队列的中断绑定&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;如果大家用的万兆网卡跑linux或者nginx做大规模的负载均衡，那么肯定会遇到网卡中断占耗尽一个CPU的情况，会发现有一个ksoftirqd进程耗CPU非常厉害。这个时候就需要把万兆网卡的多个队列分别绑定到不同的核上。简单的在自己的笔记本上测试一下把单个中断绑定到指定CPU的方式。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
  0:       1120         78         73         89   IO-APIC-edge      timer
  1:       8372       8326       4485       1256   IO-APIC-edge      i8042
  8:          0          0          0          1   IO-APIC-edge      rtc0
  9:     919824     902422     945216     917506   IO-APIC-fasteoi   acpi
 12:      70724      74831      73671     130628   IO-APIC-edge      i8042
 14:    3836954     375689     389297     391612   IO-APIC-edge      ata_piix
 15:          0          0          0          0   IO-APIC-edge      ata_piix
 17:     228109        213     105882      40581   IO-APIC-fasteoi   ata_piix, HDA Intel
 19:    2129264    2483519    2266058    1798885   IO-APIC-fasteoi   ehci_hcd:usb2
 23:     548565     795696     859954     207891   IO-APIC-fasteoi   ehci_hcd:usb1
 27:        929      23923       1717       2311   PCI-MSI-edge      eth0
 28:   60226455    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
 29:    1156981    1577957    3826559    1869343   PCI-MSI-edge      i915&amp;#64;pci:0000:00:02.0
NMI:          0          0          0          0   Non-maskable interrupts
LOC:   88922568   93984839  101969505   97218270   Local timer interrupts
SPU:          0          0          0          0   Spurious interrupts
PMI:          0          0          0          0   Performance monitoring interrupts
PND:          0          0          0          0   Performance pending work
RES:   15963006   16173515   13643964   13852799   Rescheduling interrupts
CAL:     264642     254329     620940     555868   Function call interrupts
TLB:    2069687    1882570    1553231    1561555   TLB shootdowns
TRM:          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0   Threshold APIC interrupts
MCE:          0          0          0          0   Machine check exceptions
MCP:       1349       1345       1345       1345   Machine check polls
ERR:          0
MIS:          0
&lt;/pre&gt;
&lt;p&gt;通过两次cat:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237470    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237488    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60237512    7787039    7893406    8392505   PCI-MSI-edge      iwlagn
&lt;/pre&gt;
&lt;p&gt;这里发现28号中断(iwlagn) 只有CPU0这一列在增加, 说明28号中断绑定在CPU0上.&lt;/p&gt;
&lt;p&gt;比如要绑定到CPU3:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
echo 4 &amp;gt; /proc/irq/28/smp_affinity
&lt;/pre&gt;
&lt;p&gt;这里:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1 : CPU0
2 : CPU1
4 : CPU2
8 : CPU3
&lt;/pre&gt;
&lt;p&gt;再观察, 发现只有CPU2这一列在增加:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893707    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893727    8392505   PCI-MSI-edge      iwlagn
ning&amp;#64;ning-laptop:~/test$ cat /proc/interrupts | grep iwl
 28:   60238491    7787039    7893740    8392505   PCI-MSI-edge      iwlagn
&lt;/pre&gt;
&lt;p&gt;一个核每秒能处理多少中断?&lt;/p&gt;
&lt;p&gt;我们的机器eth中断都绑定在CPU0上面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/interrupts | grep eth
  49:  273896202          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-0
  50: 2839469681          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-1
  51: 2443166700          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-2
  52:  947194873          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-3
  53: 3035084892          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-4
  54: 2586224100          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-5
  55: 1861561263          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-6
  56: 4154271481          0          0          0          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth1-7
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/interrupts | grep eth | awk '{A+=$2} END{print A}' &amp;amp;&amp;amp; sleep 10 &amp;amp;&amp;amp; cat /proc/interrupts | grep eth | awk '{A+=$2} END{print A}'
18144814547
18145846813 (10s)
&lt;/pre&gt;
&lt;p&gt;大约每秒10w个中断, 这个机器负载不重.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id26"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id123"&gt;4.5.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;把进程绑在核上&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ taskset -p 40234
pid 40234's current affinity mask: fff
&lt;/pre&gt;
&lt;p&gt;说明每个核都可能运行.&lt;/p&gt;
&lt;p&gt;设置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ taskset -p 7537
pid 7537's current affinity mask: f

ning&amp;#64;ning-laptop ~/test$ taskset -p e 7537
pid 7537's current affinity mask: f
pid 7537's new affinity mask: e

ning&amp;#64;ning-laptop ~/test$ taskset -p 7537
pid 7537's current affinity mask: e
&lt;/pre&gt;
&lt;p&gt;另外一种格式set:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
taskset -pc 0,3,7-11 700
&lt;/pre&gt;
&lt;p&gt;进程启动时指定CPU:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
taskset -c 1 ./redis-server ../redis.conf
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id27"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id124"&gt;4.5.1.4&amp;nbsp;&amp;nbsp;&amp;nbsp;网卡多队列&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;对于万兆网卡, 一把提供多个中断号(多队列), 如果中断都绑在一个核上, 就悲剧了.&lt;/p&gt;
&lt;p&gt;有多个RSS队列.&lt;/p&gt;
&lt;p&gt;英特尔 X520万兆网卡里，最大可以同时支持128个队列，足以满足当前主流的服务器CPU配置。&lt;/p&gt;
&lt;p&gt;开启多队列:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sed -i 's/e1000/igb/g' /etc/modprobe.conf
echo &amp;quot;options igb RSS=8,8&amp;quot; &amp;gt;&amp;gt; /etc/modprobe.conf
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id28"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id125"&gt;4.5.1.5&amp;nbsp;&amp;nbsp;&amp;nbsp;千兆网卡多队列&lt;/a&gt;&lt;/h5&gt;
&lt;div class="section" id="id29"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id126"&gt;4.5.1.5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;是否支持&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;&lt;a class="reference external" href="http://blog.csdn.net/turkeyzhou/article/details/7528182"&gt;http://blog.csdn.net/turkeyzhou/article/details/7528182&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#lspci -vvv
Ethernet controller的条目内容，如果有MSI-X &amp;amp;&amp;amp; Enable+ &amp;amp;&amp;amp; TabSize &amp;gt; 1，则该网卡是多队列网卡，如图4.4所示。

图4.4 lspci内容
Message Signaled Interrupts(MSI)是PCI规范的一个实现，可以突破CPU 256条interrupt的限制，使每个设备具有多个中断线变成可能，多队列网卡驱动给每个queue申请了MSI。MSI-X是MSI数组，Enable+指使能，TabSize是数组大小。

02:00.1 Ethernet controller: Intel Corporation: Unknown device 150e (rev 01)
        Subsystem: Intel Corporation: Unknown device 0000
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
        Status: Cap+ 66Mhz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR-
        Latency: 0, Cache Line Size 10
        Interrupt: pin B routed to IRQ 30
        Region 0: Memory at 94800000 (32-bit, non-prefetchable) [size=512K]
        Region 2: I/O ports at 5000 [size=32]
        Region 3: Memory at 94900000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: [40] Power Management version 3
                Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)
                Status: D0 PME-Enable- DSel=0 DScale=1 PME-
        Capabilities: [50] Message Signalled Interrupts: 64bit+ Queue=0/0 Enable-
                Address: 0000000000000000  Data: 0000
        Capabilities: [70] MSI-X: Enable+ Mask- TabSize=10
                Vector table: BAR=3 offset=00000000
                PBA: BAR=3 offset=00002000
        Capabilities: [a0] Express Endpoint IRQ 0
                Device: Supported: MaxPayload 512 bytes, PhantFunc 0, ExtTag-
                Device: Latency L0s &amp;lt;512ns, L1 &amp;lt;64us
                Device: AtnBtn- AtnInd- PwrInd-
                Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
                Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
                Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
                Link: Supported Speed unknown, Width x4, ASPM L0s L1, Port 2
                Link: Latency L0s &amp;lt;4us, L1 &amp;lt;8us
                Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
                Link: Speed unknown, Width x4
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [140] Device Serial Number ab-fb-2b-ff-ff-c7-0b-20
        Capabilities: [1a0] Unknown (23)
&lt;/pre&gt;
&lt;p&gt;还有种通用的方式，直接查看 interrupts 文件，看关键字 MSI 就知道了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# grep -i msi /proc/interrupts
&lt;/pre&gt;
&lt;p&gt;3.dmsg:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#  dmesg  | grep -i msi
hpet: hpet2 irq 72 for MSI
hpet: hpet3 irq 73 for MSI
hpet: hpet4 irq 74 for MSI
hpet: hpet5 irq 75 for MSI
hpet: hpet6 irq 76 for MSI
hpet: hpet7 irq 77 for MSI
megaraid_sas 0000:03:00.0: irq 78 for MSI/MSI-X
ahci 0000:00:1f.2: irq 79 for MSI/MSI-X
igb 0000:02:00.0: irq 80 for MSI/MSI-X
igb 0000:02:00.0: irq 81 for MSI/MSI-X
igb 0000:02:00.0: Using MSI-X interrupts. 1 rx queue(s), 1 tx queue(s)
igb 0000:02:00.1: irq 82 for MSI/MSI-X
igb 0000:02:00.1: irq 83 for MSI/MSI-X
igb 0000:02:00.1: Using MSI-X interrupts. 1 rx queue(s), 1 tx queue(s)
isci 0000:04:00.0: irq 84 for MSI/MSI-X
isci 0000:04:00.0: irq 85 for MSI/MSI-X
&lt;/pre&gt;
&lt;ol class="arabic" start="4"&gt;
&lt;li&gt;&lt;p class="first"&gt;ethtool:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# ethtool -S eth0 | tail -20
     os2bmc_tx_by_bmc: 0
     os2bmc_tx_by_host: 0
     os2bmc_rx_by_host: 0
     rx_errors: 0
     tx_errors: 0
     tx_dropped: 0
     rx_length_errors: 0
     rx_over_errors: 0
     rx_frame_errors: 0
     rx_fifo_errors: 0
     tx_fifo_errors: 0
     tx_heartbeat_errors: 0
     tx_queue_0_packets: 0
     tx_queue_0_bytes: 0
     tx_queue_0_restart: 0
     rx_queue_0_packets: 0
     rx_queue_0_bytes: 0
     rx_queue_0_drops: 0
     rx_queue_0_csum_err: 0
     rx_queue_0_alloc_failed: 0
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id30"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id127"&gt;4.5.1.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;开启多队列&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;首先要支持MSI-X (内核2.6.24+)&lt;/p&gt;
&lt;p&gt;Linux 网卡驱动一般只有两种 e1000 和 igb. (无线的是iwlagn):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#下面来自
本发行版包括两个适用于英特尔® 网卡的 Linux 基础驱动程序。这两个驱动程序的名称是 e1000 和 igb。为支持任何基于 82575 的网卡，必须安装 igb 驱动程序。其它所有网卡要求 e1000 驱动程序。
&lt;/pre&gt;
&lt;p&gt;先通过lspci看看当前用的是什么驱动:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
06:00.2 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation I350 Gigabit Network Connection
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Latency: 0, Cache Line Size: 64 bytes
        Interrupt: pin C routed to IRQ 18
        Region 0: Memory at a9a20000 (32-bit, non-prefetchable) [size=128K]
        Region 2: I/O ports at 1020 [size=32]
        Region 3: Memory at a9a84000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &amp;lt;access denied&amp;gt;
        Kernel driver in use: igb
        Kernel modules: igb

06:00.3 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation I350 Gigabit Network Connection
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Latency: 0, Cache Line Size: 64 bytes
        Interrupt: pin D routed to IRQ 19
        Region 0: Memory at a9a00000 (32-bit, non-prefetchable) [size=128K]
        Region 2: I/O ports at 1000 [size=32]
        Region 3: Memory at a9a80000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &amp;lt;access denied&amp;gt;
        Kernel driver in use: igb
        Kernel modules: igb
&lt;/pre&gt;
&lt;p&gt;igb是一个内核mod:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ lsmod | grep igb
igb                   143886  0
&lt;/pre&gt;
&lt;p&gt;看看这个mod支持啥参数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ modinfo igb
filename:       /lib/modules/2.6.32_1-12-0-0/kernel/drivers/net/igb/igb.ko
version:        4.0.17
license:        GPL
description:    Intel(R) Gigabit Ethernet Network Driver
author:         Intel Corporation, &amp;lt;e1000-devel&amp;#64;lists.sourceforge.net&amp;gt;
srcversion:     BCB38D2CABB33E0A1BA8385
...
depends:
vermagic:       2.6.32_1-12-0-0 SMP mod_unload modversions
parm:           InterruptThrottleRate:Maximum interrupts per second, per vector, (max 100000), default 3=adaptive (array of int)
parm:           IntMode:Change Interrupt Mode (0=Legacy, 1=MSI, 2=MSI-X), default 2 (array of int)
parm:           Node:set the starting node to allocate memory on, default -1 (array of int)
parm:           LLIPort:Low Latency Interrupt TCP Port (0-65535), default 0=off (array of int)
parm:           LLIPush:Low Latency Interrupt on TCP Push flag (0,1), default 0=off (array of int)
parm:           LLISize:Low Latency Interrupt on Packet Size (0-1500), default 0=off (array of int)
parm:           RSS:Number of Receive-Side Scaling Descriptor Queues (0-8), default 1, 0=number of cpus (array of int)
parm:           VMDQ:Number of Virtual Machine Device Queues: 0-1 = disable, 2-8 enable, default 0 (array of int)
parm:           max_vfs:Number of Virtual Functions: 0 = disable, 1-7 enable, default 0 (array of int)
parm:           MDD:Malicious Driver Detection (0/1), default 1 = enabled. Only available when max_vfs is greater than 0 (array of int)
parm:           QueuePairs:Enable Tx/Rx queue pairs for interrupt handling (0,1), default 1=on (array of int)
parm:           EEE:Enable/disable on parts that support the feature (array of int)
parm:           DMAC:Disable or set latency for DMA Coalescing ((0=off, 1000-10000(msec), 250, 500 (usec)) (array of int)
parm:           LRO:Large Receive Offload (0,1), default 0=off (array of int)
parm:           debug:Debug level (0=none, ..., 16=all) (int)
&lt;/pre&gt;
&lt;p&gt;通过调整IntMode, RSS, /etc/modules.conf or /etc/modprobe.conf&lt;/p&gt;
&lt;pre class="literal-block"&gt;
alias eth0 igb
alias eth1 igb
options igb IntMode=2,1 RSS=4,4
&lt;/pre&gt;
&lt;p&gt;On some kernels a reboot is required to switch between a single queue mode and multiqueue modes, or vice-versa.&lt;/p&gt;
&lt;p&gt;可以看这里的intel驱动文档:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://downloadmirror.intel.com/20927/eng/e1000.htm

IntMode:
    0-2 (0 = Legacy Int, 1 = MSI and 2 = MSI-X)
    IntMode controls allow load time control over the type of interrupt registered for by the driver. MSI-X is required for multiple queue support, and some kernels and combinations of kernel .config options will force a lower level of interrupt support. 'cat /proc/interrupts' will show different values for each type of interrupt.

RSS
    0-8:

    0 - Assign up to whichever is less, number of CPUS or number of queues
    X - Assign X queues where X is less than the maximum number of queues
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="proc-softirqs"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id128"&gt;4.5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;/proc/softirqs&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/test$ cat /proc/softirqs
                CPU0       CPU1       CPU2       CPU3
      HI:     185922     155733     322202     415150
   TIMER:  116015047  115689110  116242953  114220601
  NET_TX:  145507222    2411961    2579050    2645211
  NET_RX:   91563132   62827666   54938487   56726882
   BLOCK:   12582678     387007     389099     477301
BLOCK_IOPOLL:         39          0         14          1
 TASKLET:  268807160    8526283   10469002    7812433
   SCHED:   85717988   81576238   76344646   74394437
 HRTIMER:      38106      42778      28602      28957
     RCU:  110562375  107074305  102180377   98345842
&lt;/pre&gt;
&lt;div class="section" id="mpstat"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id129"&gt;4.5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;mpstat&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
mpstat [ -P { cpu | ALL } ] [ -V ] [ interval [ count ] ]

 CPU
        Processor number. The keyword all indicates that statistics  are
        calculated as averages among all processors.

 ...
 %iowait
        Show  the percentage of time that the CPU or CPUs were idle dur-
        ing which the system had an outstanding disk I/O request.
 %irq (有多少时间花在处理中断)
        Show the percentage of time spent by the CPU or CPUs to  service
        interrupts.
 %soft
        Show  the percentage of time spent by the CPU or CPUs to service
        softirqs.  A softirq (software interrupt) is one  of  up  to  32
        enumerated software interrupts which can run on multiple CPUs at
        once.
 %idle
        Show the percentage of time that the CPU or CPUs were  idle  and
        the system did not have an outstanding disk I/O request.
 intr/s
        Show  the  total number of interrupts received per second by the
        CPU or CPUs.
&lt;/pre&gt;
&lt;p&gt;两种用法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#看总体情况
mpstat 1
#看每个CPU情况.
mpstat -P ALL 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="vmstat"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id130"&gt;4.5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;vmstat&lt;/a&gt;&lt;/h5&gt;
&lt;pre class="literal-block"&gt;
$ vmstat  1
procs -----------memory---------- ---swap-- -----io----    --system--    ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo        in    cs  us sy id wa
 5  0 975864 3730960 237268 30782988    0    0     1   110      0     0  13  7 80  0
 1  0 975864 3731720 237268 30783940    0    0     0   412 111381 93381  5 10 85  0
 3  0 975864 3731780 237268 30784904    0    0     0   356 110127 92617  5 10 86  0
 5  0 975864 3729672 237268 30785796    0    0     0   324 109500 90538  5  9 86  0

 system的in这一列, 就是说每秒多少中断.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="softirqs-and-tasklets"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id131"&gt;4.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Softirqs and Tasklets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;TODO: SoftIRQ(软中断) 和中断/异常是什么关系??&lt;/p&gt;
&lt;p&gt;ksoftirqd/n 内核线程:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
for(;;) {
    set_current_state(TASK_INTERRUPTIBLE);
    schedule();
    /* now in TASK_RUNNING state */
    while (local_softirq_pending()) {
        preempt_disable();
        do_softirq();
        preempt_enable();
        cond_resched();
    }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="work-queues"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id132"&gt;4.7&amp;nbsp;&amp;nbsp;&amp;nbsp;Work Queues&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;工作队列实际上是这样一种概念:
硬件中断发生时, 把中断对应的处理函数加到一个队列里面, 再由一个 &lt;tt class="docutils literal"&gt;内核线程&lt;/tt&gt; 来对这个队列里面的每个函数, 逐一调用, 可以简化中断处理例程.&lt;/p&gt;
&lt;p&gt;这种方法和lighttpd对请求有事件来时的处理很像.&lt;/p&gt;
&lt;p&gt;预定义的Work Queue: &lt;tt class="docutils literal"&gt;events&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;内核线程:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;keventd(通用)&lt;/li&gt;
&lt;li&gt;kblockd(块设备层使用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="returning-from-interrupts-and-exceptions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id133"&gt;4.8&amp;nbsp;&amp;nbsp;&amp;nbsp;Returning from Interrupts and Exceptions&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ret_from_intr():        中断处理结束时&lt;/li&gt;
&lt;li&gt;ret_from_exception():   异常处理结束时&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c5-kernel-synchronization"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id134"&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;c5 Kernel Synchronization&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="how-the-kernel-services-requests"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id135"&gt;5.1&amp;nbsp;&amp;nbsp;&amp;nbsp;How the Kernel Services Requests&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以把内核看作不断对请求进行响应的服务器, 这些请求可能来自CPU上执行的进程, 也可能来自发出中断请求的外部设备.&lt;/p&gt;
&lt;div class="section" id="id31"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id136"&gt;5.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;内核抢占&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;抢占内核的主要特点是: 一个在内核台运行的进程, 可能在执行内核函数期间被另一个进程取代.&lt;/li&gt;
&lt;li&gt;比如一个执行异常处理程序的进程, 用完了它的时间片, 如果内核是抢占的, 进程会立即被取代.
如果内核不是抢占的, 进程继续执行直到它执行完异常处理程序或主动放弃CPU.&lt;/li&gt;
&lt;li&gt;使内核可抢占的目的是: 减少用户态进程的分派延迟.&lt;/li&gt;
&lt;li&gt;内核抢占会引起不容忽视的开销, 所以2.6内核允许用户在编译的时候设置是否开启内核抢占.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个界定其实不严格.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronization-primitives"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id137"&gt;5.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronization Primitives(同步原语)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Table 5-2. Various types of synchronization techniques used by the kernel&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="21%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="47%" /&gt;
&lt;col width="18%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Technique&lt;/th&gt;
&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;Description&lt;/th&gt;
&lt;th class="head"&gt;Scope&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Per-CPU variables&lt;/td&gt;
&lt;td&gt;每CPU变量&lt;/td&gt;
&lt;td&gt;Duplicate a data Structure among the CPUs&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Atomic operation&lt;/td&gt;
&lt;td&gt;原子操作&lt;/td&gt;
&lt;td&gt;Atomic read-modify-write instruction to a counter&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Memory barrier&lt;/td&gt;
&lt;td&gt;内存屏障&lt;/td&gt;
&lt;td&gt;Avoid instruction reordering(避免指令重排)&lt;/td&gt;
&lt;td&gt;Local CPU or All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Spin lock&lt;/td&gt;
&lt;td&gt;自旋锁&lt;/td&gt;
&lt;td&gt;Lock with busy wait&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Semaphore&lt;/td&gt;
&lt;td&gt;信号量&lt;/td&gt;
&lt;td&gt;Lock with blocking wait (sleep)&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Seqlocks&lt;/td&gt;
&lt;td&gt;顺序锁&lt;/td&gt;
&lt;td&gt;Lock based on an access counter&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Local interrupt disabling&lt;/td&gt;
&lt;td&gt;本地中断禁止&lt;/td&gt;
&lt;td&gt;Forbid interrupt handling on a single CPU&lt;/td&gt;
&lt;td&gt;Local CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Local softirq disabling&lt;/td&gt;
&lt;td&gt;本地软中断禁止&lt;/td&gt;
&lt;td&gt;Forbid deferrable function handling on a single CPU&lt;/td&gt;
&lt;td&gt;Local CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Read-copy-update (RCU)&lt;/td&gt;
&lt;td&gt;通过指针而不是锁&lt;/td&gt;
&lt;td&gt;Lock-free access to shared data structures through pointers&lt;/td&gt;
&lt;td&gt;All CPUs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RCU 应该是指一些无锁数据结构操作方式,&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Read-copy-update&lt;/span&gt;&lt;/tt&gt; 这个术语是针对 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;读-修改-写(read-modify-write)&lt;/span&gt;&lt;/tt&gt; 这种常见的操作模式来说的.&lt;/p&gt;
&lt;div class="section" id="cpu"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id138"&gt;5.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;每CPU变量&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;各个CPU的数据在硬件Cache中, 保证不会存放在同一个 &lt;tt class="docutils literal"&gt;Cache Line&lt;/tt&gt;, 对每CPU数组的并发访问不会导致Cache Line的窃用和失效.&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
DEFINE_PER_CPU(type, name) Statically allocates a per-CPU array called name of type data structures
per_cpu(name, cpu) Selects the element for CPU cpu of the per-CPU array name
&lt;/pre&gt;
&lt;p&gt;每个CPU的运行队列就是 &lt;tt class="docutils literal"&gt;每CPU变量&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id32"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id139"&gt;5.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;原子操作&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;哪些操作是原子的&lt;/strong&gt; :&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;进行0次或1次 &lt;strong&gt;对齐&lt;/strong&gt; 内存访问的汇编指令(如int/指针赋值)
但是要注意, &lt;strong&gt;对齐&lt;/strong&gt; 很重要, 一个结构体中, 很容易不对齐, 静态堆/栈/malloc是否对齐 依赖编译器.&lt;/li&gt;
&lt;li&gt;如果读操作后, 写操作前没有其它处理器占用内存总线(如 &lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;dec&lt;/tt&gt; )&lt;/li&gt;
&lt;li&gt;操作码有lock前缀(控制单元此时锁定内存总线, 直到这条指令执行完成)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; : C代码中, 不能保证编译器会将 &lt;tt class="docutils literal"&gt;a=a+1&lt;/tt&gt; 甚至 &lt;tt class="docutils literal"&gt;a++&lt;/tt&gt; 这样的操作使用一个原子指令 (但是赋值是)&lt;/p&gt;
&lt;p&gt;原子操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
atomic_read(v)
atomic_set(v)
atomic_add(v)
atomic_add_return(v)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id33"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id140"&gt;5.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障&amp;amp;内存屏障&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;CPU的多发射会导致指令重排, 如果放在同步原语之后的一条指令在同步原语之前执行, 就悲剧了.&lt;/p&gt;
&lt;div class="section" id="optimization-barrier"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id141"&gt;5.2.3.1&amp;nbsp;&amp;nbsp;&amp;nbsp;优化屏障(optimization barrier) 原语保证编译程序不会混淆原语前后的汇编指令.&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Linux中, 优化屏障:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
barrier()
&lt;/pre&gt;
&lt;p&gt;展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
asm volatile(&amp;quot;&amp;quot;:::&amp;quot;memory&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;优化屏障&lt;/tt&gt; 并不保证不使当前CPU把汇编指令混在一起执行. -- 这是 &lt;tt class="docutils literal"&gt;内存屏障&lt;/tt&gt; 的作用&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id34"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id142"&gt;5.2.3.2&amp;nbsp;&amp;nbsp;&amp;nbsp;内存屏障确保原语之后的操作开始执行之前, 原语之前的操作已完成.&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;在80x86处理器中, 下列种类的汇编指令是串行的, 他们起到 &lt;tt class="docutils literal"&gt;内存屏障&lt;/tt&gt; 的作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;对I/O端口操作的所有指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;lock前缀的所有指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;写控制寄存器, 系统寄存器或调试寄存器的指令(cli, sti)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Pentium 4中引入的&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;lfence: 读内存屏障, 仅作用于读内存的指令&lt;/li&gt;
&lt;li&gt;sfence: 写内存屏障, 仅作用于写内存的指令&lt;/li&gt;
&lt;li&gt;mfence: 读-写内存屏障.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;少数汇编指令, 如iret.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux使用6个内存屏障原语, 它们同时也被作为优化屏障:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
mb()        Memory barrier for MP and UP
rmb()       Read memory barrier for MP and UP
wmb()       Write memory barrier for MP and UP
smp_mb()    Memory barrier for MP only
smp_rmb()   Read memory barrier for MP only
smp_wmb()   Write memory barrier for MP only
&lt;/pre&gt;
&lt;p&gt;rmb 可能展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
asm volatile(&amp;quot;lfence&amp;quot;)
asm volatile(&amp;quot;lock;addl $0,0(%%esp)&amp;quot;:::&amp;quot;memory&amp;quot;)
lock; addl $0,0(%%esp)
&lt;/pre&gt;
&lt;p&gt;wmb可能展开为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
barrier()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id35"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id143"&gt;5.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;自旋锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;锁里面最简单的一种, 忙等锁.&lt;/p&gt;
&lt;p&gt;很多自旋锁只会锁1ms时间, 所以, 自旋锁不会造成很大的浪费.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
spin_lock_init() Set the spin lock to 1 (unlocked)
spin_lock() Cycle until spin lock becomes 1 (unlocked), then set it to 0 (locked)
spin_unlock() Set the spin lock to 1 (unlocked)
spin_unlock_wait() Wait until the spin lock becomes 1 (unlocked)
spin_is_locked() Return 0 if the spin lock is set to 1 (unlocked); 1 otherwise
spin_trylock() Set the spin lock to 0 (locked), and return 1 if the previous value of the lock was 1; 0 oth- erwise
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id36"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id144"&gt;5.2.5&amp;nbsp;&amp;nbsp;&amp;nbsp;读/写自旋锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;目的是提高内核的并行能力.&lt;/p&gt;
&lt;p&gt;允许多个读并发.&lt;/p&gt;
&lt;p&gt;原来:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    读  写
读   0   0
写   0   0
&lt;/pre&gt;
&lt;p&gt;现在:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    读  写
读   1   0
写   0   0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id37"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id145"&gt;5.2.6&amp;nbsp;&amp;nbsp;&amp;nbsp;顺序锁&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;SeqLock, 它和读写自旋锁很像, 只是它赋予写者更高的优先级,&lt;/p&gt;
&lt;p&gt;即使有读者正在读, 也允许写者继续写,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这种策略的好处是写者永远不会等待(除非有另一个写者正在写),&lt;/li&gt;
&lt;li&gt;缺点是读者必须反复读相同的数据, 直到它获得有效的副本.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个读者在读前后两次读 &lt;tt class="docutils literal"&gt;顺序计数器&lt;/tt&gt; , 如果两次读到的值不相同, 说明新的写者已经开始写并增加了 &lt;tt class="docutils literal"&gt;顺序计数器&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;p237, 在内核更新Time的时候使用了顺序锁, 这时读者其实可以只读一次, 因为取到旧时间关系不大.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rcu"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id146"&gt;5.2.7&amp;nbsp;&amp;nbsp;&amp;nbsp;读-拷贝-更新 (RCU通过指针而不是锁)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不用锁:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RCU只保护被动态分配 通过指针引用的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读者几乎不做任何事情来防止竞争条件, 得靠写者.&lt;/p&gt;
&lt;p&gt;写着要更新数据结构时, 生成整个数据结构的副本, 写者修改这个副本, 修改完成后改变指针.&lt;/p&gt;
&lt;p&gt;改变指针是一个原子操作(我们在cruiser中需要动态加载配置的时候就是这样做的)&lt;/p&gt;
&lt;p&gt;写着修改指针后, 不能马上释放数据结构的旧副本, 因为写着修改时, 可能有读者拿着老指针呢.!!! &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--从前自己改这个模块的时候根本没意识到,&lt;/span&gt; 只是模仿了浩哥的代码&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id38"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id147"&gt;5.2.8&amp;nbsp;&amp;nbsp;&amp;nbsp;信号量&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;类似于自旋锁, 但是在锁的时候不是自旋, 而是挂起.&lt;/p&gt;
&lt;p&gt;信号量结构:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct semphore{
    atomic_t count;
    wait: 等待队列
    sleepers: 是否有进程在信号量上睡眠
}
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;__up&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;__down&lt;/tt&gt;&lt;/p&gt;
&lt;div class="section" id="completion"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id148"&gt;5.2.8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;补充原语(completion)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;类似信号量,&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id39"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id149"&gt;5.2.9&amp;nbsp;&amp;nbsp;&amp;nbsp;本地中断禁止&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="id40"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id150"&gt;5.2.10&amp;nbsp;&amp;nbsp;&amp;nbsp;本地软中断禁止&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronizing-accesses-to-kernel-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id151"&gt;5.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Synchronizing Accesses to Kernel Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;链表例子.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="examples-of-race-condition-prevention"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id152"&gt;5.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Examples of Race Condition Prevention&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;大内核锁.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c6-timing-measurements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id153"&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;c6 Timing Measurements&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="clock-and-timer-circuits"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id154"&gt;6.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Clock and Timer Circuits (几种硬件计时器)&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;实时时钟 RTC (CMOS时间 )&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;和CMOS在一个芯片上, 自带电池&lt;/li&gt;
&lt;li&gt;频率在2-8192Hz之间.&lt;/li&gt;
&lt;li&gt;IRQ8&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;时间戳计数器 TSC&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;64位&lt;/li&gt;
&lt;li&gt;每个时钟信号来加1&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;可编程间隔定时器 PIT (8254芯片)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Linux编程为 &lt;tt class="docutils literal"&gt;大约&lt;/tt&gt; 1000Hz, 向IRQ0发中断.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;CPU本地定时器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;高精度事件定时器 HPET&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;8个32/64位独立计数器, 硬件中还不普遍.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;PCPI电源管理定时器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核启动时会选择最好的一个计时器&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-linux-timekeeping-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id155"&gt;6.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Linux Timekeeping Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;内核使用两个函数:&lt;/p&gt;
&lt;p&gt;time()
gettimeofday()&lt;/p&gt;
&lt;p&gt;数据结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;timer_opts&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;描述硬件定时器(每种硬件一个这个结构)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;jiffies&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;每个时钟中断加一, &lt;strong&gt;内核就是设置为1000Hz&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;80x86中是32位, (2**32/80000*1000)大约50天回绕到0, 内核处理了溢出.&lt;/li&gt;
&lt;li&gt;jiffies 被初始化为0xfffb6c20(-300,000) 系统启动5分钟后回到0(使得哪些不对jiffies做校验的bug及早发现)&lt;/li&gt;
&lt;li&gt;jiffies通过连接器被转换为一个64为计数器的低32位, 这个64位计数器: jiffies_64&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;xtime (timespec类型 )&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;tv_sec (timestamp的秒数)&lt;/li&gt;
&lt;li&gt;tv_nsec (纳秒)&lt;/li&gt;
&lt;li&gt;初始化时用get_coms_time() 函数从 实时时钟读取.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id41"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id156"&gt;6.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;时钟中断时处理&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;需要判断是否丢失时钟中断.&lt;/li&gt;
&lt;li&gt;计算当前系统的负载(Load)&lt;/li&gt;
&lt;li&gt;更新xtime&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id42"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id157"&gt;6.2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;系统负载&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;单处理器: 0意味着没有活跃的进程(除了idle), 1意味着一个单独的进程100%占有cpu.&lt;/p&gt;
&lt;p&gt;大于1说明有几个进程处于running, 共享CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id43"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id158"&gt;6.2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;监管内核代码&lt;/a&gt;&lt;/h5&gt;
&lt;div class="section" id="readprofiler-hot-spot"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id159"&gt;6.2.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;readprofiler, 用于确定内核热点(hot spot).&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;监管器基于非常简单的 &lt;tt class="docutils literal"&gt;蒙特卡洛算法&lt;/tt&gt;, 每次时钟中断发生时, 内核确定中断是否发生在内核态, 如果是, 内核从堆栈取出eip寄存器值, 从而确定中断发生前内核正在做什么. 形成采样数据.&lt;/p&gt;
&lt;p&gt;启动内核时需要用 profile=N来开启prifile&lt;/p&gt;
&lt;p&gt;数据可以从 &lt;tt class="docutils literal"&gt;/proc/profile&lt;/tt&gt; 读取, 用 &lt;tt class="docutils literal"&gt;readprofile&lt;/tt&gt; 命令更方便&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="oprofile"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id160"&gt;6.2.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;oprofile&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;此外, 内核提供另一个监管器: &lt;tt class="docutils literal"&gt;oprofile&lt;/tt&gt;, 还可一监控用户态程序热点.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id44"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id161"&gt;6.2.1.2.3&amp;nbsp;&amp;nbsp;&amp;nbsp;检测死锁&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;通过非屏蔽中断NMI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id45"&gt;
&lt;h6&gt;&lt;a class="toc-backref" href="#id162"&gt;6.2.1.2.4&amp;nbsp;&amp;nbsp;&amp;nbsp;蒙特卡洛:&lt;/a&gt;&lt;/h6&gt;
&lt;p&gt;蒙特卡罗方法又称统计模拟法、随机抽样技术，是一种随机模拟方法，以概率和统计理论方法为基础的一种计算方法，是使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。&lt;/p&gt;
&lt;p&gt;这个词构忽悠,其实就是随机采样的意思.&lt;/p&gt;
&lt;p&gt;提出：&lt;/p&gt;
&lt;p&gt;蒙特卡罗方法于20世纪40年代美国在第二次世界大战中研制原子弹的“曼哈顿计划”计划的成员S.M.乌拉姆和J.冯·诺伊曼首先提出。数学家冯·诺伊曼用驰名世界的赌城—摩纳哥的Monte Carlo—来命名这种方法，为它蒙上了一层神秘色彩。在这之前，蒙特卡罗方法就已经存在。1777年，法国数学家布丰（Georges Louis Leclere de Buffon，1707—1788）提出用投针实验的方法求圆周率π。这被认为是蒙特卡罗方法的起源。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-the-time-and-date"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id163"&gt;6.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating the Time and Date&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-system-statistics"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id164"&gt;6.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Updating System Statistics&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="software-timers-and-delay-functions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id165"&gt;6.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Software Timers and Delay Functions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-timing-measurements"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id166"&gt;6.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Timing Measurements&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
time()
gettimeofday()
adjtimex()
settimer() / alarm()
&lt;/pre&gt;
&lt;p&gt;posix 相关系统调用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
clock_gettime()
...
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c7-process-scheduling"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id167"&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;c7 Process Scheduling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;亲和性:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sched_setaffinity()
sched_getaffinity()
&lt;/pre&gt;
&lt;div class="section" id="scheduling-policy"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id168"&gt;7.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Scheduling Policy&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-scheduling-algorithm"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id169"&gt;7.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Scheduling Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="data-structures-used-by-the-scheduler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id170"&gt;7.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Data Structures Used by the Scheduler&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;140个双向链表, 代表140个优先级,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="functions-used-by-the-scheduler-schedule"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id171"&gt;7.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Functions Used by the Scheduler(schedule)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;schedule 执行的前半部分和后半部分在两个进程中, 中间还有一段时间不属于任何一个进程.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id46"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id172"&gt;7.5&amp;nbsp;&amp;nbsp;&amp;nbsp;多处理器系统中 执行队列的平衡&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 一直使用对称多处理器模型(), 内核不应该对任何一个CPU有偏好(有点分布式系统中无master的意思)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;超线程:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;当前线程在访问内存的间隙, 处理器可以利用机器周期去执行另外一个线程,&lt;/li&gt;
&lt;li&gt;一个超线程的物理CPU可以被linux看作是几个逻辑CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;NUMA&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;把CPU和RAM以本地节点为单位分组(通常一个节点包括一个CPU和几个RAM芯片)&lt;/li&gt;
&lt;li&gt;CPU访问本地RAM非常快, 防伪其它节点就非常慢.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一般来说, 一个进程总是在一个CPU上执行, 但是也会在CPU之间迁移.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;任何一个可运行的进程都不会同时出现在两个或多个CPU的运行队列中, 一个保持可运行状态的进程通常被限制在一个固定的CPU上.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;内核周期性的检查运行队列是否平衡, 必要时迁移.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-scheduling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id173"&gt;7.6&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Scheduling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c8-memory-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id174"&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;c8 Memory Management&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="page-frame-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id175"&gt;8.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Frame Management&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;页描述符大小为32字节(放在mem_map中), 用于描述一个4k大小的页, 所以内存的(32/4k=0.8%)  的内存用于存放页描述符(被内核使用)&lt;/p&gt;
&lt;div class="section" id="numa"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id176"&gt;8.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;非一致内存访问(NUMA)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Non-Uniform Memory Access, 对比与80x86体系结构的UMA模型(一致性内存访问)&lt;/p&gt;
&lt;p&gt;NUMA中, 某个CPU对不同内存单元的访问时间可能不一样, 系统中的CPU和内存被划分为几个节点. 一个节点内的cpu访问自己节点的内存很快, 跨节点访问就很慢.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-area-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id177"&gt;8.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Area Management&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;slab分配器: 类似于 预分配/对象池 的概念&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把内存去看作对象, 有构造/析构函数.&lt;/li&gt;
&lt;li&gt;内核反复申请同一类型的内存区.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;slab着色 - 解决高速缓存颠簸的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="noncontiguous-memory-area-management"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id178"&gt;8.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Noncontiguous Memory Area Management&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c9-process-address-space"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id179"&gt;9&amp;nbsp;&amp;nbsp;&amp;nbsp;c9. Process Address Space&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-processs-address-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id180"&gt;9.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Process’s Address Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-memory-descriptor"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id181"&gt;9.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Memory Descriptor&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-regions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id182"&gt;9.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Regions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault-exception-handler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id183"&gt;9.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Page Fault Exception Handler&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-and-deleting-a-process-address-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id184"&gt;9.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating and Deleting a Process Address Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-the-heap"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id185"&gt;9.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing the Heap&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c10-system-calls"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id186"&gt;10&amp;nbsp;&amp;nbsp;&amp;nbsp;c10 System Calls&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="posix-apis-and-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id187"&gt;10.1&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX APIs and System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-call-handler-and-service-routines"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id188"&gt;10.2&amp;nbsp;&amp;nbsp;&amp;nbsp;System Call Handler and Service Routines&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="entering-and-exiting-a-system-call"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id189"&gt;10.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Entering and Exiting a System Call&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="parameter-passing"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id190"&gt;10.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Parameter Passing&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel-wrapper-routines"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id191"&gt;10.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Kernel Wrapper Routines&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c11-signals"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id192"&gt;11&amp;nbsp;&amp;nbsp;&amp;nbsp;c11. Signals&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-role-of-signals"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id193"&gt;11.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of Signals&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="generating-a-signal"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id194"&gt;11.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Generating a Signal&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="delivering-a-signal"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id195"&gt;11.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Delivering a Signal&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-calls-related-to-signal-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id196"&gt;11.4&amp;nbsp;&amp;nbsp;&amp;nbsp;System Calls Related to Signal Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c12-the-virtual-filesystem"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id197"&gt;12&amp;nbsp;&amp;nbsp;&amp;nbsp;c12 The Virtual Filesystem&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-role-of-the-virtual-filesystem-vfs"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id198"&gt;12.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Role of the Virtual Filesystem (VFS)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="vfs-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id199"&gt;12.2&amp;nbsp;&amp;nbsp;&amp;nbsp;VFS Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-types"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id200"&gt;12.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Types&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id201"&gt;12.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Filesystem Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="pathname-lookup"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id202"&gt;12.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Pathname Lookup&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="implementations-of-vfs-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id203"&gt;12.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementations of VFS System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="file-locking"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id204"&gt;12.7&amp;nbsp;&amp;nbsp;&amp;nbsp;File Locking&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c13-i-o-architecture-and-device-drivers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id205"&gt;13&amp;nbsp;&amp;nbsp;&amp;nbsp;c13. I/O Architecture and Device Drivers&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="i-o-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id206"&gt;13.1&amp;nbsp;&amp;nbsp;&amp;nbsp;I/O Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-device-driver-model"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id207"&gt;13.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Device Driver Model&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="device-files"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id208"&gt;13.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Files&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id209"&gt;13.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="character-device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id210"&gt;13.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Character Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c14-block-device-drivers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id211"&gt;14&amp;nbsp;&amp;nbsp;&amp;nbsp;c14. Block Device Drivers&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="block-devices-handling"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id212"&gt;14.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Devices Handling&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-generic-block-layer"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id213"&gt;14.2&amp;nbsp;&amp;nbsp;&amp;nbsp;The Generic Block Layer&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-i-o-scheduler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id214"&gt;14.3&amp;nbsp;&amp;nbsp;&amp;nbsp;The I/O Scheduler&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="block-device-drivers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id215"&gt;14.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Block Device Drivers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="opening-a-block-device-file"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id216"&gt;14.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Opening a Block Device File&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c15-the-page-cache"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id217"&gt;15&amp;nbsp;&amp;nbsp;&amp;nbsp;c15. The Page Cache&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-page-cache"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id218"&gt;15.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Cache&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="storing-blocks-in-the-page-cache"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id219"&gt;15.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Storing Blocks in the Page Cache&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-dirty-pages-to-disk"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id220"&gt;15.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Writing Dirty Pages to Disk&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-sync-fsync-and-fdatasync-system-calls"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id221"&gt;15.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The sync( ), fsync( ), and fdatasync() System Calls&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c16-accessing-files"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id222"&gt;16&amp;nbsp;&amp;nbsp;&amp;nbsp;c16. Accessing Files&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="reading-and-writing-a-file"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id223"&gt;16.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Reading and Writing a File&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-mapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id224"&gt;16.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Memory Mapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="direct-i-o-transfers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id225"&gt;16.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Direct I/O Transfers&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="asynchronous-i-o"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id226"&gt;16.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Asynchronous I/O&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c17-page-frame-reclaiming"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id227"&gt;17&amp;nbsp;&amp;nbsp;&amp;nbsp;c17. Page Frame Reclaiming&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="the-page-frame-reclaiming-algorithm"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id228"&gt;17.1&amp;nbsp;&amp;nbsp;&amp;nbsp;The Page Frame Reclaiming Algorithm&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="reverse-mapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id229"&gt;17.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Reverse Mapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="implementing-the-pfra"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id230"&gt;17.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Implementing the PFRA&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="swapping"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id231"&gt;17.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Swapping&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c18-the-ext2-and-ext3-filesystems"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id232"&gt;18&amp;nbsp;&amp;nbsp;&amp;nbsp;c18. The Ext2 and Ext3 Filesystems&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="general-characteristics-of-ext2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id233"&gt;18.1&amp;nbsp;&amp;nbsp;&amp;nbsp;General Characteristics of Ext2&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-disk-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id234"&gt;18.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Disk Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-memory-data-structures"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id235"&gt;18.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Memory Data Structures&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-the-ext2-filesystem"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id236"&gt;18.4&amp;nbsp;&amp;nbsp;&amp;nbsp;Creating the Ext2 Filesystem&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="ext2-methods"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id237"&gt;18.5&amp;nbsp;&amp;nbsp;&amp;nbsp;Ext2 Methods&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-ext2-disk-space"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id238"&gt;18.6&amp;nbsp;&amp;nbsp;&amp;nbsp;Managing Ext2 Disk Space&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-ext3-filesystem"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id239"&gt;18.7&amp;nbsp;&amp;nbsp;&amp;nbsp;The Ext3 Filesystem&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c19-process-communication"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id240"&gt;19&amp;nbsp;&amp;nbsp;&amp;nbsp;c19. Process Communication&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pipes"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id241"&gt;19.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Pipes&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="fifos"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id242"&gt;19.2&amp;nbsp;&amp;nbsp;&amp;nbsp;FIFOs&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="system-v-ipc"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id243"&gt;19.3&amp;nbsp;&amp;nbsp;&amp;nbsp;System V IPC&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="posix-message-queues"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id244"&gt;19.4&amp;nbsp;&amp;nbsp;&amp;nbsp;POSIX Message Queues&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="c20-program-execution"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id245"&gt;20&amp;nbsp;&amp;nbsp;&amp;nbsp;c20. Program Execution&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="executable-files"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id246"&gt;20.1&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Files&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="executable-formats"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id247"&gt;20.2&amp;nbsp;&amp;nbsp;&amp;nbsp;Executable Formats&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="execution-domains"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id248"&gt;20.3&amp;nbsp;&amp;nbsp;&amp;nbsp;Execution Domains&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="the-exec-functions"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id249"&gt;20.4&amp;nbsp;&amp;nbsp;&amp;nbsp;The exec Functions&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id47"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id250"&gt;21&amp;nbsp;&amp;nbsp;&amp;nbsp;总结&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;其实中文版翻译还算可以, 中文看不懂的地方, 去看英文版, 发现一样看不懂.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;不过看英文版映像深一些.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;读这本书, 需要和源码一起看&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;比如c2 内存寻址 里面详细列出了页表操作的宏定义, 读的时候就每必要细究.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;之前一致理解有内核和用户进程这两种东西&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;实际上, 应该是一个进程, 可以运行在用户态, 也可以运行在内核态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;当发起系统调用的时候, 进入内核态, 切换栈为内核栈,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;用户态只能访问本进程的部分线性地址空间.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;进入内核态后, 可以访问全部线性地址空间.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;还有一些进程是只在内核态运行的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;内核在运行中的代码形态(CPU执行内核代码的时候)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;初始化系统&lt;/li&gt;
&lt;li&gt;普通进程调用系统调用, 进入内核态, 用该进程的内核堆栈执行.&lt;/li&gt;
&lt;li&gt;几个内核线程&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;c5 Kernel Synchronization&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;对各种锁的介绍挺全面.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;自旋锁是锁里面最简单的一种,&lt;/li&gt;
&lt;li&gt;信号量是自旋锁的一种改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;对内存屏障的介绍, 看一遍就懂了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy</title><link href="/twemproxy.html" rel="alternate"></link><updated>2014-01-03T17:33:27+08:00</updated><author><name>ning</name></author><id>tag:,2014-01-03:twemproxy.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="auto-toc simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#twemporxy-nutcracker" id="id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Twemporxy(nutcracker) 介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;twemproxy 是一个 redis/memcache 代理. 实现sharding逻辑&lt;/p&gt;
&lt;div class="section" id="twemporxy-nutcracker"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;Twemporxy(nutcracker) 介绍&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2012.2月由twitter 开源:&lt;/li&gt;
&lt;li&gt;刚开始是只做 memcached 协议&lt;/li&gt;
&lt;li&gt;主要目标是作为分布式连接池, 减少后端连接.(数千前端, 都要连后端的memcached) =&amp;gt; 几个前端聚合用一个proxy.&lt;/li&gt;
&lt;li&gt;后端长连接&lt;/li&gt;
&lt;li&gt;config by YAML&lt;/li&gt;
&lt;li&gt;Use multiple hashing modes, including consistent hashing&lt;/li&gt;
&lt;li&gt;stats 统计信息.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>twemproxy代码分析</title><link href="/twemproxy-src.html" rel="alternate"></link><updated>2013-12-15T15:12:02+08:00</updated><author><name>ning</name></author><id>tag:,2013-12-15:twemproxy-src.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id47"&gt;调研&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id48"&gt;文章调研&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-twemproxy-a-redis-proxy-from-twitter" id="id49"&gt;Redis 作者:Twemproxy, a Redis proxy from Twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id50"&gt;存储分片和Twemproxy核心解读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-twemproxy-benchmark" id="id51"&gt;redis-twemproxy-benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id52"&gt;这个文章总结不错&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hash" id="id53"&gt;hash函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id54"&gt;配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#user" id="id55"&gt;user&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id56"&gt;不支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id57"&gt;代码分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id58"&gt;模块划分&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#event" id="id59"&gt;event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id60"&gt;请求处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#main" id="id61"&gt;main&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#os-utils" id="id62"&gt;os utils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ds-utils" id="id63"&gt;ds utils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id64"&gt;协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id65"&gt;hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id66"&gt;event 机制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#epool" id="id67"&gt;epool 实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#event-create" id="id68"&gt;上层对event_create 的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#event-wait" id="id69"&gt;上层对event_wait的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#libevent" id="id70"&gt;和libevent 对比&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id71"&gt;重要结构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#server-poolserver" id="id72"&gt;server_pool和server.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conn-msg-mbuf" id="id73"&gt;conn, msg, mbuf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conn" id="id74"&gt;conn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#msg" id="id75"&gt;msg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mbuf" id="id76"&gt;mbuf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id77"&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id78"&gt;请求处理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#core-core" id="id79"&gt;读写总控函数 core_core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#accept" id="id80"&gt;accept连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nc-connection-c" id="id81"&gt;nc_connection.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#messsage-c" id="id82"&gt;messsage.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id83"&gt;一个请求被处理的流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id17" id="id84"&gt;初始状态&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id18" id="id85"&gt;1.读取请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id19" id="id86"&gt;2.转发到后端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id20" id="id87"&gt;3.接收后端响应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#client" id="id88"&gt;4.把响应回给client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#buf" id="id89"&gt;buf处理上的特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id21" id="id90"&gt;后端如何处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id22" id="id91"&gt;协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id23" id="id92"&gt;hash&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id24" id="id93"&gt;具体hash函数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#crc32" id="id94"&gt;crc32&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hsieh" id="id95"&gt;hsieh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#jenkins-lookup3" id="id96"&gt;Jenkins lookup3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#jenkins-one-at-a-time" id="id97"&gt;Jenkins one_at_a_time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fnv-xxx" id="id98"&gt;FNV-XXX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#murmur" id="id99"&gt;murmur&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id25" id="id100"&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dispatch" id="id101"&gt;dispatch方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rbtree" id="id102"&gt;rbtree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mget" id="id103"&gt;如何处理mget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nginx" id="id104"&gt;代码严重受nginx影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id26" id="id105"&gt;(代码)小结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id27" id="id106"&gt;注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id28" id="id107"&gt;使用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id29" id="id108"&gt;编译&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#debug" id="id109"&gt;debug级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#core" id="id110"&gt;core的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id30" id="id111"&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id31" id="id112"&gt;配置参数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hashdistribution" id="id113"&gt;hash和distribution见前面分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#auto-eject-hosts" id="id114"&gt;auto_eject_hosts相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#timeout" id="id115"&gt;timeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#log" id="id116"&gt;log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mbuf-size" id="id117"&gt;mbuf size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#max-key-lenght" id="id118"&gt;max key lenght&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#server-connections-1" id="id119"&gt;server_connections: &amp;gt; 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id32" id="id120"&gt;监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#redis-mgr" id="id121"&gt;使用redis-mgr部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id33" id="id122"&gt;日志级别&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id34" id="id123"&gt;修改日志级别:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id35" id="id124"&gt;2.动态调整日志级别:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id36" id="id125"&gt;3.切日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id37" id="id126"&gt;自己实现一个自动的主从切换?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#sentinel" id="id127"&gt;sentinel验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id38" id="id128"&gt;配置和优化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#m-512" id="id129"&gt;-m 512&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id39" id="id130"&gt;问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#preconnect-true-redis-core" id="id131"&gt;preconnect: true 的时候, 如果后端redis挂掉, 会core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pipeline-replay" id="id132"&gt;pipeline/replay时消耗大量内存:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mgetcase" id="id133"&gt;mget慢这个case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id40" id="id134"&gt;应该允许释放mbuf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id41" id="id135"&gt;#一轮完了再集中加事件, 不要多次加, 重复加&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id42" id="id136"&gt;#可能的优化:mget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id43" id="id137"&gt;改造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#key" id="id138"&gt;key过长回错误&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id44" id="id139"&gt;社区情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id45" id="id140"&gt;小结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id46" id="id141"&gt;期望&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id47"&gt;调研&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id48"&gt;文章调研&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="redis-twemproxy-a-redis-proxy-from-twitter"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id49"&gt;Redis 作者:Twemproxy, a Redis proxy from Twitter&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antirez.com/news/44"&gt;http://antirez.com/news/44&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;计划中的redis-cluster: Multiple instances is a share-nothing architecture.&lt;/li&gt;
&lt;li&gt;2.6 中实现了Redis Sentinel, 即将实现 partial resynchronization&lt;/li&gt;
&lt;li&gt;Twemproxy 是 single-threaded proxy&lt;/li&gt;
&lt;li&gt;What's awesome about Twemproxy is that it can be configured both to disable nodes on failure, and retry after some time&lt;/li&gt;
&lt;li&gt;失败时, 可以disable 或者 retry
- 作为data store : retry
- 作为cache: disable(node-ejection)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样的一组后端, 可以配成两种:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
redis1:
  listen: 0.0.0.0:9999
  redis: true
  hash: fnv1a_64
  distribution: ketama
  auto_eject_hosts: true
  timeout: 400
  server_retry_timeout: 2000
  server_failure_limit: 1
  servers:
   - 127.0.0.1:6379:1
   - 127.0.0.1:6380:1
   - 127.0.0.1:6381:1
   - 127.0.0.1:6382:1

redis2:
  listen: 0.0.0.0:10000
  redis: true
  hash: fnv1a_64
  distribution: ketama
  auto_eject_hosts: false
  timeout: 400
  servers:
   - 127.0.0.1:6379:1
   - 127.0.0.1:6380:1
   - 127.0.0.1:6381:1
   - 127.0.0.1:6382:1
&lt;/pre&gt;
&lt;p&gt;限制:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;不支持 mset, transaction:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
I think that twemproxy do it right, not supporting multiple keys commands nor transactions. Currently is AFAIK even more strict than Redis Cluster that instead allows MULTI/EXEC blocks if all the commands are about the same key.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;对mget, mdel 支持, 性能待测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
However there is some support for commands with multiple keys. MGET and DEL are handled correctly. Interestingly MGET will split the request among different servers and will return the reply as a single entity. This is pretty cool even if I don't get the right performance numbers with this feature (see later).

So I expected to see almost the same numbers with an MGET as I see when I run the MGET against a single instance
but I get only 50% of the operations per second. Maybe it's the time to reconstruct the reply, I'm not sure.

mget 只有50%
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;不支持EVAL,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;错误处理: (antirez 测试还挺认真)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;non supported command: closes the connection.&lt;/li&gt;
&lt;li&gt;sending just a &amp;quot;GET&amp;quot;: hang&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望: 支持HA&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;能直接做主从切换.&lt;/li&gt;
&lt;li&gt;配置热加载也可以啊~ (checking the Sentinel configuration regularly to upgrade the servers table if a failover happened.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能: 好!!!&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;This Thing Is Fast. Really fast, it is almost as fast as talking directly with Redis. I would say you lose 20% of performances at worst.&lt;/li&gt;
&lt;li&gt;MGET可以优化 (目前性能降低50%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论:
- I strongly suggest Redis users to give it a try.&lt;/p&gt;
&lt;p&gt;人们的讨论:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于MGET: The response time will then be &lt;em&gt;at least&lt;/em&gt; as slow as the slowest node&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id50"&gt;存储分片和Twemproxy核心解读&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.wzxue.com/%E5%AD%98%E5%82%A8%E5%88%86%E7%89%87%E5%92%8Ctwemproxy%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB/"&gt;http://www.wzxue.com/%E5%AD%98%E5%82%A8%E5%88%86%E7%89%87%E5%92%8Ctwemproxy%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;antirez(Redis作者)写过一篇对twemproxy的介绍http://antirez.com/news/44, 他认为twemproxy是目前Redis 分片管理的最好方案，虽然antirez的Redis cluster正在实现并且对其给予厚望&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;涉及到三个重要的结构:server, connection, message。&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;每个server其实就是一个后端的缓存服务程序&lt;/li&gt;
&lt;li&gt;connection在Twemproxy中非常重要，它分为三种类型的connection:proxy，client和server&lt;/li&gt;
&lt;li&gt;struct msg是连接建立后的消息内容发送载体，这个复杂的msg结构很大程度是因为需要实现pipeline的效果，多个msg属于同一个conn，conn通过接收到内容解析来发现几个不同的msg。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Twemproxy的架构比较清晰，对Twemproxy源码印象较深的是对logging的合理布局和错误处理的清晰，这是第一次看大公司开源出来的代码，非常重视logging和错误处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;我的fork: 由于Twitter开源的Twemproxy直接使用epoll驱动，导致其他不支持epoll的系统无法使用，因此我fork了一个版本，加入了kqueue支持，让FreeBSD和Mac os x能够成功编译运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这位同学2013.10 还是一个大四学生.
github 上人气挺高: &lt;a class="reference external" href="https://github.com/yuyuyu101"&gt;https://github.com/yuyuyu101&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-twemproxy-benchmark"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id51"&gt;redis-twemproxy-benchmark&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="http://blog.jpush.cn/redis-twemproxy-benchmark/"&gt;http://blog.jpush.cn/redis-twemproxy-benchmark/&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;twemproxy 可以开http监控端口: &lt;a class="reference external" href="http://ip:22222"&gt;http://ip:22222&lt;/a&gt; json格式&lt;/li&gt;
&lt;li&gt;性能基本和单台一样.&lt;/li&gt;
&lt;li&gt;多个twemproxy 实例, 性能可以更好.&lt;/li&gt;
&lt;li&gt;不支持除mget，del之外的redis批处理命令，如取多个集合交集等等&lt;/li&gt;
&lt;li&gt;不支持脚本eval&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id52"&gt;这个文章总结不错&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class="reference external" href="http://cloudaice.com/twemproxy-explore/"&gt;http://cloudaice.com/twemproxy-explore/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;redis-proxy&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;使用node写的redis代理层。&lt;/li&gt;
&lt;li&gt;支持主从节点的失败处理（可以仔细研究）&lt;/li&gt;
&lt;li&gt;测试后发现性能为原生的1/3&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;twemproxy&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;支持失败节点自动删除&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;可以设置重新连接该节点的时间&lt;/li&gt;
&lt;li&gt;可以设置连接多少次之后删除该节点&lt;/li&gt;
&lt;li&gt;该方式适合作为cache存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持设置HashTag&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;通过HashTag可以自己设定将两个KEYhash到同一个实例上去。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;减少与redis的直接连接数&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;保持与redis的长连接&lt;/li&gt;
&lt;li&gt;可设置代理与后台每个redis连接的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;自动分片到后端多个redis实例上&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多种hash算法（部分还没有研究明白)&lt;/li&gt;
&lt;li&gt;可以设置后端实例的权重&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;避免单点问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;可以平行部署多个代理层.client自动选择可用的一个&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持redis pipelining request&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持状态监控&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;可设置状态监控ip和端口，访问ip和端口可以得到一个json格式的状态信息串&lt;/li&gt;
&lt;li&gt;可设置监控信息刷新间隔时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;高吞吐量&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;连接复用，内存复用。&lt;/li&gt;
&lt;li&gt;将多个连接请求，组成reids pipelining统一向redis请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置部署建议: 编译时候打开logging模块。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="hash"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;hash函数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;hash:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;one_at_a_time&lt;/li&gt;
&lt;li&gt;md5&lt;/li&gt;
&lt;li&gt;crc16&lt;/li&gt;
&lt;li&gt;crc32 (crc32 implementation compatible with libmemcached)&lt;/li&gt;
&lt;li&gt;crc32a (correct crc32 implementation as per the spec)&lt;/li&gt;
&lt;li&gt;fnv1_64&lt;/li&gt;
&lt;li&gt;fnv1a_64&lt;/li&gt;
&lt;li&gt;fnv1_32&lt;/li&gt;
&lt;li&gt;fnv1a_32&lt;/li&gt;
&lt;li&gt;hsieh&lt;/li&gt;
&lt;li&gt;murmur&lt;/li&gt;
&lt;li&gt;jenkins&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id54"&gt;配置&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
delta:
  listen: 127.0.0.1:22124
  hash: fnv1a_64
  distribution: ketama
  timeout: 100
  auto_eject_hosts: true
  server_retry_timeout: 2000
  server_failure_limit: 1
  servers:
   - 127.0.0.1:11214:1
   - 127.0.0.1:11215:1
   - 127.0.0.1:11216:1
   - 127.0.0.1:11217:1
   - 127.0.0.1:11218:1
   - 127.0.0.1:11219:1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="user"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id55"&gt;user&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;li&gt;Pinterest&lt;/li&gt;
&lt;li&gt;Tumblr&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id56"&gt;不支持&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;auth&lt;/li&gt;
&lt;li&gt;mset&lt;/li&gt;
&lt;li&gt;eval&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id57"&gt;代码分析&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id58"&gt;模块划分&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;核心是 &lt;tt class="docutils literal"&gt;event&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;请求处理&lt;/tt&gt; 这两块&lt;/p&gt;
&lt;div class="section" id="event"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id59"&gt;event&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./event
./event/Makefile.am
./event/nc_epoll.c
./event/nc_event.h
./event/nc_evport.c
./event/nc_kqueue.c
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id60"&gt;请求处理&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./nc_proxy.c
./nc_proxy.h

./nc_connection.c
./nc_connection.h
./nc_client.c
./nc_client.h
./nc_server.c
./nc_server.h

./nc_message.c
./nc_message.h
./nc_request.c
./nc_response.c

./nc_mbuf.c
./nc_mbuf.h
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="main"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id61"&gt;main&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;./nc.c, 处理daemon, pidfile, args, config, 最后:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nc_run(struct instance *nci)
{
    ctx = core_start(nci);
    for (;;) {
        status = core_loop(ctx);
        if (status != NC_OK) {
            break;
        }
    }
    core_stop(ctx);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="os-utils"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id62"&gt;os utils&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./nc_conf.c
./nc_conf.h
./nc_core.c
./nc_core.h
./nc_log.c
./nc_log.h
./nc_signal.c
./nc_signal.h
./nc_stats.c
./nc_stats.h
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ds-utils"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id63"&gt;ds utils&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./nc_array.c
./nc_array.h
./nc_util.c
./nc_util.h
./nc_queue.h
./nc_rbtree.c
./nc_rbtree.h
./nc_string.c
./nc_string.h
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id64"&gt;协议&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./proto/nc_proto.h
./proto/nc_memcache.c
./proto/nc_redis.c
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id65"&gt;hash&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
./hashkit/nc_crc16.c
./hashkit/nc_crc32.c
./hashkit/nc_fnv.c
./hashkit/nc_hashkit.h
./hashkit/nc_hsieh.c
./hashkit/nc_jenkins.c
./hashkit/nc_ketama.c
./hashkit/nc_md5.c
./hashkit/nc_modula.c
./hashkit/nc_murmur.c
./hashkit/nc_one_at_a_time.c
./hashkit/nc_random.c
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id66"&gt;event 机制&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
struct event_base {
    int                ep;      /* epoll descriptor */
    struct epoll_event *event;  /* event[] - events that were triggered */
    int                nevent;  /* # event */
    event_cb_t         cb;      /* event callback */
};


struct event_base *event_base_create(int size, event_cb_t cb);
void event_base_destroy(struct event_base *evb);

int event_add_in(struct event_base *evb, struct conn *c);
int event_del_in(struct event_base *evb, struct conn *c);
int event_add_out(struct event_base *evb, struct conn *c);
int event_del_out(struct event_base *evb, struct conn *c);
int event_add_conn(struct event_base *evb, struct conn *c);
int event_del_conn(struct event_base *evb, struct conn *c);
int event_wait(struct event_base *evb, int timeout);
void event_loop_stats(event_stats_cb_t cb, void *arg);
&lt;/pre&gt;
&lt;div class="section" id="epool"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id67"&gt;epool 实现&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;event_base_create:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct event_base *
event_base_create(int nevent, event_cb_t cb)
{
    struct event_base *evb = nc_alloc(sizeof(*evb));
    int ep = epoll_create(nevent);
    struct epoll_event *event = nc_calloc(nevent, sizeof(*event));

    evb-&amp;gt;ep = ep;
    evb-&amp;gt;event = event;
    evb-&amp;gt;nevent = nevent;
    evb-&amp;gt;cb = cb;

    return evb;
}

int
event_add_in(struct event_base *evb, struct conn *c)
{
    struct epoll_event event;
    event.events = (uint32_t)(EPOLLIN | EPOLLET);
    event.data.ptr = c;

    status = epoll_ctl(evb-&amp;gt;ep, EPOLL_CTL_MOD, c-&amp;gt;sd, &amp;amp;event);
}

int
event_wait(struct event_base *evb, int timeout)
{
    int ep = evb-&amp;gt;ep;
    struct epoll_event *event = evb-&amp;gt;event;
    int nevent = evb-&amp;gt;nevent;

    for (;;) {
        int i, nsd;

        nsd = epoll_wait(ep, event, nevent, timeout);
        if (nsd &amp;gt; 0) {
            for (i = 0; i &amp;lt; nsd; i++) {
                struct epoll_event *ev = &amp;amp;evb-&amp;gt;event[i];
                uint32_t events = 0;

                log_debug(LOG_VVERB, &amp;quot;epoll %04&amp;quot;PRIX32&amp;quot; triggered on conn %p&amp;quot;,
                          ev-&amp;gt;events, ev-&amp;gt;data.ptr);

                if (ev-&amp;gt;events &amp;amp; EPOLLERR) {
                    events |= EVENT_ERR;
                }

                if (ev-&amp;gt;events &amp;amp; (EPOLLIN | EPOLLHUP)) {
                    events |= EVENT_READ;
                }

                if (ev-&amp;gt;events &amp;amp; EPOLLOUT) {
                    events |= EVENT_WRITE;
                }

                if (evb-&amp;gt;cb != NULL) {
                    evb-&amp;gt;cb(ev-&amp;gt;data.ptr, events);
                }
            }
            return nsd;
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;每次调用event_wait, 如果没有事件则一直等, 如果有事件, 调用回调，并返回.&lt;/p&gt;
&lt;p&gt;注意: 这里用的都是边缘触发 EPOLLET (redis本身用的是水平触发)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="event-create"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id68"&gt;上层对event_create 的使用&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
core_ctx_create(){
    /* initialize server pool from configuration */  pool 是一种隔离单位
    status = server_pool_init(&amp;amp;ctx-&amp;gt;pool, &amp;amp;ctx-&amp;gt;cf-&amp;gt;pool, ctx);

    ctx-&amp;gt;evb = event_base_create(EVENT_SIZE, &amp;amp;core_core); //这里有个EVENT_SIZE 是1024, core_core 是一个基础回调, 处理读写.
    status = server_pool_preconnect(ctx);
    status = proxy_init(ctx);
}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
ctx-&amp;gt;evb = event_base_create(EVENT_SIZE, &amp;amp;core_core); //这里有个EVENT_SIZE 是1024, 在epool里面没用, 设置的回调 core_core 是一个基础回调, 处理读写.
&lt;/pre&gt;
&lt;p&gt;event_add_in里面, &lt;tt class="docutils literal"&gt;data.ptr&lt;/tt&gt; 是一个conn数据结构,&lt;/p&gt;
&lt;p&gt;所以，有事件的时候, 调用  &lt;tt class="docutils literal"&gt;core_core(conn, events)&lt;/tt&gt;, 这里events 说明是读还是写事件.&lt;/p&gt;
&lt;p&gt;接下来的 &lt;tt class="docutils literal"&gt;proxy_init&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
proxy_each_init(void *elem, void *data) {
    struct server_pool *pool = elem;
    struct conn *p;

    p = conn_get_proxy(pool); //获得一个proxy类型的 conn, 它的回调设置: conn-&amp;gt;recv = proxy_recv;
    status = proxy_listen(pool-&amp;gt;ctx, p); //做bind/listen/set noblocking/加到epool
}
&lt;/pre&gt;
&lt;p&gt;这里设置的回调 proxy_recv, 就是做accept, 建立与客户端的连接:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
proxy_recv(struct context *ctx, struct conn *conn)
{
    conn-&amp;gt;recv_ready = 1;
    do {
        status = proxy_accept(ctx, conn);
        if (status != NC_OK) {
            return status;
        }
    } while (conn-&amp;gt;recv_ready);
    return NC_OK;
}
&lt;/pre&gt;
&lt;p&gt;用proxy_accept 与客户端建立连接, 获得client 类型的conn, 并且加入到事件队列:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static rstatus_t
proxy_accept(struct context *ctx, struct conn *p) {
    rstatus_t status;
    struct conn *c;
    int sd;

    for (;;) {//死循环去做. 不带sleep!!
        sd = accept(p-&amp;gt;sd, NULL, NULL);
        if (sd &amp;lt; 0) {
            ...
            return NC_ERROR;
        }
        break;
    }

    c = conn_get(p-&amp;gt;owner, true, p-&amp;gt;redis); //获得一个client类型的连接
    c-&amp;gt;sd = sd;

    status = nc_set_nonblocking(c-&amp;gt;sd);
    status = event_add_conn(ctx-&amp;gt;evb, c);

    return NC_OK;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="event-wait"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id69"&gt;上层对event_wait的使用&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
core_loop(struct context *ctx)
{
    nsd = event_wait(ctx-&amp;gt;evb, ctx-&amp;gt;timeout);
    ...
}
&lt;/pre&gt;
&lt;p&gt;超清晰的主循环:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void
nc_run(struct instance *nci)
{
    rstatus_t status;
    struct context *ctx;

    ctx = core_start(nci);
    if (ctx == NULL) {
        return;
    }

    /* run rabbit run */
    for (;;) {
        status = core_loop(ctx);
        if (status != NC_OK) {
            break;
        }
    }

    core_stop(ctx);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="libevent"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id70"&gt;和libevent 对比&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;从数据结构, 函数命令来看, 受到libevnet和nginx的强烈影响.&lt;/p&gt;
&lt;p&gt;(redis是自己的事件框架, memcached 就是用libevent作为事件框架)&lt;/p&gt;
&lt;p&gt;libevent 的结构大概是这样的(不准确)&lt;/p&gt;
&lt;p&gt;event, 类似连接的概念:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct event {
    TAILQ_ENTRY (event) ev_next;
    TAILQ_ENTRY (event) ev_active_next;
    TAILQ_ENTRY (event) ev_signal_next;
    unsigned int min_heap_idx;  /* for managing timeouts */

    struct event_base *ev_base;

    int ev_fd;
    short ev_events;
&lt;/pre&gt;
&lt;p&gt;event_base是暴露给外面的统一接口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct event_base {
    const struct eventop *evsel;
    void *evbase;
    int event_count;        /* counts number of total events */
    int event_count_active; /* counts number of active events */
    ...
}
&lt;/pre&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//获得listen_fd
listen_fd = network_server_socket(cfg-&amp;gt;listen_host, cfg-&amp;gt;listen_port);

struct event *ev_accept;
ev_accept = event_new(g_server.event_base, listen_fd, EV_READ | EV_PERSIST, on_accept, NULL);
event_add(ev_accept, NULL);
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id71"&gt;重要结构&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="server-poolserver"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id72"&gt;server_pool和server.&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在 &lt;tt class="docutils literal"&gt;server_pool.h&lt;/tt&gt; 中注释写的非常清楚, 还有示意图:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
*  +-------------+
*  |             |&amp;lt;---------------------+
*  |             |&amp;lt;------------+        |
*  |             |     +-------+--+-----+----+--------------+
*  |   pool 0    |+---&amp;gt;|          |          |              |
*  |             |     | server 0 | server 1 | ...     ...  |
*  |             |     |          |          |              |--+
*  |             |     +----------+----------+--------------+  |
*  +-------------+                                             //
*  |             |
*  |             |
*  |             |
*  |   pool 1    |
*  |             |
*  |             |
*  |             |
*  +-------------+
*  |             |
*  |             |
*  .             .
*  .    ...      .
*  .             .
*  |             |
*  |             |
*  +-------------+
*            |
*            |
*            //
&lt;/pre&gt;
&lt;p&gt;看看twemproxy的配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
s1:
  listen: 127.0.0.1:22124
  servers:
   - 127.0.0.1:11214:1
   - 127.0.0.1:11215:1
   - 127.0.0.1:11216:1
   - 127.0.0.1:11217:1
s2:
  listen: 127.0.0.1:22125
   - 127.0.0.1:11218:1
   - 127.0.0.1:11219:1
&lt;/pre&gt;
&lt;p&gt;这样的配置就对应着类似这样的结构:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-server_pool.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="conn-msg-mbuf"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id73"&gt;conn, msg, mbuf&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="conn"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id74"&gt;conn&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;前面event机制提供的事件注册接口, 注册的事件都是在conn上的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int event_add_in(struct event_base *evb, struct conn *c);
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
struct conn {
    TAILQ_ENTRY(conn)  conn_tqe;      /* link in server_pool / server / free q */
    void               *owner;        /* connection owner - server_pool / server */
                                     //对于client和proxy, conn-&amp;gt;owner 是server_pool 对象
                                     //对于server, conn-&amp;gt;owner 是一个server 对象
    ..
    struct msg_tqh     imsg_q;        /* incoming request Q */
    struct msg_tqh     omsg_q;        /* outstanding request Q */

    conn_recv_t        recv;          /* recv (read) handler */
    conn_recv_next_t   recv_next;     /* recv next message handler */
    conn_recv_done_t   recv_done;     /* read done handler */
    conn_send_t        send;          /* send (write) handler */
    conn_send_next_t   send_next;     /* write next message handler */
    conn_send_done_t   send_done;     /* write done handler */
    conn_close_t       close;         /* close handler */
    conn_active_t      active;        /* active? handler */
    ...
};
&lt;/pre&gt;
&lt;p&gt;conn有三种:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;proxy : 代表proxy监听的端口&lt;/li&gt;
&lt;li&gt;client: 代表一个client连接.&lt;/li&gt;
&lt;li&gt;server: 代表一个后端连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种conn的获取方式和事件处理钩子不一样:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;listen&lt;/strong&gt;: 通过 &lt;tt class="docutils literal"&gt;conn_get_proxy(void *owner)&lt;/tt&gt; 获取, 只指定了这几个函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;recv = proxy_recv;
conn-&amp;gt;close = proxy_close;
conn-&amp;gt;ref = proxy_ref;
conn-&amp;gt;unref = proxy_unref;
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;client&lt;/strong&gt;: 通过 &lt;tt class="docutils literal"&gt;conn_get(void *owner, bool client=true, bool redis)&lt;/tt&gt; 获取:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;recv = msg_recv;
conn-&amp;gt;recv_next = req_recv_next;    //分配下一个读缓冲区.
conn-&amp;gt;recv_done = req_recv_done;

conn-&amp;gt;send = msg_send;
conn-&amp;gt;send_next = rsp_send_next;
conn-&amp;gt;send_done = rsp_send_done;
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;server&lt;/strong&gt;: , 通过 &lt;tt class="docutils literal"&gt;conn_get(void *owner, bool client=false, bool redis)&lt;/tt&gt; 获取:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;recv = msg_recv;
conn-&amp;gt;recv_next = rsp_recv_next;
conn-&amp;gt;recv_done = rsp_recv_done;

conn-&amp;gt;send = msg_send;
conn-&amp;gt;send_next = req_send_next;
conn-&amp;gt;send_done = req_send_done;
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="msg"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id75"&gt;msg&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;msg代表一个请求体, 或者一个response, 对于mget之类, 它还会代表原request解析后的一个子request:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct msg {
    TAILQ_ENTRY(msg)     c_tqe;           /* link in client q */
    TAILQ_ENTRY(msg)     s_tqe;           /* link in server q */
    TAILQ_ENTRY(msg)     m_tqe;           /* link in send q / free q */

    uint64_t             id;              /* message id */
    struct msg           *peer;           /* message peer */
    struct conn          *owner;          /* message owner - client | server */

    struct rbnode        tmo_rbe;         /* entry in rbtree */

    struct mhdr          mhdr;            /* message mbuf header */
    uint32_t             mlen;            /* message length */
    ...
};
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="mbuf"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id76"&gt;mbuf&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;msg中用来保存请求/响应 内容的链表, 每个mbuf大小默认是16K, 可以配置, 范围在 &lt;tt class="docutils literal"&gt;512B - 64K&lt;/tt&gt; 之间&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id77"&gt;小结&lt;/a&gt;&lt;/h5&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;server_pool里面保存该pool上面所有client_conn的链表,&lt;/li&gt;
&lt;li&gt;server里面保存该server上所有server_conn的链表.&lt;/li&gt;
&lt;li&gt;conn里面的msg会分为in_q, 和out_q 两个msg链表&lt;/li&gt;
&lt;li&gt;每个msg会同时存在与一个client_conn的out_q 和server_conn的in_q里面&lt;/li&gt;
&lt;li&gt;msg中消息保存在mbuf链表中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;conn和msg的结构:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-conn-msg-struct.png" /&gt;
&lt;p&gt;他们的关系:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-conn-msg.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id78"&gt;请求处理&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
./nc_connection.h
./nc_connection.c       //三种连接类型, 对象池处理(conn_get, conn_put), 底层读写(conn_recv, conn_sendv)

./nc_proxy.h
./nc_proxy.c            //建立listen socket(proxy_init), 对新连接做accetp (proxy_recv)

./nc_client.h
./nc_client.c           //判断是否有东西要写给client

./nc_server.h
./nc_server.c           //server, server_pool, 连接后端(server_connect), 后端的连接管理(server_pool_conn)

./nc_message.h
./nc_message.c          //msg 结构.

./nc_request.c
./nc_response.c         //对应的forward, filter 函数

./nc_mbuf.h
./nc_mbuf.c             //msg使用的buf.
&lt;/pre&gt;
&lt;div class="section" id="core-core"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id79"&gt;读写总控函数 core_core&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
core_core(void *arg, uint32_t events)
{
    conn-&amp;gt;events = events;
    if (events &amp;amp; EVENT_ERR) {
        core_error(ctx, conn);
        return NC_ERROR;
    }

    /* read takes precedence over write */
    if (events &amp;amp; EVENT_READ) {
        status = core_recv(ctx, conn); // //简单直接调用 conn-&amp;gt;recv
    }
    if (events &amp;amp; EVENT_WRITE) {
        status = core_send(ctx, conn); // //简单直接调用 conn-&amp;gt;send
    }

    return NC_OK;
}
&lt;/pre&gt;
&lt;p&gt;核心就是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;recv&lt;/span&gt;&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;send&lt;/span&gt;&lt;/tt&gt;, 以及它们的变化.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="accept"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id80"&gt;accept连接&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;前面讲到proxy_init通过:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
p = conn_get_proxy(pool); 获得一个proxy类型的 conn, 它的回调设置: conn-&amp;gt;recv = proxy_recv;
&lt;/pre&gt;
&lt;p&gt;在 proxy_accept 中 accetp到一个连接后, 又通过:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
c = conn_get(p-&amp;gt;owner, true, p-&amp;gt;redis);
&lt;/pre&gt;
&lt;p&gt;获得一个client类型的conn, 这里会把conn-&amp;gt;recv设置为 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conn-&amp;gt;recv&lt;/span&gt; = msg_recv&lt;/tt&gt;, 有数据发来时，就会调用 msg_recv&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nc-connection-c"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id81"&gt;nc_connection.c&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;很赞的注释:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
*                   nc_connection.[ch]
*                Connection (struct conn)
*                 +         +          +
*                 |         |          |
*                 |       Proxy        |
*                 |     nc_proxy.[ch]  |
*                 /                    \
*              Client                Server
*           nc_client.[ch]         nc_server.[ch]
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="messsage-c"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id82"&gt;messsage.c&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
*            nc_message.[ch]
*        _message (struct msg)
*            +        +            .
*            |        |            .
*            /        \            .
*         Request    Response      .../ nc_mbuf.[ch]  (mesage buffers)
*      nc_request.c  nc_response.c .../ nc_memcache.c; nc_redis.c (_message parser)

* Messages in nutcracker are manipulated by a chain of processing handlers,
* where each handler is responsible for taking the input and producing an
* output for the next handler in the chain. This mechanism of processing
* loosely conforms to the standard chain-of-responsibility design pattern

*             Client+             Proxy           Server+
*                              (nutcracker)
*                                   .
*       msg_recv {read event}       .       msg_recv {read event}
*         +                         .                         +
*         |                         .                         |
*         \                         .                         /
*         req_recv_next             .             rsp_recv_next
*           +                       .                       +
*           |                       .                       |       Rsp
*           req_recv_done           .           rsp_recv_done      &amp;lt;===
*             +                     .                     +
*             |                     .                     |
*    Req      \                     .                     /
*    ===&amp;gt;     req_filter*           .           *rsp_filter
*               +                   .                   +
*               |                   .                   |
*               \                   .                   /
*               req_forward-//  (1) . (3)  \\-rsp_forward
*                                   .
*                                   .
*       msg_send {write event}      .      msg_send {write event}
*         +                         .                         +
*         |                         .                         |
*    Rsp' \                         .                         /     Req'
*   &amp;lt;===  rsp_send_next             .             req_send_next     ===&amp;gt;
*           +                       .                       +
*           |                       .                       |
*           \                       .                       /
*           rsp_send_done-//    (4) . (2)    //-req_send_done
*
*
* (1) -&amp;gt; (2) -&amp;gt; (3) -&amp;gt; (4) is the normal flow of transaction consisting
* of a single request response, where (1) and (2) handle request from
* client, while (3) and (4) handle the corresponding response from the
* server.
&lt;/pre&gt;
&lt;p&gt;好有爱的注释!!&lt;/p&gt;
&lt;p&gt;对应这段注释的代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct conn *
conn_get(void *owner, bool client, bool redis)
{
    struct conn *conn;

    conn = _conn_get();

    conn-&amp;gt;client = client ? 1 : 0;

    if (conn-&amp;gt;client) {
        /*
         * client receives a request, possibly parsing it, and sends a
         * response downstream.
         */
        conn-&amp;gt;recv = msg_recv;
        conn-&amp;gt;recv_next = req_recv_next;
        conn-&amp;gt;recv_done = req_recv_done;

        conn-&amp;gt;send = msg_send;
        conn-&amp;gt;send_next = rsp_send_next;
        conn-&amp;gt;send_done = rsp_send_done;

        conn-&amp;gt;close = client_close;
        conn-&amp;gt;active = client_active;

        conn-&amp;gt;ref = client_ref;
        conn-&amp;gt;unref = client_unref;

        conn-&amp;gt;enqueue_inq = NULL;
        conn-&amp;gt;dequeue_inq = NULL;
        conn-&amp;gt;enqueue_outq = req_client_enqueue_omsgq;
        conn-&amp;gt;dequeue_outq = req_client_dequeue_omsgq;
    } else {
        /*
         * server receives a response, possibly parsing it, and sends a
         * request upstream.
         */
        conn-&amp;gt;recv = msg_recv;
        conn-&amp;gt;recv_next = rsp_recv_next;
        conn-&amp;gt;recv_done = rsp_recv_done;

        conn-&amp;gt;send = msg_send;
        conn-&amp;gt;send_next = req_send_next;
        conn-&amp;gt;send_done = req_send_done;

        conn-&amp;gt;close = server_close;
        conn-&amp;gt;active = server_active;

        conn-&amp;gt;ref = server_ref;
        conn-&amp;gt;unref = server_unref;

        conn-&amp;gt;enqueue_inq = req_server_enqueue_imsgq;
        conn-&amp;gt;dequeue_inq = req_server_dequeue_imsgq;
        conn-&amp;gt;enqueue_outq = req_server_enqueue_omsgq;
        conn-&amp;gt;dequeue_outq = req_server_dequeue_omsgq;
    }

    conn-&amp;gt;ref(conn, owner);

    return conn;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id83"&gt;一个请求被处理的流程&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们按照 messsage.c 里面的4个步骤&lt;/p&gt;
&lt;p&gt;后面的图都采用这样的表示方法:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-step-desc.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id84"&gt;初始状态&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;考察只有一个后端的情况, 假设有2个client要发送3个请求过来&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-state-0.png" /&gt;
&lt;div class="section" id="id18"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id85"&gt;1.读取请求&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;此时回调函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;recv = msg_recv;
conn-&amp;gt;recv_next = req_recv_next;
conn-&amp;gt;recv_done = req_recv_done;
&lt;/pre&gt;
&lt;p&gt;函数调用栈:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-step-1.png" /&gt;
&lt;p&gt;每次发生 &lt;tt class="docutils literal"&gt;req_recv_done(req_forward)&lt;/tt&gt;, 就会调用 &lt;tt class="docutils literal"&gt;req_forward()&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
req_forward(struct context *ctx, struct conn *c_conn, struct msg *msg)
{
    if (!msg-&amp;gt;noreply) {
        c_conn-&amp;gt;enqueue_outq(ctx, c_conn, msg);
    }

    //获得到后端的连接. (可能是新建, 或者从pool里面获取)
    s_conn = server_pool_conn(ctx, c_conn-&amp;gt;owner, key, keylen);

    s_conn-&amp;gt;enqueue_inq(ctx, s_conn, msg);
    event_add_out(ctx-&amp;gt;evb, s_conn);
}
&lt;/pre&gt;
&lt;p&gt;就有一个msg就出现在client_conn-&amp;gt;out_q, 同时出现在server_conn-&amp;gt;in_q&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-state-1.png" /&gt;
&lt;p&gt;req_forward用server_pool_conn获得一个server_conn.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id86"&gt;2.转发到后端&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;对于server_conn来说, 因为挂了epoll_out事件, 很快就会调用 conn-&amp;gt;send，也就是msg_send.&lt;/p&gt;
&lt;p&gt;此时:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;send = msg_send;
conn-&amp;gt;send_next = req_send_next;
conn-&amp;gt;send_done = req_send_done;
&lt;/pre&gt;
&lt;p&gt;调用栈:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-step-2.png" /&gt;
&lt;p&gt;#这时, 每次发生 req_send_done, 这个msg就被放到server_conn-&amp;gt;out_q&lt;/p&gt;
&lt;p&gt;注意,  此时两个msg依然在client_conn-&amp;gt;in_q里面&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-state-2.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id87"&gt;3.接收后端响应&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;因为server_conn的 epoll_in是一直开着的, 响应很快回来后, 就到了server_conn的 msg_recv
这个过程和调用栈1类似,不过两个函数钩子不一样(图中灰色框)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
conn-&amp;gt;recv = msg_recv;(和&amp;lt;1&amp;gt;一样)
conn-&amp;gt;recv_next = rsp_recv_next;
conn-&amp;gt;recv_done = rsp_recv_done;
&lt;/pre&gt;
&lt;img alt="" src="/imgs/twemproxy-step-3.png" /&gt;
&lt;p&gt;这里 &lt;tt class="docutils literal"&gt;rsp_recv_next&lt;/tt&gt; 的作用是, 拿到下一个要接收的msg&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;rsp_forward&lt;/tt&gt; 会把 msg从 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;server_conn-&amp;gt;outq&lt;/span&gt;&lt;/tt&gt; 里面摘掉, 同时设置req和resp之间的一一对应关系&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//establish msg &amp;lt;-&amp;gt; pmsg (response &amp;lt;-&amp;gt; request) link
pmsg-&amp;gt;peer = msg;
msg-&amp;gt;peer = pmsg;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面这个代码是整个过程的精华所在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时候, client的q_out上排队的req, 就有了对应的response&lt;/p&gt;
&lt;p&gt;这时也会设置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
event_add_out(ctx-&amp;gt;evb, c_conn);
&lt;/pre&gt;
&lt;p&gt;每收到一个rsp, 就从server_conn的out_q摘掉, 并设置一一对应关系, 如下:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-state-3.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="client"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id88"&gt;4.把响应回给client&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;现在每个请求的msg都有了一个对应的response msg, client_conn的out事件也挂上了, 下面这个调用栈:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-step-4.png" /&gt;
&lt;p&gt;最终, 一切归于沉寂, 后端连接依然在:&lt;/p&gt;
&lt;img alt="" src="/imgs/twemproxy-state-4.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="buf"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id89"&gt;buf处理上的特点&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;输入是通过mbuf &lt;strong&gt;链表&lt;/strong&gt; 来保存, 不会做realloc()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;mbuf大小默认是16K, 可以配置, 范围在 &lt;tt class="docutils literal"&gt;512B - 64K&lt;/tt&gt; 之间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;mbuf, msg, conn等都有对象池, 减少对象分配:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct context *
core_start(struct instance *nci)
{
    mbuf_init(nci);     //mbuf内存池
    msg_init();         //msg池
    conn_init();        //连接对象池
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;请求是会被pipeline到后端的
就是说, 不必等proxy接收完整的请求, 再传给后端, 解析出一个msg, 就传給后端(如果msg比较大, 比如set 一个10M的对象, 效率就会比较低)
得到一个request_msg, 就转给后端, 在后端响应之前, 请求的msg 是不会销毁的.
得到后端response_msg后, request_msg 和response_msg 一起回到内存池.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id90"&gt;后端如何处理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;后端连接池的处理:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct conn *
server_conn(struct server *server)
{
    struct server_pool *pool;
    struct conn *conn;

    pool = server-&amp;gt;owner;

    if (server-&amp;gt;ns_conn_q &amp;lt; pool-&amp;gt;server_connections) {
        return conn_get(server, false, pool-&amp;gt;redis);
    }
    ASSERT(server-&amp;gt;ns_conn_q == pool-&amp;gt;server_connections);

    /*
     * 这里只是简单的转了一下, 如果一个conn正在使用, 那么它也会返回, 也就是说一个server conn会同时被 两个client conn使用.
     */
    conn = TAILQ_FIRST(&amp;amp;server-&amp;gt;s_conn_q);
    ASSERT(!conn-&amp;gt;client &amp;amp;&amp;amp; !conn-&amp;gt;proxy);

    TAILQ_REMOVE(&amp;amp;server-&amp;gt;s_conn_q, conn, conn_tqe);
    TAILQ_INSERT_TAIL(&amp;amp;server-&amp;gt;s_conn_q, conn, conn_tqe);

    return conn;
}
&lt;/pre&gt;
&lt;p&gt;这个连接池会受到每个server多少个后端连接这样一个限制, 如果没达到限制, 那么一定是创建连接.
如果达到限制了, 一定是返回其中一个连接.&lt;/p&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;proxy 刚起来的时候, 性能会比较差. 可以用server_each_preconnect解决.&lt;/li&gt;
&lt;li&gt;这个 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pool-&amp;gt;server_connections&lt;/span&gt;&lt;/tt&gt; 一般都没有配置(默认值是1. 虽然一个连接可能可以应付绝大多数场景, 个人感觉这必须配置啊!!!)
也就是说 不管前端多少个client, 到后端redis, 就只有1个连接. -- 这是这种proxy的特色&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id91"&gt;协议&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为需要从mbuf链表里面解析, 解析器是手工打造的..
这里暂时不去分析它.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id92"&gt;hash&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;twemproxy支持的hash方法:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;one_at_a_time&lt;/li&gt;
&lt;li&gt;md5&lt;/li&gt;
&lt;li&gt;crc16&lt;/li&gt;
&lt;li&gt;crc32 (crc32 implementation compatible with libmemcached)&lt;/li&gt;
&lt;li&gt;crc32a (correct crc32 implementation as per the spec)&lt;/li&gt;
&lt;li&gt;fnv1_64&lt;/li&gt;
&lt;li&gt;fnv1a_64&lt;/li&gt;
&lt;li&gt;fnv1_32&lt;/li&gt;
&lt;li&gt;fnv1a_32&lt;/li&gt;
&lt;li&gt;hsieh&lt;/li&gt;
&lt;li&gt;murmur&lt;/li&gt;
&lt;li&gt;jenkins&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们看hashkit/nc_hashkit.h 中的这个定义:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define HASH_CODEC(ACTION)                      \
    ACTION( HASH_ONE_AT_A_TIME, one_at_a_time ) \
    ACTION( HASH_MD5,           md5           ) \
    ACTION( HASH_CRC16,         crc16         ) \
    ACTION( HASH_CRC32,         crc32         ) \
    ACTION( HASH_CRC32A,        crc32a        ) \
    ACTION( HASH_FNV1_64,       fnv1_64       ) \
    ACTION( HASH_FNV1A_64,      fnv1a_64      ) \
    ACTION( HASH_FNV1_32,       fnv1_32       ) \
    ACTION( HASH_FNV1A_32,      fnv1a_32      ) \
    ACTION( HASH_HSIEH,         hsieh         ) \
    ACTION( HASH_MURMUR,        murmur        ) \
    ACTION( HASH_JENKINS,       jenkins       ) \

#define DEFINE_ACTION(_hash, _name) _hash,
typedef enum hash_type {
    HASH_CODEC( DEFINE_ACTION )
    HASH_SENTINEL
} hash_type_t;
#undef DEFINE_ACTION
&lt;/pre&gt;
&lt;p&gt;这个宏显得有些复杂, 我们用 &lt;tt class="docutils literal"&gt;gcc &lt;span class="pre"&gt;-E&lt;/span&gt;&lt;/tt&gt; 展开来看看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gcc -E hashkit/nc_hashkit.h
...
typedef enum hash_type {
    HASH_ONE_AT_A_TIME, HASH_MD5, HASH_CRC16, HASH_CRC32, HASH_CRC32A, HASH_FNV1_64, HASH_FNV1A_64, HASH_FNV1_32, HASH_FNV1A_32, HASH_HSIEH, HASH_MURMUR, HASH_JENKINS,
    HASH_SENTINEL
} hash_type_t;
&lt;/pre&gt;
&lt;p&gt;在这个 enum定义之后, 是这些函数定义:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
uint32_t hash_one_at_a_time(const char *key, size_t key_length);
void md5_signature(const unsigned char *key, unsigned int length, unsigned char *result);
uint32_t hash_md5(const char *key, size_t key_length);
uint32_t hash_crc16(const char *key, size_t key_length);
uint32_t hash_crc32(const char *key, size_t key_length);
uint32_t hash_crc32a(const char *key, size_t key_length);
uint32_t hash_fnv1_64(const char *key, size_t key_length);
uint32_t hash_fnv1a_64(const char *key, size_t key_length);
uint32_t hash_fnv1_32(const char *key, size_t key_length);
uint32_t hash_fnv1a_32(const char *key, size_t key_length);
uint32_t hash_hsieh(const char *key, size_t key_length);
uint32_t hash_jenkins(const char *key, size_t length);
uint32_t hash_murmur(const char *key, size_t length);
&lt;/pre&gt;
&lt;p&gt;在配置文件解析的时候, 用户指定一个hash函数名字, 需要解析为conf_pool.hash:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct conf_pool {
    struct string      name;                  /* pool name (root node) */
    struct conf_listen listen;                /* listen: */
    hash_type_t        hash;                  /* hash: */
}

char *
conf_set_hash(struct conf *cf, struct command *cmd, void *conf)
{
    struct string *value, *hash;
    for (hash = hash_strings; hash-&amp;gt;len != 0; hash++) {
        if (string_compare(value, hash) != 0) {
            continue;
        }

        *hp = hash - hash_strings;
        return CONF_OK;
    }
    return &amp;quot;is not a valid hash&amp;quot;;
}
&lt;/pre&gt;
&lt;p&gt;这里的hash_strings是在 nc_conf.c里定义的:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define string(_str)   { sizeof(_str) - 1, (uint8_t *)(_str) }
#define DEFINE_ACTION(_hash, _name) string(#_name),
static struct string hash_strings[] = {
    HASH_CODEC( DEFINE_ACTION )
    null_string
};
#undef DEFINE_ACTION
&lt;/pre&gt;
&lt;p&gt;展开得到的是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -E nc_conf.c  -I ./ | vim -
static struct string hash_strings[] = {
    { sizeof(&amp;quot;one_at_a_time&amp;quot;) - 1, (uint8_t *)(&amp;quot;one_at_a_time&amp;quot;) }, { sizeof(&amp;quot;md5&amp;quot;) - 1, (uint8_t *)(&amp;quot;md5&amp;quot;) }, { sizeof(&amp;quot;crc16&amp;quot;) - 1, (uint8_t *)(&amp;quot;crc16&amp;quot;) }, { sizeof(&amp;quot;crc32&amp;quot;) - 1, (uint8_t *)(&amp;quot;crc32&amp;quot;) }, { sizeof(&amp;quot;crc32a&amp;quot;) - 1, (uint8_t *)(&amp;quot;crc32a&amp;quot;) }, { sizeof(&amp;quot;fnv1_64&amp;quot;) - 1, (uint8_t *)(&amp;quot;fnv1_64&amp;quot;) }, { sizeof(&amp;quot;fnv1a_64&amp;quot;) - 1, (uint8_t *)(&amp;quot;fnv1a_64&amp;quot;) }, { sizeof(&amp;quot;fnv1_32&amp;quot;) - 1, (uint8_t *)(&amp;quot;fnv1_32&amp;quot;) }, { sizeof(&amp;quot;fnv1a_32&amp;quot;) - 1, (uint8_t *)(&amp;quot;fnv1a_32&amp;quot;) }, { sizeof(&amp;quot;hsieh&amp;quot;) - 1, (uint8_t *)(&amp;quot;hsieh&amp;quot;) }, { sizeof(&amp;quot;murmur&amp;quot;) - 1, (uint8_t *)(&amp;quot;murmur&amp;quot;) }, { sizeof(&amp;quot;jenkins&amp;quot;) - 1, (uint8_t *)(&amp;quot;jenkins&amp;quot;) },
    { 0, ((void *)0) }
};
&lt;/pre&gt;
&lt;p&gt;配置文件解析后, 被加载到server_pool里面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
typedef uint32_t (*hash_t)(const char *, size_t);
struct server_pool {
    int                dist_type;            /* distribution type (dist_type_t) */
    int                key_hash_type;        /* key hash type (hash_type_t) */
    hash_t             key_hash;             /* key hasher */
}

#这个宏定义一个函数列表
#define DEFINE_ACTION(_hash, _name) hash_##_name,
static hash_t hash_algos[] = {
    HASH_CODEC( DEFINE_ACTION )
    NULL
};
#undef DEFINE_ACTION
&lt;/pre&gt;
&lt;p&gt;展开后:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static hash_t hash_algos[] = {
    hash_one_at_a_time, hash_md5, hash_crc16, hash_crc32, hash_crc32a, hash_fnv1_64, hash_fnv1a_64, hash_fnv1_32, hash_fnv1a_32, hash_hsieh, hash_murmur, hash_jenkins,
    ((void *)0)
};
&lt;/pre&gt;
&lt;p&gt;最后, 利用conf中解析出来的 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cp-&amp;gt;hash&lt;/span&gt;&lt;/tt&gt; 为下标, 直接去这个数组的函数指针即可:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sp-&amp;gt;key_hash = hash_algos[cp-&amp;gt;hash];
&lt;/pre&gt;
&lt;div class="section" id="id24"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id93"&gt;具体hash函数&lt;/a&gt;&lt;/h4&gt;
&lt;div class="section" id="crc32"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id94"&gt;crc32&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;crc32是设计来计算校验码的, 并不适合算hash.&lt;/p&gt;
&lt;p&gt;twemproxy 0.2.4 里面包含的crc32算法 crc32使用的是 memcache 用的crc32.
最新的版本里面包含了一个 crc32a, 才是原来含义上的crc32:&lt;/p&gt;
&lt;p&gt;用 &lt;tt class="docutils literal"&gt;crc32a&lt;/tt&gt; , 我们才能用这段代码计算key被分布到哪里去了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import binascii
word = 'hello'
crc32 =  binascii.crc32(word) &amp;amp; 0xffffffff
print '%08x' % crc32, crc32%4
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="hsieh"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id95"&gt;hsieh&lt;/a&gt;&lt;/h5&gt;
&lt;/div&gt;
&lt;div class="section" id="jenkins-lookup3"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id96"&gt;Jenkins lookup3&lt;/a&gt;&lt;/h5&gt;
&lt;/div&gt;
&lt;div class="section" id="jenkins-one-at-a-time"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id97"&gt;Jenkins one_at_a_time&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;The Jenkins hash functions are a collection of (non-cryptographic) hash functions for multi-byte keys designed by Bob Jenkins. They can be used also as checksums&lt;/p&gt;
&lt;pre class="literal-block"&gt;
uint32_t jenkins_one_at_a_time_hash(char *key, size_t len)
{
    uint32_t hash, i;
    for(hash = i = 0; i &amp;lt; len; ++i)
    {
        hash += key[i];
        hash += (hash &amp;lt;&amp;lt; 10);
        hash ^= (hash &amp;gt;&amp;gt; 6);
    }
    hash += (hash &amp;lt;&amp;lt; 3);
    hash ^= (hash &amp;gt;&amp;gt; 11);
    hash += (hash &amp;lt;&amp;lt; 15);
    return hash;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fnv-xxx"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id98"&gt;FNV-XXX&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Fowler–Noll–Vo is a non-cryptographic hash function created by Glenn Fowler, Landon Curt Noll, and Phong Vo.&lt;/p&gt;
&lt;p&gt;FNV-1实现简单:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hash = FNV_offset_basis
for each octet_of_data to be hashed
     hash = hash × FNV_prime
     hash = hash XOR octet_of_data
return hash
&lt;/pre&gt;
&lt;p&gt;FNV-1a, reverses the multiply and XOR steps.&lt;/p&gt;
&lt;p&gt;designed primarily for hashtable and checksum use(不适合作为加密用的hash函数)&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;li&gt;对0敏感, 只要x和xor, 步骤里面 出现一个0, 后面就都是0(可以加个固定常数, 但是这样会破坏随机性)
(好在字符串没有这个问题)&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="murmur"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id99"&gt;murmur&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;MurmurHash performed well in a random distribution of regular keys.[7]&lt;/p&gt;
&lt;p&gt;这些都用了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
libstdc++ (ver 4.6), Perl,[24] nginx (ver 1.0.1),[25] Rubinius,[26] libmemcached (the C driver for Memcached),[27] maatkit,[28] Hadoop,[1] Kyoto Cabinet,[29], RaptorDB[30], and Cassandra.[31]
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h5&gt;&lt;a class="toc-backref" href="#id100"&gt;小结&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;hash函数的几个要求:
1. 均匀性(排除crc32)
2. 速度
3. 如果能用python/php计算 hash更好.&lt;/p&gt;
&lt;p&gt;时间消耗上, 大致是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Murmur/Jenkins(2s) &amp;lt; FNV(4s) &amp;lt; CRC32(5s)
&lt;/pre&gt;
&lt;p&gt;应该选择Murmur或者FNV-1&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.azillionmonkeys.com/qed/hash.html"&gt;http://www.azillionmonkeys.com/qed/hash.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed"&gt;http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed&lt;/a&gt;  (这个文章对随机性和速度做了详细考察)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;twemproxy 的github上一般都是用 &lt;tt class="docutils literal"&gt;fnv1a_64&lt;/tt&gt;:&lt;/p&gt;
&lt;p&gt;我们可以用下面这段python实现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#/home/ning/idning/langtest/python/fnv
def hash_fnv1a_64(s):
    UINT32_MAX=2**32
    FNV_64_INIT = 0xcbf29ce484222325 % UINT32_MAX
    FNV_64_PRIME = 0x100000001b3 % UINT32_MAX

    hval = FNV_64_INIT
    for c in s:
        hval = hval ^ ord(c)
        hval = (hval * FNV_64_PRIME) % UINT32_MAX
    return hval
&lt;/pre&gt;
&lt;p&gt;相比起来, 对应的murmur要复杂些, 所以我们选择  &lt;tt class="docutils literal"&gt;fnv1a_64&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dispatch"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id101"&gt;dispatch方法&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ketama&lt;/li&gt;
&lt;li&gt;modula&lt;/li&gt;
&lt;li&gt;random&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="rbtree"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id102"&gt;rbtree&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个proxy为什么需要rbtree?? 用来做某种超时:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static struct rbtree tmo_rbt;    /* timeout rbtree */

void
msg_tmo_insert(struct msg *msg, struct conn *conn)
{
    struct rbnode *node;
    int timeout;

    timeout = server_timeout(conn);
    if (timeout &amp;lt;= 0) {
        return;
    }

    node = &amp;amp;msg-&amp;gt;tmo_rbe;
    node-&amp;gt;key = nc_msec_now() + timeout;
    node-&amp;gt;data = conn;

    rbtree_insert(&amp;amp;tmo_rbt, node);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="mget"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id103"&gt;如何处理mget&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id104"&gt;代码严重受nginx影响&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;active 和ready变量&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ngx_int_t
ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags)
{
    if (ngx_event_flags &amp;amp; NGX_USE_CLEAR_EVENT) {

        /* kqueue, epoll */

        if (!rev-&amp;gt;active &amp;amp;&amp;amp; !rev-&amp;gt;ready) {
            if (ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT)
                == NGX_ERROR)
            {
                return NGX_ERROR;
            }
        }

        return NGX_OK;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id26"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id105"&gt;(代码)小结&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;代码质量非常好, 举例&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数开始写ASSERT:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int
event_wait(struct event_base *evb, int timeout)
{
    int ep = evb-&amp;gt;ep;
    struct epoll_event *event = evb-&amp;gt;event;
    int nevent = evb-&amp;gt;nevent;

    ASSERT(ep &amp;gt; 0);
    ASSERT(event != NULL);
    ASSERT(nevent &amp;gt; 0);
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;类名, 函数名, 注释都很赞.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;状态变迁: 因为逻辑相对简单, 不需要保存状态, 所以只是有一个conn.client 标志表示状态,  &lt;strong&gt;不需要一个状态机, 机制不同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;从这个配置看, 完全的nginx风格:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static struct command conf_commands[] = {
    { string(&amp;quot;listen&amp;quot;),
      conf_set_listen,
      offsetof(struct conf_pool, listen) },

    { string(&amp;quot;hash&amp;quot;),
      conf_set_hash,
      offsetof(struct conf_pool, hash) },

    { string(&amp;quot;hash_tag&amp;quot;),
      conf_set_hashtag,
      offsetof(struct conf_pool, hash_tag) },

    { string(&amp;quot;server_connections&amp;quot;),
      conf_set_num,
      offsetof(struct conf_pool, server_connections) },

    null_command
};
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id27"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id106"&gt;注意&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;这个 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pool-&amp;gt;server_connections&lt;/span&gt;&lt;/tt&gt; 一般都没有配置(默认值是1. 虽然一个连接可能可以应付绝大多数场景, 个人感觉这必须配置啊!!!)&lt;/p&gt;
&lt;p&gt;也就是说 不管前端多少个client, 到后端redis, 就只有1个连接. -- 这是这种proxy的特色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过msg-&amp;gt;peer 和msg-&amp;gt;owner 耦合client_conn与server_conn&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;非常巧妙的设计, 多个前端, 可以同时复用后端的 &lt;strong&gt;一个连接&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//下面这里建立的link是保证客户端收到的请求和响应一一对应的关键.
//client_conn-&amp;gt;out_q 里面还保存着按照发送顺序的请求msg. 这里收到了response 的msg之后.
//一一对应起来, 向客户端返回response的时候, 按照 client_conn-&amp;gt;out_q的顺序, 看相应的
//msg 的peer是否被设置了, 如果设置了, 就可以返回.  //
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;这也是与一般的proxy不一样的地方,
一般的proxy, 收到client_conn_1消息, 处理后找个后端连接发过去, 此时这个后端连接是不会被其它客户端连接复用的, 而这时收到的response也就必然是client_conn_1对应的response, 直接放到client_conn1的输出队列即可.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//
/* establish msg &amp;lt;-&amp;gt; pmsg (response &amp;lt;-&amp;gt; request) link */
pmsg-&amp;gt;peer = msg;
msg-&amp;gt;peer = pmsg;
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里proxy必须保存req msg的body和resp msg的body, 如果后端网络/响应慢, 则req msg撑爆内存, 如果前端不读取, 则rsp msg撑爆内存.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;能用这种后端只开一个连接的proxy, 要求:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;后端交互包不会被打散, 即一个连接上, 包一定是连续的发出, 或者连续的收到.&lt;/li&gt;
&lt;li&gt;单连接上, 后端返回顺序和请求顺序一致.
如果服务器在一个连接上起多个线程来服务, 哪个线程先处理完，就 &lt;strong&gt;从这个连接&lt;/strong&gt; 返回, 那proxy层就乱套了(不过这时候如果有个req/resp id, 也是可以的)&lt;/li&gt;
&lt;li&gt;小包(req/resp都很小, 这样才容易满足1)&lt;/li&gt;
&lt;li&gt;后端处理很快(否则都堆在proxy了)&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id28"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id107"&gt;使用&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id29"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id108"&gt;编译&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="debug"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id109"&gt;debug级别&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有两种debug: log_debug输出到日志和ASSERT:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
flag                         log    ASSERT
--enable-debug=no       =&amp;gt;   0      啥也不做
--enable-debug=log      =&amp;gt;   1      啥也不做
--enable-debug=yes      =&amp;gt;   1      出错时打日志
--enable-debug=full     =&amp;gt;   1      出错时core
&lt;/pre&gt;
&lt;p&gt;configure.ac:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
AS_CASE([x$enable_debug],
  [xfull], [AC_DEFINE([HAVE_ASSERT_PANIC], [1],
                      [Define to 1 if panic on an assert is enabled])
            AC_DEFINE([HAVE_DEBUG_LOG], [1], [Define to 1 if debug log is enabled])
           ],
  [xyes], [AC_DEFINE([HAVE_ASSERT_LOG], [1],
                     [Define to 1 if log on an assert is enabled])
           AC_DEFINE([HAVE_DEBUG_LOG], [1], [Define to 1 if debug log is enabled])
          ],
  [xlog], [AC_DEFINE([HAVE_DEBUG_LOG], [1], [Define to 1 if debug log is enabled])],
  [xno], [],
  [AC_MSG_FAILURE([invalid value ${enable_debug} for --enable-debug])])
AC_MSG_RESULT($enable_debug)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="core"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id110"&gt;core的问题&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;./configure --enable-debug=log&lt;/p&gt;
&lt;p&gt;有些老的gcc可能会core&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/115"&gt;https://github.com/twitter/twemproxy/issues/115&lt;/a&gt;
&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/146"&gt;https://github.com/twitter/twemproxy/issues/146&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;in my machine(centos6.3):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gcc -v
Using built-in specs.
Target: x86_64-redhat-linux
Thread model: posix
gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC)
&lt;/pre&gt;
&lt;p&gt;debug=no:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./configure  &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                                         =&amp;gt; core
./configure CFLAGS=&amp;quot;-O1 -g3&amp;quot; &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                         =&amp;gt; ok
./configure CFLAGS=&amp;quot;-O2 -g3&amp;quot; &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                         =&amp;gt; core
./configure CFLAGS=&amp;quot;-O3 -g3&amp;quot; &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                         =&amp;gt; core
&lt;/pre&gt;
&lt;p&gt;debug=log:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./configure --enable-debug=log &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                       =&amp;gt; core
./configure CFLAGS=&amp;quot;-O1 -g3&amp;quot; --enable-debug=log &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8      =&amp;gt; ok
./configure CFLAGS=&amp;quot;-O2 -g3&amp;quot; --enable-debug=log &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8      =&amp;gt; core
./configure CFLAGS=&amp;quot;-O3 -g3&amp;quot; --enable-debug=log &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8      =&amp;gt; core
&lt;/pre&gt;
&lt;p&gt;debug=full:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./configure --enable-debug=full &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8                      =&amp;gt; ok
./configure CFLAGS=&amp;quot;-O1 -g3&amp;quot; --enable-debug=full &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8     =&amp;gt; ok
./configure CFLAGS=&amp;quot;-O2 -g3&amp;quot; --enable-debug=full &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8     =&amp;gt; ok
./configure CFLAGS=&amp;quot;-O3 -g3&amp;quot; --enable-debug=full &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8     =&amp;gt; ok
&lt;/pre&gt;
&lt;p&gt;在configure里面写了, 默认是-O2(看直接./configure 之后make的输出, 也能看到-O2):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
elif test $ac_cv_prog_cxx_g = yes; then
  if test &amp;quot;$GXX&amp;quot; = yes; then
    CXXFLAGS=&amp;quot;-g -O2&amp;quot;
  else
    CXXFLAGS=&amp;quot;-g&amp;quot;
  fi
else
  if test &amp;quot;$GXX&amp;quot; = yes; then
    CXXFLAGS=&amp;quot;-O2&amp;quot;
  else
    CXXFLAGS=
  fi
fi
&lt;/pre&gt;
&lt;p&gt;比较优化选项:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gcc -c -Q -O1 --help=optimizers &amp;gt; /tmp/o1
$ gcc -c -Q -O2 --help=optimizers &amp;gt; /tmp/o2

-finline-small-functions
&lt;/pre&gt;
&lt;p&gt;分别用-O1 和-O2生成的二进制, 看某个函数的汇编, 差别太大了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
objdump -d src/nutcracker.o1
&lt;/pre&gt;
&lt;p&gt;对函数禁止优化:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
有时候，我们希望对某个函数或者某块代码添加自己的优化选项
这个可以通过下面的宏实现：
对代码块的优化/禁止优化：
#pragma GCC push_options
#pragma GCC optimize (&amp;quot;O0&amp;quot;)

your code

#pragma GCC pop_options
to disable optimizations since GCC 4.4.
&lt;/pre&gt;
&lt;p&gt;对函数的优化/禁止优化:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
__attribute__((optimize(&amp;quot;O0&amp;quot;)))
&lt;/pre&gt;
&lt;p&gt;写了个脚本逐一去掉 -O2的选项:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cd ~/twemproxy &amp;amp;&amp;amp; ./configure CFLAGS=&amp;quot;-O1  -falign-functions -falign-jumps -falign-labels -falign-loops -fcaller-saves -fcrossjumping -fcse-follow-jumps -fdelete-null-pointer-checks -fexpensive-optimizations -fforward-propagate -fgcse -finline-small-functions -fipa-cp -foptimize-register-move -foptimize-sibling-calls -fpeephole2 -fregmove -freorder-blocks -freorder-functions -frerun-cse-after-loop -fschedule-insns2 -fstrict-aliasing&amp;quot; &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make -j 8
&lt;/pre&gt;
&lt;p&gt;去掉 -fstrict-aliasing 就好.&lt;/p&gt;
&lt;p&gt;带 -fstrict-aliasing  就会出问题.&lt;/p&gt;
&lt;p&gt;下面的就ok:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./configure CFLAGS=&amp;quot;-O3 -fno-strict-aliasing&amp;quot; &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id30"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id111"&gt;使用&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;一般运行的时候需要指定一个pid文件, 如果这个命令连续运行两次, 则pid文件被清除:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ ll log/
total 16K
928376 -rw-r--r-- 1 ning ning 12K 2013-12-20 15:36 nutcracker-22000.log
928377 -rw-r--r-- 1 ning ning   5 2013-12-20 15:36 nutcracker-22000.pid
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ bin/nutcracker -d -c /tmp/r/nutcracker-22000/conf/nutcracker-22000.conf -o /tmp/r/nutcracker-22000/log/nutcracker-22000.log -p /tmp/r/nutcracker-22000/log/nutcracker-22000.pid -s 23000
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ ll log/
total 12K
928376 -rw-r--r-- 1 ning ning 12K 2013-12-20 15:36 nutcracker-22000.log
&lt;/pre&gt;
&lt;p&gt;因为第二个进程会启动后 先写pid文件, 发现listen失败, 就退出, 同时清空pid文件.
应该修改一下, 如果pid文件已经存在, 拒绝启动&lt;/p&gt;
&lt;p&gt;同时, 我们的部署脚本, 也需要一个kill任务. 强制kill&lt;/p&gt;
&lt;p&gt;redis 本身就是先listen, 后写pid文件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;listen:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cluster0:
    listen: 127.0.0.5:22000
&lt;/pre&gt;
&lt;p&gt;这是进程只会监听127.0.0.5 上的端口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tcp        0      0 127.0.0.5:22000         0.0.0.0:*               LISTEN      8581/nutcracker
&lt;/pre&gt;
&lt;p&gt;需要改成:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cluster0:
    listen: 0.0.0.0:22000

    tcp        0      0 0.0.0.0:22000           0.0.0.0:*               LISTEN      19902/nutcracker
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id31"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id112"&gt;配置参数&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
alpha:
  listen: 127.0.0.1:22121
  hash: fnv1a_64
  distribution: ketama
  auto_eject_hosts: true
  redis: true
  server_retry_timeout: 2000
  server_failure_limit: 1
  servers:
   - 127.0.0.1:6379:1
&lt;/pre&gt;
&lt;div class="section" id="hashdistribution"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id113"&gt;hash和distribution见前面分析&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="auto-eject-hosts"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id114"&gt;auto_eject_hosts相关&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;下面选项只在auto_eject_hosts时有用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;server_failure_limit(多少次开始弹出)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;The number of conseutive failures on a server that would leads to it being temporarily ejected when auto_eject_host is set to true&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;server_retry_timeout(每次弹出多长时间)&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;是说在这段时间内, 这个host是被eject的(不在hash环中)&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;这一块的代码 &lt;tt class="docutils literal"&gt;modula_update&lt;/tt&gt; 还没仔细看&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="timeout"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id115"&gt;timeout&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;默认情况下, twemproxy一直等着把请求传给后端, 但是如果等了timeout时间, proxy 就不会把这个请求传给后端, 而是向客户端回复一个&lt;/p&gt;
&lt;p&gt;SERVER_ERROR Connection timed outrn is sent back to the client.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="log"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id116"&gt;log&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;编译时加上log选项, 设为 LOG_INFO&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mbuf-size"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id117"&gt;mbuf size&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;default mbuf-size of 16K&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在启动时指定:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/nutcracker -h
This is nutcracker-0.2.4

Usage: nutcracker [-?hVdDt] [-v verbosity level] [-o output file]
                  [-c conf file] [-s stats port] [-a stats addr]
                  [-i stats interval] [-p pid file] [-m mbuf size]

Options:
  -h, --help             : this help
  -V, --version          : show version and exit
  -t, --test-conf        : test configuration for syntax errors and exit
  -d, --daemonize        : run as a daemon
  -D, --describe-stats   : print stats description and exit
  -v, --verbosity=N      : set logging level (default: 5, min: 0, max: 11)
  -o, --output=S         : set logging file (default: stderr)
  -c, --conf-file=S      : set configuration file (default: conf/nutcracker.yml)
  -s, --stats-port=N     : set stats monitoring port (default: 22222)
  -a, --stats-addr=S     : set stats monitoring ip (default: 0.0.0.0)
  -i, --stats-interval=N : set stats aggregation interval in msec (default: 30000 msec)
  -p, --pid-file=S       : set pid file (default: off)
  -m, --mbuf-size=N      : set size of mbuf chunk in bytes (default: 16384 bytes)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="max-key-lenght"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id118"&gt;max key lenght&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;对memcache: ascii protocol key最多 250 characters. The key should not include whitespace, or 'r' or 'n' character.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;redis 没有这个限制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;nutcracker requires the key to be stored in a contiguous memory region.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;也就是说key必须小于mbuf size&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="server-connections-1"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id119"&gt;server_connections: &amp;gt; 1&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如果client想要在一个pipeline里面读到最新的写, 就要设置server_connections:1,
如果我们设置 &lt;tt class="docutils literal"&gt;server_connections:2&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;那么:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set foo bar
get foo
&lt;/pre&gt;
&lt;p&gt;后面这个get可能在另一个连接里面发过去, 所以不一定能读到 &lt;tt class="docutils literal"&gt;set foo bar&lt;/tt&gt; 的结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id32"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id120"&gt;监控&lt;/a&gt;&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;server_err&lt;/li&gt;
&lt;li&gt;server_timedout&lt;/li&gt;
&lt;li&gt;server_eof&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="redis-mgr"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id121"&gt;使用redis-mgr部署&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
cluster0 = {
    'cluster_name': 'cluster0',
    'user': 'ning',
    'sentinel':[
        ('127.0.0.5:21001', '/tmp/r/sentinel-21001'),
        ('127.0.0.5:21002', '/tmp/r/sentinel-21002'),
        ('127.0.0.5:21003', '/tmp/r/sentinel-21003'),
    ],
    'redis': [
        # master(host:port, install path)       ,  slave(host:port, install path)
        ('127.0.0.5:20000', '/tmp/r/redis-20000'), ('127.0.0.5:30000', '/tmp/r/redis-30000'),
        ('127.0.0.5:20001', '/tmp/r/redis-20001'), ('127.0.0.5:30001', '/tmp/r/redis-30001'),
        ('127.0.0.5:20002', '/tmp/r/redis-20002'), ('127.0.0.5:30002', '/tmp/r/redis-30002'),
        ('127.0.0.5:20003', '/tmp/r/redis-20003'), ('127.0.0.5:30003', '/tmp/r/redis-30003'),
    ],
    'nutcracker': [
        ('127.0.0.5:22000', '/tmp/r/nutcracker-22000'),
        ('127.0.0.5:22001', '/tmp/r/nutcracker-22001'),
        ('127.0.0.5:22002', '/tmp/r/nutcracker-22002'),
    ],
}
&lt;/pre&gt;
&lt;p&gt;对redis的benchmark(在我自己机器上):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ redis-benchmark -h 127.0.0.5 -p 20000 -t get,set -n 1000000
====== SET ======
  1000000 requests completed in 18.65 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

86.50% &amp;lt;= 1 milliseconds
99.66% &amp;lt;= 2 milliseconds
53613.55 requests per second

====== GET ======
  1000000 requests completed in 16.25 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

99.25% &amp;lt;= 1 milliseconds
99.89% &amp;lt;= 2 milliseconds
61557.40 requests per second
&lt;/pre&gt;
&lt;p&gt;对proxy 的benchmark:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ redis-benchmark -h 127.0.0.5 -p 22000 -t get,set -n 1000000
====== SET ======
  1000000 requests completed in 21.45 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

86.42% &amp;lt;= 1 milliseconds
99.76% &amp;lt;= 2 milliseconds
46628.74 requests per second

====== GET ======
  1000000 requests completed in 48.91 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

30.70% &amp;lt;= 1 milliseconds
44.95% &amp;lt;= 2 milliseconds
20445.30 requests per second
&lt;/pre&gt;
&lt;p&gt;高并发先, 直连redis性能差, cpu都起不来.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id33"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id122"&gt;日志级别&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们如果编译debug版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cd nutcracker-0.2.4/ &amp;amp;&amp;amp; ./configure CFLAGS=&amp;quot;-O1&amp;quot; --enable-debug=full --prefix=`pwd`/../output &amp;amp;&amp;amp; make -j 8 &amp;amp;&amp;amp; make install
&lt;/pre&gt;
&lt;p&gt;默认的日志级别是5, 就会有很多连接日志:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[Mon Jan 20 09:44:01 2014] nc_core.c:207 close c 12 '127.0.0.5:52020' on event 0001 eof 1 done 1 rb 26714 sb 13301
[Mon Jan 20 09:44:01 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52021'
[Mon Jan 20 09:44:02 2014] nc_core.c:207 close c 12 '127.0.0.5:52021' on event 0001 eof 1 done 1 rb 26741 sb 13315
[Mon Jan 20 09:44:02 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52022'
[Mon Jan 20 09:44:04 2014] nc_core.c:207 close c 12 '127.0.0.5:52022' on event 0001 eof 1 done 1 rb 26768 sb 13329
[Mon Jan 20 09:44:04 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52024'
[Mon Jan 20 09:44:05 2014] nc_core.c:207 close c 12 '127.0.0.5:52024' on event 0001 eof 1 done 1 rb 26795 sb 13343
[Mon Jan 20 09:44:05 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52025'
[Mon Jan 20 09:44:06 2014] nc_core.c:207 close c 12 '127.0.0.5:52025' on event 0001 eof 1 done 1 rb 26822 sb 13357
[Mon Jan 20 09:44:06 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52026'
[Mon Jan 20 09:44:07 2014] nc_core.c:207 close c 12 '127.0.0.5:52026' on event 0001 eof 1 done 1 rb 26849 sb 13371
[Mon Jan 20 09:44:07 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52027'
[Mon Jan 20 09:44:08 2014] nc_core.c:207 close c 12 '127.0.0.5:52027' on event 0001 eof 1 done 1 rb 26876 sb 13385
[Mon Jan 20 09:44:08 2014] nc_proxy.c:337 accepted c 12 on p 11 from '127.0.0.5:52028'
&lt;/pre&gt;
&lt;p&gt;处理方法:&lt;/p&gt;
&lt;div class="section" id="id34"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id123"&gt;修改日志级别:&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/nutcracker -h
This is nutcracker-0.2.4

Usage: nutcracker [-?hVdDt] [-v verbosity level] [-o output file]
                  [-c conf file] [-s stats port] [-a stats addr]
                  [-i stats interval] [-p pid file] [-m mbuf size]

Options:
  -h, --help             : this help
  -V, --version          : show version and exit
  -t, --test-conf        : test configuration for syntax errors and exit
  -d, --daemonize        : run as a daemon
  -D, --describe-stats   : print stats description and exit
  -v, --verbosity=N      : set logging level (default: 5, min: 0, max: 11)
  -o, --output=S         : set logging file (default: stderr)
  -c, --conf-file=S      : set configuration file (default: conf/nutcracker.yml)
  -s, --stats-port=N     : set stats monitoring port (default: 22222)
  -a, --stats-addr=S     : set stats monitoring ip (default: 0.0.0.0)
  -i, --stats-interval=N : set stats aggregation interval in msec (default: 30000 msec)
  -p, --pid-file=S       : set pid file (default: off)
  -m, --mbuf-size=N      : set size of mbuf chunk in bytes (default: 16384 bytes)
&lt;/pre&gt;
&lt;p&gt;使用 &lt;tt class="docutils literal"&gt;nutcracker &lt;span class="pre"&gt;-v&lt;/span&gt; 0&lt;/tt&gt; 即可&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id35"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id124"&gt;2.动态调整日志级别:&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
case SIGTTIN:
    actionstr = &amp;quot;, up logging level&amp;quot;;
    action = log_level_up;
    break;

case SIGTTOU:
    actionstr = &amp;quot;, down logging level&amp;quot;;
    action = log_level_down;
    break;

case SIGHUP:
    actionstr = &amp;quot;, reopening log file&amp;quot;;
    action = log_reopen;
    break;
&lt;/pre&gt;
&lt;p&gt;所以:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kill -s TTOU  23787
&lt;/pre&gt;
&lt;p&gt;日志显示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[Mon Jan 20 09:44:09 2014] nc_signal.c:122 signal 22 (SIGTTOU) received, down logging level
[Mon Jan 20 09:44:09 2014] nc_log.c:95 down log level to 4
&lt;/pre&gt;
&lt;p&gt;此时就没有连接日志了.&lt;/p&gt;
&lt;p&gt;如果想要多看日志:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kill -s TTIN 15797
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id36"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id125"&gt;3.切日志&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如果我们需要用日志统计流量, 客户端信息, 可以切日志, 方法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ mv log/nutcracker.log log/nutcracker.log.20140120
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ ll log/
total 124K
813654 -rw-r--r-- 1 ning ning 114K 2014-01-20 09:44 nutcracker.log.20140120
813655 -rw-r--r-- 1 ning ning    5 2014-01-20 09:33 nutcracker.pid
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ cat log/nutcracker.pid
23787

#doit
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ cat log/nutcracker.pid | xargs kill -s HUP
ning&amp;#64;ning-laptop /tmp/r/nutcracker-22000$ ll log/
total 124K
813688 -rw-r--r-- 1 ning ning    0 2014-01-20 09:49 nutcracker.log
813654 -rw-r--r-- 1 ning ning 114K 2014-01-20 09:49 nutcracker.log.20140120
813655 -rw-r--r-- 1 ning ning    5 2014-01-20 09:33 nutcracker.pid
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id37"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id126"&gt;自己实现一个自动的主从切换?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;0配置, 利用sentinel用的方式, 获知sentinel的位置.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sentinel"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id127"&gt;sentinel验证&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如果一主一丛, 主彻底挂了, 从应该是提升为主, 而給老主发的&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id38"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id128"&gt;配置和优化&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="m-512"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id129"&gt;-m 512&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;速度提高, 内存消耗减少(一般消息都小于512字节)&lt;/p&gt;
&lt;p&gt;注意: 不能滥用, twemproxy实现里面, 一个key必须放在一个mbuf里面(解析器, 为了防止拷贝数据做的限制), 所以, 如果key长度大于mbuf大小, 会打印错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (r-&amp;gt;rlen &amp;gt;= mbuf_data_size()) {
    log_error(&amp;quot;parsed bad req %&amp;quot;PRIu64&amp;quot; of type %d with key &amp;quot;
              &amp;quot;length %d that greater than or equal to maximum&amp;quot;
              &amp;quot; redis key length of %d&amp;quot;, r-&amp;gt;id, r-&amp;gt;type,
              r-&amp;gt;rlen, mbuf_data_size());
    goto error;
}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Mbuf enables zero copy for requests and responses flowing through the proxy. By default an mbuf is 16K

nutcracker requires the key to be stored in a contiguous memory region. Since all requests and responses in nutcracker are stored in mbuf, the maximum length of the redis key is limited by the size of the maximum available space for data in mbuf (mbuf_data_size()).
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id39"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id130"&gt;问题&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="preconnect-true-redis-core"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id131"&gt;preconnect: true 的时候, 如果后端redis挂掉, 会core&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [0] /lib64/tls/libpthread.so.0 [0x302b80c420]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [1] bin/nutcracker(server_unref+0x5a) [0x405f7a]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [2] bin/nutcracker(server_close+0x1ae) [0x40681e]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [3] bin/nutcracker(core_loop+0x89) [0x4054d9]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [4] bin/nutcracker(main+0x4b5) [0x40f1c5]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [5] /lib64/tls/libc.so.6(__libc_start_main+0xdb) [0x302af1c4bb]
[Tue Dec 24 21:10:20 2013] nc_util.c:291 [6] bin/nutcracker [0x40507a]
[Tue Dec 24 21:10:20 2013] nc_signal.c:122 signal 11 (SIGSEGV) received, core dumping


似乎是这个问题: https://github.com/twitter/twemproxy/issues/146
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pipeline-replay"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id132"&gt;pipeline/replay时消耗大量内存:&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/203"&gt;https://github.com/twitter/twemproxy/issues/203&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis-mgr$ cat tests/a.py
import socket
import time

HOST = '127.0.0.5'
PORT = 24000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

data = '*3\r\n$3\r\nSET\r\n$13\r\nkkk-100001480\r\n$13\r\nvvv-100001480\r\n'
for i in range(100*1000):
    s.sendall(data)

ning&amp;#64;ning-laptop:~/idning-github/redis-mgr$ time python tests/a.py

real        0m0.797s
user        0m0.280s
sys 0m0.120s
&lt;/pre&gt;
&lt;p&gt;I found that twemproxy consume 1.6G of  memeory, and the memory will not free after the client shutdown:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:/tmp/r/nutcracker-24000$ ps aux | grep nut
ning      2017  0.5 14.8 1652068 1186692 ?     Sl   09:43   0:00 bin/nutcracker -d -c /tmp/r/nutcracker-24000/conf/nutcracker.conf -o /tmp/r/nutcracker-24000/log/nutcracker.log -p /tmp/r/nutcracker-24000/log/nutcracker.pid -s 25000 -v 4

100*1000*52(msg length) = 5MB
&lt;/pre&gt;
&lt;p&gt;send 5MB to twemproxy, it will consume 1.6G memory...&lt;/p&gt;
&lt;p&gt;if we deploy twemporxy and redis on the same machine. they will killed by OOMKiller.&lt;/p&gt;
&lt;p&gt;原因:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./bin/nutcracker -h
...
-m, --mbuf-size=N      : set size of mbuf chunk in bytes (default: 16384 bytes)
&lt;/pre&gt;
&lt;p&gt;default mbuf size is 16K, and twemproxy will alloc at least one mbuf for one msg, so 100*1000 msgs will use 1.6G memory.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;twemproxy will not free the request mbuf until client read the response&lt;/li&gt;
&lt;li&gt;twemproxy not reduce memory on mbuf pool.
it only call &lt;tt class="docutils literal"&gt;mbuf_free&lt;/tt&gt; on &lt;tt class="docutils literal"&gt;mbuf_deinit&lt;/tt&gt;, which is called on server down&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;that is a big pipeline, got huge memory consumption&lt;/p&gt;
&lt;p&gt;this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
data = '*3\r\n$3\r\nSET\r\n$13\r\nkkk-100001480\r\n$13\r\nvvv-100001480\r\n'
for i in range(1*1000):
    s.sendall(data)

#print s.recv(10*1000)
&lt;/pre&gt;
&lt;p&gt;endswith:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
==9226== 311,064 bytes in 997 blocks are possibly lost in loss record 38 of 38
==9226==    at 0x4C274A8: malloc (vg_replace_malloc.c:236)
==9226==    by 0x411C75: _nc_alloc (nc_util.c:224)
==9226==    by 0x409B6B: _msg_get (nc_message.c:200)
==9226==    by 0x409CC5: msg_get (nc_message.c:268)
==9226==    by 0x40A1DC: msg_recv (nc_message.c:439)
==9226==    by 0x406178: core_core (nc_core.c:158)
==9226==    by 0x41BBB7: event_wait (nc_epoll.c:269)
==9226==    by 0x405F88: core_loop (nc_core.c:316)
==9226==
==9226== LEAK SUMMARY:
==9226==    definitely lost: 0 bytes in 0 blocks
==9226==    indirectly lost: 0 bytes in 0 blocks
==9226==      possibly lost: 352,937 bytes in 1,129 blocks
==9226==    still reachable: 27,735 bytes in 50 blocks
==9226==         suppressed: 0 bytes in 0 blocks
==9226== Reachable blocks (those to which a pointer was found) are not shown.
==9226== To see them, rerun with: --leak-check=full --show-reachable=yes
&lt;/pre&gt;
&lt;p&gt;this script:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
data = '*3\r\n$3\r\nSET\r\n$13\r\nkkk-100001480\r\n$13\r\nvvv-100001480\r\n'
for i in range(1*1000):
    s.sendall(data)

#print s.recv(10*1000)
&lt;/pre&gt;
&lt;p&gt;ends with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
==9255== 4,292,608 bytes in 262 blocks are possibly lost in loss record 40 of 40
==9255==    at 0x4C274A8: malloc (vg_replace_malloc.c:236)
==9255==    by 0x411C75: _nc_alloc (nc_util.c:224)
==9255==    by 0x40BCF5: mbuf_get (nc_mbuf.c:46)
==9255==    by 0x40BD4A: mbuf_split (nc_mbuf.c:241)
==9255==    by 0x40A1AA: msg_recv (nc_message.c:434)
==9255==    by 0x406178: core_core (nc_core.c:158)
==9255==    by 0x41BBB7: event_wait (nc_epoll.c:269)
==9255==    by 0x405F88: core_loop (nc_core.c:316)
==9255==
==9255== LEAK SUMMARY:
==9255==    definitely lost: 0 bytes in 0 blocks
==9255==    indirectly lost: 0 bytes in 0 blocks
==9255==      possibly lost: 4,376,723 bytes in 535 blocks
&lt;/pre&gt;
&lt;p&gt;原因是太快的向proxy发送大量数据, proxy 不管三七二十一, 都把数据全部接收下来, 再慢慢处理, 这就造成大量msg对象堆在proxy的内存中,&lt;/p&gt;
&lt;p&gt;nutcracker always try to receive at the client side:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rstatus_t
core_core(void *arg, uint32_t events)
{
    /* read takes precedence over write */
    if (events &amp;amp; EVENT_READ) {
        status = core_recv(ctx, conn);      //call conn-&amp;gt;recv (msg_recv)
        if (status != NC_OK || conn-&amp;gt;done || conn-&amp;gt;err) {
            core_close(ctx, conn);
            return NC_ERROR;
        }
    }
    ...
}
&lt;/pre&gt;
&lt;p&gt;if the client write to the socket, it will always success, (something like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;redis-cli&lt;/span&gt; &lt;span class="pre"&gt;--pipe&lt;/span&gt;&lt;/tt&gt; ) then message queued at nutcracker, and got timeouted,&lt;/p&gt;
&lt;p&gt;the problem is client do not know when to stop sending request,&lt;/p&gt;
&lt;p&gt;I think we can add a config like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;max-queue&lt;/span&gt;&lt;/tt&gt;, if nutcracker got too much request queued, it stop read at the client side.&lt;/p&gt;
&lt;p&gt;so the client will block on sending&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mgetcase"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id133"&gt;mget慢这个case&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We are looking to use TwemProxy with Redis for sharding. We have use cases where we may need to fetch about 10k keys in one go from across multiple shards. However, when I try this with TwemProxy on a test setup (described below), it takes about 1.7 seconds to return. If I fired the same request on a single Redis instance directly, it returns in about 16ms.&lt;/p&gt;
&lt;p&gt;-m 512, I got the best results. With this, multi-key get on 10k keys returned in about 750ms&lt;/p&gt;
&lt;p&gt;For example, if my input buffer from read syscall contains 10 messages = [1, 2, 3, 4, 5, 6, ... 10], we leave existing message &amp;quot;1&amp;quot; in its current mbuf and copy messages from [2,3,4,5, ...10] to a new mbuf. Once message &amp;quot;1&amp;quot; is processed, we then we copy messages from [3,4,5,6,...10] to a new mbuf and so on and on. So, to split messages [1,2,3...10] across 10 mbufs we are doing quadratic instead of linear copies. This is really unfortunate,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id40"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id134"&gt;应该允许释放mbuf&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;否则一旦分配，就不释放&lt;/p&gt;
&lt;p&gt;大量并发mget, 就需要用小的mbuf size&lt;/p&gt;
&lt;p&gt;This is the reason why for 'large number' of connections or for wide multi-get like requests, you want to choose a small value for mbuf-size like 512&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id41"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id135"&gt;#一轮完了再集中加事件, 不要多次加, 重复加&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;实际上, 已经做了这个优化, 只有第一次加事件的时候才真正加:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void
req_forward(struct context *ctx, struct conn *c_conn, struct msg *msg)

    ...

    /* enqueue the message (request) into server inq */
    if (TAILQ_EMPTY(&amp;amp;s_conn-&amp;gt;imsg_q)) {
        status = event_add_out(ctx-&amp;gt;evb, s_conn);
        if (status != NC_OK) {
            req_forward_error(ctx, c_conn, msg);
            s_conn-&amp;gt;err = errno;
            return;
        }
    }
    s_conn-&amp;gt;enqueue_inq(ctx, s_conn, msg);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id42"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id136"&gt;#可能的优化:mget&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id43"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id137"&gt;改造&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;single 模式, 支持所有命令, 简单proxy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="key"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id138"&gt;key过长回错误&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id44"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id139"&gt;社区情况&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;pull-request:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;支持select db:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/217"&gt;https://github.com/twitter/twemproxy/pull/217&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/102"&gt;https://github.com/twitter/twemproxy/pull/102&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;支持ping:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/119/files"&gt;https://github.com/twitter/twemproxy/pull/119/files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;支持auth:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/81"&gt;https://github.com/twitter/twemproxy/pull/81&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;issues 大家的呼声:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;配置热加载 &lt;tt class="docutils literal"&gt;TODO&lt;/tt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/215"&gt;https://github.com/twitter/twemproxy/issues/215&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/6"&gt;https://github.com/twitter/twemproxy/issues/6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pubsub &lt;tt class="docutils literal"&gt;TODO&lt;/tt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/130"&gt;https://github.com/twitter/twemproxy/issues/130&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;select/auth/ping 的支持&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/103"&gt;https://github.com/twitter/twemproxy/issues/103&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/102"&gt;https://github.com/twitter/twemproxy/pull/102&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/81"&gt;https://github.com/twitter/twemproxy/pull/81&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;pipeline 下内存消耗:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/158"&gt;https://github.com/twitter/twemproxy/issues/158&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/issues/203"&gt;https://github.com/twitter/twemproxy/issues/203&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;支持sentinel 自动主从切换.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它人的一些改动:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;openbaas/aduong等同学支持了auth/ping/quit. 已经在twitter/twemproxy 里面的 auth_and_select 分支. 但是select 的支持没做.&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aduong/twemproxy/compare/0.2.4%2Bquit"&gt;https://github.com/aduong/twemproxy/compare/0.2.4%2Bquit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aduong/twemproxy/commit/871537d912f3036daeea883d7ed1ef6f642fa15e"&gt;https://github.com/aduong/twemproxy/commit/871537d912f3036daeea883d7ed1ef6f642fa15e&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/twitter/twemproxy/pull/81"&gt;https://github.com/twitter/twemproxy/pull/81&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;另一个同学的后续改动: &lt;a class="reference external" href="https://github.com/jdi-tagged/twemproxy/commit/5ba615865fff547f997998bcc9634ab680d83645"&gt;https://github.com/jdi-tagged/twemproxy/commit/5ba615865fff547f997998bcc9634ab680d83645&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;auth 没什么用, 但是ping和quit, 因为php-redis 里面关连接之前都会quit, 所以有用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;yuyuyu101/twemproxy 很久以前做了kqueue 的port, 不过没有merge 到主干&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;jbfavre/twemproxy 主要做一些打包工作, 比如debian包.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;shaofengniu/twemproxy 做了很多工作. 代码改动超过5000行.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id45"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id140"&gt;小结&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;twemproxy 对pipeline型的读写, 性能不好.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id46"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id141"&gt;期望&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ping/auth/quit 的几个支持希望能尽快merge到主干&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>vimcasts笔记</title><link href="/vim-vimcasts.html" rel="alternate"></link><updated>2013-12-05T11:13:53+08:00</updated><author><name>ning</name></author><id>tag:,2013-12-05:vim-vimcasts.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#show-invisibles" id="id8"&gt;#1.Show invisibles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tabs-and-spaces" id="id9"&gt;#2.Tabs and Spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#whitespace-preferences-and-filetypes" id="id10"&gt;#3.Whitespace preferences and filetypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tidying-whitespace" id="id11"&gt;#4.Tidying whitespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#indentation-commands" id="id12"&gt;#5.Indentation commands&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id13"&gt;缩进规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-buffers" id="id14"&gt;#6.Working with buffers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-windows-5-32" id="id15"&gt;#7 Working with windows (5:32)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#working-with-tabs-3-17" id="id16"&gt;#8 Working with tabs (3:17)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-to-use-tabs-5-28" id="id17"&gt;#9 How to use tabs (5:28)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-creating-the-vimcasts-logo-as-ascii-art-5-47" id="id18"&gt;#10 &amp;lt;nice-demo&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-the-changelist-and-jumplist-3-21" id="id19"&gt;#11 Using the changelist and jumplist (3:21)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#modal-editing-undo-redo-and-repeat-5-26" id="id20"&gt;#12 Modal editing: undo, redo and repeat (5:26)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cleaning-up-with-vim-0-36" id="id21"&gt;#13 Cleaning up with Vim (0:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-edit-command-3-50" id="id22"&gt;#14 The :edit command (3:50)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-file-explorer-5-36" id="id23"&gt;#15 The file explorer (5:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#soft-wrapping-text-4-54" id="id24"&gt;#16 Soft wrapping text (4:54)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hard-wrapping-text-5-23" id="id25"&gt;#17 Hard wrapping text (5:23)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#formatting-text-with-par-5-12" id="id26"&gt;#18 Formatting text with par (5:12)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#spell-checking-5-42" id="id27"&gt;#19 Spell checking (5:42)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#running-vim-within-irb-4-35" id="id28"&gt;#20 Running Vim within IRB (4:35)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-converting-markdown-to-struct-ured-html-with-a-macro-9-25" id="id29"&gt;#21 &amp;lt;nice-demo&amp;gt;Converting markdown to struct_ured HTML with a macro (9:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nice-demo-selecting-columns-with-visual-block-mode-4-21" id="id30"&gt;#22 &amp;lt;nice-demo&amp;gt;Selecting columns with visual block mode (4:21)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#converting-haml-to-erb-with-vim-macros-7-36" id="id31"&gt;#23 Converting HAML to ERB with Vim macros (7:36)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#updating-your-vimrc-file-on-the-fly-2-51" id="id32"&gt;#24 Updating your vimrc file on the fly (2:51)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-colorschemes-for-vim-9-44" id="id33"&gt;#25 Creating colorschemes for Vim (9:44)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bubbling-text-6-23" id="id34"&gt;#26 Bubbling text (6:23)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#synchronizing-plugins-with-git-submodules-and-pathogen-9-24" id="id35"&gt;#27 Synchronizing plugins with git submodules and pathogen (9:24)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#refining-search-patterns-with-the-command-line-window-7-51" id="id36"&gt;#28 Refining search patterns with the command-line window (7:51)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#aligning-text-with-tabular-vim-5-11" id="id37"&gt;#29 Aligning text with Tabular.vim (5:11)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#undo-branching-and-gundo-vim-6-30" id="id38"&gt;#30 Undo branching and Gundo.vim (6:30)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id39"&gt;例1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id40"&gt;例2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#undo-branch" id="id41"&gt;undo branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gundo" id="id42"&gt;gundo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-a-complement-to-command-line-git-8-27" id="id43"&gt;#31 Fugitive.vim - a complement to command line git (8:27)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-working-with-the-git-index-11-41" id="id44"&gt;#32 Fugitive.vim - working with the git index (11:41)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-resolving-merge-conflicts-with-vimdiff-11-35" id="id45"&gt;#33 Fugitive.vim - resolving merge conflicts with vimdiff (11:35)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-browsing-the-git-object-database-9-45" id="id46"&gt;#34 Fugitive.vim - browsing the git object database (9:45)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fugitive-vim-exploring-the-history-of-a-git-repository-10-04" id="id47"&gt;#35 Fugitive.vim - exploring the history of a git repository (10:04)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vimgolf-prime-numbers-6-53" id="id48"&gt;#36 VimGolf - Prime Numbers (6:53)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#how-to-fold-8-49" id="id49"&gt;#37 How to fold (8:49)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#writing-a-custom-fold-expression-12-07" id="id50"&gt;#38 Writing a custom fold expression (12:07)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#profiling-vimscript-performance-8-09" id="id51"&gt;#39 Profiling Vimscript performance (8:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#long-range-line-duplication-6-31" id="id52"&gt;#40 Long-range line duplication (6:31)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#meet-the-arglist-4-57" id="id53"&gt;#41 Meet the arglist (4:57)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#populating-the-arglist-5-31" id="id54"&gt;#42 Populating the arglist (5:31)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-argdo-to-change-multiple-files-5-40" id="id55"&gt;#43 Using :argdo to change multiple files (5:40)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#search-multiple-files-with-vimgrep-7-25" id="id56"&gt;#44 Search multiple files with :vimgrep (7:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#project-wide-find-and-replace-6-25" id="id57"&gt;#45 Project-wide find and replace (6:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#search-for-the-selected-text-4-39" id="id58"&gt;#46 Search for the selected text (4:39)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#smart-search-with-subvert-5-33" id="id59"&gt;&amp;#64;47 Smart search with :Subvert (5:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#supercharged-substitution-with-subvert-7-09" id="id60"&gt;&amp;#64;48 Supercharged substitution with :Subvert (7:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#enhanced-abbreviations-with-abolish-3-09" id="id61"&gt;&amp;#64;49 Enhanced abbreviations with :Abolish (3:09)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#an-introduction-to-vspec-7-15" id="id62"&gt;#50 An introduction to vspec (7:15)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#simple-operations-using-the-default-register-4-07" id="id63"&gt;#51 Simple operations using the default register (4:07)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#meet-the-yank-register-4-29" id="id64"&gt;#52 Meet the yank register (4:29)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-vim-s-named-registers-3-29" id="id65"&gt;#53 Using Vim's named registers (3:29)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pasting-from-visual-mode-3-33" id="id66"&gt;#54 Pasting from Visual mode (3:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#pasting-from-insert-mode-4-15" id="id67"&gt;#55 Pasting from Insert mode (4:15)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#simple-calculations-with-vim-s-expression-register-4-02" id="id68"&gt;#56 Simple calculations with Vim's expression register (4:02)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#evaluating-scripts-with-vim-s-expression-register-3-56" id="id69"&gt;#57 Evaluating scripts with Vim's expression register (3:56)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#accessing-the-system-clipboard-from-vim-4-48" id="id70"&gt;#58 Accessing the system clipboard from Vim (4:48)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-vim-s-paste-mode-with-the-system-paste-command-4-25" id="id71"&gt;#59 Using Vim's paste mode with the system paste command (4:25)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#comparing-buffers-with-vimdiff-4-16" id="id72"&gt;#60 Comparing buffers with vimdiff (4:16)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-repeatable-mappings-with-repeat-vim-4-33" id="id73"&gt;#61 Creating repeatable mappings with repeat.vim (4:33)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id74"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ning-vim-modline" id="id75"&gt;ning: vim modline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id76"&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;关于&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个系列视频来自:
&lt;a class="reference external" href="http://vimcasts.org/episodes/archive"&gt;http://vimcasts.org/episodes/archive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者每个月会录1-5个视频放出来.从2010年坚持到现在.&lt;/p&gt;
&lt;p&gt;这个网站的作者经常进行 vim 课程, $250 每次.(4小时)
他也是 &amp;lt;Practical Vim&amp;gt; 的作者(&lt;strong&gt;豆瓣8.9分&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;对tabstop 不熟悉的, 建议观看1,2,4&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="show-invisibles"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;#1.Show invisibles&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;显示不可见字符:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set list
set nolist
&lt;/pre&gt;
&lt;p&gt;修改使用的不可见字符样式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tabs-and-spaces"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;#2.Tabs and Spaces&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;tabstop:&lt;/th&gt;&lt;td class="field-body"&gt;tab符宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;softtabstop:&lt;/th&gt;&lt;td class="field-body"&gt;使用&amp;lt;-键删除的时候, 删除多少宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;shiftwidth:&lt;/th&gt;&lt;td class="field-body"&gt;用&amp;gt;, &amp;lt;缩进的时候, 插入多宽.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;expandtab:&lt;/th&gt;&lt;td class="field-body"&gt;输入的tab, shift 时, 都替换为空格.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;默认值:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tabstop = 8
softtabstop = 0
shiftwidth = 8
no expandtab
&lt;/pre&gt;
&lt;p&gt;不一样会很混乱&lt;/p&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;保证 tabstop == softtabstop == shiftwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;retab&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="whitespace-preferences-and-filetypes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;#3.Whitespace preferences and filetypes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用autocommand实现对python 和Makefile 不同的缩进设置.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tidying-whitespace"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;#4.Tidying whitespace&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;convert between tabs and spaces.&lt;/li&gt;
&lt;li&gt;strip trailing whitespace,&lt;/li&gt;
&lt;li&gt;how to remove blank lines from a file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;noexpandtab 的时候, &lt;cite&gt;retab&lt;/cite&gt; 把space 变成tab,
expandtab 的时候  &lt;cite&gt;retab&lt;/cite&gt; 把tab变成space.&lt;/p&gt;
&lt;p&gt;不错的函数例子, 保存当前位置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! &amp;lt;SID&amp;gt;StripTrailingWhitespaces()
    &amp;quot; Preparation: save last search, and cursor position.
    let _s=&amp;#64;/
    let l = line(&amp;quot;.&amp;quot;)
    let c = col(&amp;quot;.&amp;quot;)
    &amp;quot; Do the business:
    %s/\s\+$//e
    &amp;quot; Clean up: restore previous search history, and cursor position
    let &amp;#64;/=_s
    call cursor(l, c)
endfunction
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除空白行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:g/^$/d
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;g命令&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;:g 表示范围 &lt;tt class="docutils literal"&gt;global command&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;d 是一个Ex command&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="indentation-commands"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;#5.Indentation commands&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;就是讲&amp;gt;&amp;gt; 和 &amp;lt;&amp;lt;
还有:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vmap &amp;lt;D-[&amp;gt; &amp;lt;gv (我用tab和shift-tab)
vmap &amp;lt;D-]&amp;gt; &amp;gt;gv
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;N模式下用 &lt;tt class="docutils literal"&gt;==&lt;/tt&gt;, V模式下用 &lt;tt class="docutils literal"&gt;=&lt;/tt&gt; 格式化,&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;vi}&lt;/tt&gt; 选择{}中的代码.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;=i}&lt;/tt&gt; 格式化{}中的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;缩进规则&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;~/.vim/indent/python.vim&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-buffers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;#6.Working with buffers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;讲的不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:buffers
1 #    &amp;quot;.recent&amp;quot;                      line 2        # 是上一个活跃buffer
2      &amp;quot;./notes/misc/vim_usage.rst&amp;quot;   line 217
3 %a   &amp;quot;./notes/misc/vim-vimcasts.rst&amp;quot; line 123     %a是active buffer
&lt;/pre&gt;
&lt;p&gt;如果修改了一下 .recent. 就需要 bn! 才能切到下一个buffer:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:ls
1 #h + &amp;quot;.recent&amp;quot;                      line 3            +表示有modify,  h 表示hidden
2 %a   &amp;quot;./notes/misc/vim_usage.rst&amp;quot;   line 217
3  a   &amp;quot;./notes/misc/vim-vimcasts.rst&amp;quot; line 0
&lt;/pre&gt;
&lt;p&gt;bn时不要求buffer 一定要写入:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set hidden
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:ls&lt;/tt&gt;     show the buffer list&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:bn&lt;/tt&gt;     open the next buffer in t        he current window (cycles from the end of the list to the beginning).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;:bp&lt;/tt&gt;     open the previous buffer in the current window (cycles from the start of the  list to the end).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CTRL-^&lt;/span&gt;&lt;/tt&gt;   switch to the alternate file&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-windows-5-32"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;#7 Working with windows (5:32)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;知识通过读 &lt;tt class="docutils literal"&gt;window&lt;/tt&gt; 一节, 已经知道, 演示的例子不错.&lt;/p&gt;
&lt;p&gt;移动焦点:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ctrl-w hjkl
&lt;/pre&gt;
&lt;p&gt;移动窗口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ctrl-w HJKL
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="working-with-tabs-3-17"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;#8 Working with tabs (3:17)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:tabedit xxx.txt

:tabonly

:3gt, 直接到第几个tab.
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
map &amp;lt;C-1&amp;gt; 1gt
map &amp;lt;C-2&amp;gt; 2gt
map &amp;lt;C-3&amp;gt; 3gt
map &amp;lt;C-4&amp;gt; 4gt
map &amp;lt;C-5&amp;gt; 5gt
map &amp;lt;C-6&amp;gt; 6gt
map &amp;lt;C-7&amp;gt; 7gt
map &amp;lt;C-8&amp;gt; 8gt
map &amp;lt;C-9&amp;gt; 9gt
map &amp;lt;C-0&amp;gt; :tablast&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;可惜在我这用不了&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tabmove
tabmove 1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-use-tabs-5-28"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;#9 How to use tabs (5:28)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一节基本没有什么内容..&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-creating-the-vimcasts-logo-as-ascii-art-5-47"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;#10 &amp;lt;nice-demo&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ASCII art&lt;/p&gt;
&lt;p&gt;在线工具: &lt;a class="reference external" href="http://patorjk.com/software/taag/#p=display&amp;amp;v=0&amp;amp;f=Bulbhead&amp;amp;t=hello"&gt;http://patorjk.com/software/taag/#p=display&amp;amp;v=0&amp;amp;f=Bulbhead&amp;amp;t=hello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;宏:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
qavwr_jq
q      q  两个q作为起始和结束
 a        表示放在a这个寄存器.
&lt;/pre&gt;
&lt;p&gt;这一节对vim 的:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;V模式,&lt;/li&gt;
&lt;li&gt;ctrl+v 模式,&lt;/li&gt;
&lt;li&gt;拷贝,&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;宏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等的介绍, 对初学者是 &lt;strong&gt;很好的例子&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用hint&lt;/strong&gt;, 如何在ctrl+v (C-V)模式下, 只替换选中的内容:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
aaxxxaaaaaabbbbbb
&lt;/pre&gt;
&lt;p&gt;选中后 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;'&amp;lt;,'&amp;gt;s/./x/g&lt;/span&gt;&lt;/tt&gt;, 替换是在整个行上的. 会把ab都替换&lt;/p&gt;
&lt;p&gt;需要加上 &lt;tt class="docutils literal"&gt;\%V&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:'&amp;lt;,'&amp;gt;s/\%V./x/g
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="using-the-changelist-and-jumplist-3-21"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;#11 Using the changelist and jumplist (3:21)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;changelist:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:changes
g;  到上一个编辑点.
g,
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
10g;  到倒数第10个编辑点.

   10   269    0 ============================
    9   197    8 #10 &amp;lt;nice&amp;gt;Creating the Vimcasts logo as ASCII art (5:47)
    8   269    0 ============================
    7   232    0
    6   269    0 ============================
    5   235    0
    4   269    0 ============================
    3   269    0 ============================
    2   238    4 :changes
    1   242    0
&amp;gt;   0   250    0
    1   247    9 ctrl+I
    2   269    0 ============================
    3   248    0
    4   269    0 ============================
    5   239   29 g;  到上一个编辑点.
    6   269    0 ============================
    7   269    0 ============================
    8   240   36 10g;  到倒数第10个编辑点.
    9   269    0 ============================
   10   269    0 ============================
&lt;/pre&gt;
&lt;p&gt;jumplist, 比较熟悉了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:jumps
ctrl+O
ctrl+I
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="modal-editing-undo-redo-and-repeat-5-26"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;#12 Modal editing: undo, redo and repeat (5:26)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;.是对编辑命令重复, 不会对移动命令.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt; :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;cw&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;dwi&lt;/tt&gt;  (之后进入insert模式)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;I&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;^i&lt;/tt&gt;    (到行首insert)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;A&lt;/tt&gt;  相当于 &lt;tt class="docutils literal"&gt;$i&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o&lt;/tt&gt;  想当于 &lt;tt class="docutils literal"&gt;$a&amp;lt;CR&amp;gt;&lt;/tt&gt; (这个习惯了)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cleaning-up-with-vim-0-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;#13 Cleaning up with Vim (0:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;搞笑的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-edit-command-3-50"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;#14 The :edit command (3:50)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;:e&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;:help expand&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
map &amp;lt;leader&amp;gt;ew :e &amp;lt;C-R&amp;gt;=expand(&amp;quot;%:p:h&amp;quot;) . &amp;quot;/&amp;quot; &amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;后, 通过,ew, 就可以:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
e /home/ning/idning/blog_and_notes/notes/misc/
&lt;/pre&gt;
&lt;p&gt;有点用处, 不过不大, 下面这个更有用些:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Thanks to Gary Bernhardt, here is a less horrible way of creating the same mappings:

cnoremap %% &amp;lt;C-R&amp;gt;=fnameescape(expand('%:h')).'/'&amp;lt;cr&amp;gt;

this allows you to expand the directory of the current file anywhere at the command line by pressing %%. A top tip from Max Cantor!
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cmap&lt;/strong&gt;  是命令行的map, 可以在命令行里面, 用%%表示当前文件路径, &lt;strong&gt;这个收入我的.vimrc&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-file-explorer-5-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;#15 The file explorer (5:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用 &lt;tt class="docutils literal"&gt;:E&lt;/tt&gt;, 用原生的目录管理器打开 一个目录, 支持排序，创建文件/目录, 删除, 重命名等:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Netrw Directory Listing                                        (netrw v149)
&amp;quot;   /home/ning/idning/blog_and_notes
&amp;quot;   Sorted by time
&amp;quot;   Quick Help: &amp;lt;F1&amp;gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec

%   create a new file
d   create a new directory
R   rename the file/directory under the cursor
D   Delete the file/directory under the cursor
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="soft-wrapping-text-4-54"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;#16 Soft wrapping text (4:54)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;关于:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set wrap
set linebreak
set showbreak=◀  (在被wrap的行前面加个符号)
&lt;/pre&gt;
&lt;p&gt;关闭wrap:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set nowrap (此时可以用zl来向右滚动)
&lt;/pre&gt;
&lt;p&gt;开启wrap:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set wrap
&lt;/pre&gt;
&lt;p&gt;此时默认是会断开单词的, 可以用 &lt;tt class="docutils literal"&gt;:set linebreak&lt;/tt&gt;, 设置为不断开单词, (这和 &lt;tt class="docutils literal"&gt;:set list&lt;/tt&gt; 是冲突的)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用: 有wrap时候的移动&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;$&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; ,  &lt;tt class="docutils literal"&gt;j&lt;/tt&gt;  等前面加上 &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; , 就是按照break后的行来移动了(按照显示行移动)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hard-wrapping-text-5-23"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id25"&gt;#17 Hard wrapping text (5:23)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;未看&lt;/p&gt;
&lt;p&gt;强制断行.&lt;/p&gt;
&lt;p&gt;选中一段``gq``就是按照80列格式化,&lt;/p&gt;
&lt;p&gt;the textwidth setting is a number representing the maximum allowed width of a
line. when set to zero, which is the default, vim will use the full width of
the window up to a maximum of 80 characters. when set to a value above zero,
vim will format lines of text so as not to exceed the value of textwidth.&lt;/p&gt;
&lt;p&gt;相关设置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set textwidth=xx &amp;quot; 一行最多多宽
默认 textwidth=0, 表示按照当前窗口宽度(但是得小于80)来做断行.

set wrapmargin=xx &amp;quot; 断行的时候, 右边空多少个字符(set nu后就需要这个了) 如果设置了textwidth, 则这个选项没有用
默认wrapmargin=0,
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
::set formatoptions=tcq
默认: formatoptions=tcroql

:set formatoptions+=a &amp;quot; 在输入的时候自动断行. 会比较奇怪. 不要设
&lt;/pre&gt;
&lt;p&gt;两个format engine: formatexpr vs formatprg.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="formatting-text-with-par-5-12"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id26"&gt;#18 Formatting text with par (5:12)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;设置外部fromat engine:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set formatprg=par
&lt;/pre&gt;
&lt;p&gt;par 输出更好看, 能处理注释格式.&lt;/p&gt;
&lt;p&gt;太复杂, 木有必要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="spell-checking-5-42"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id27"&gt;#19 Spell checking (5:42)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:set spell
对txt文件有用, 写代码用不着.

~/.vim/spell/LL.EEE.add
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="running-vim-within-irb-4-35"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id28"&gt;#20 Running Vim within IRB (4:35)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;IRB: interactive ruby shell&lt;/p&gt;
&lt;p&gt;在irb解释器里面调用vim来编辑代码(比如定义一个多行的函数),  &lt;strong&gt;确实不错的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;python 要有这个多好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-converting-markdown-to-struct-ured-html-with-a-macro-9-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id29"&gt;#21 &amp;lt;nice-demo&amp;gt;Converting markdown to struct_ured HTML with a macro (9:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;surround.vim 插件&lt;/p&gt;
&lt;p&gt;用例子讲解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非常好的例子, 应该再看一遍&lt;/strong&gt; , 虽然不是很常用, 而且可以用脚本实现, 但是用的多了, 还是很有效率!!&lt;/p&gt;
&lt;p&gt;比如 &lt;tt class="docutils literal"&gt;&amp;quot;zdw&lt;/tt&gt;  剪切到 &lt;tt class="docutils literal"&gt;z&lt;/tt&gt; 寄存器 &lt;tt class="docutils literal"&gt;&amp;quot;zP&lt;/tt&gt; 粘贴出来, 这样的寄存器, 一般多用在宏里面.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-demo-selecting-columns-with-visual-block-mode-4-21"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id30"&gt;#22 &amp;lt;nice-demo&amp;gt;Selecting columns with visual block mode (4:21)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对 &lt;tt class="docutils literal"&gt;ctrl+v&lt;/tt&gt; 非常好的例子, 自己已经用习惯了:)&lt;/p&gt;
&lt;p&gt;textmate 也有这个功能.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;ctrl+v&lt;/tt&gt;
可以用&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;I&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;A&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;r&lt;/tt&gt; 替换&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;d&lt;/tt&gt; 删&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;p&lt;/tt&gt; 粘贴&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;c&lt;/tt&gt; &lt;strong&gt;这个有用&lt;/strong&gt; , 删掉选中的, 再进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;C&lt;/tt&gt; 这相当于按了 &lt;tt class="docutils literal"&gt;$&lt;/tt&gt; .&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o&lt;/tt&gt; &lt;strong&gt;有用&lt;/strong&gt; 到选中方块的对角.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;o9&lt;/tt&gt; 固定到块尾,(对V模式都一样)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
############################
# nihao ,wo hao            #
#                          #
############################
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="converting-haml-to-erb-with-vim-macros-7-36"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id31"&gt;#23 Converting HAML to ERB with Vim macros (7:36)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;也是例子, 没有特别的东东, 例子需要对ruby 熟悉才比较好懂.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-your-vimrc-file-on-the-fly-2-51"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id32"&gt;#24 Updating your vimrc file on the fly (2:51)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:source $MYVIMRC
autocmd bufwritepost .vimrc source $MYVIMRC
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-colorschemes-for-vim-9-44"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id33"&gt;#25 Creating colorschemes for Vim (9:44)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认放在~/.vim/colors/下面:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
highlight Todo guifg=#990000 guibg=NONE gui=NONE
highlight link Comment Todo
&lt;/pre&gt;
&lt;p&gt;对颜色没有特殊癖好.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bubbling-text-6-23"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id34"&gt;#26 Bubbling text (6:23)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;类似Eclise &amp;lt;ctrl+up&amp;gt; &amp;lt;ctrl-down&amp;gt; 之类的功能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Bubble single lines
nmap &amp;lt;C-Up&amp;gt; ddkP
nmap &amp;lt;C-Down&amp;gt; ddp
&amp;quot; Bubble multiple lines
vmap &amp;lt;C-Up&amp;gt; xkP`[V`]
vmap &amp;lt;C-Down&amp;gt; xp`[V`]
&lt;/pre&gt;
&lt;p&gt;虽然自己基本不用, 不过还是 &lt;strong&gt;不错的tip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面这个很有用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;gV&lt;/tt&gt; 选择刚编辑的地方:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; Visually select the text that was last edited/pasted
nmap gV `[v`]
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="synchronizing-plugins-with-git-submodules-and-pathogen-9-24"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id35"&gt;#27 Synchronizing plugins with git submodules and pathogen (9:24)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用这种方法管理模块:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Installation:

    git clone git://github.com/nelstrom/dotvim.git ~/.vim

Create symlinks:

    ln -s ~/.vim/vimrc ~/.vimrc
    ln -s ~/.vim/gvimrc ~/.gvimrc

Switch to the `~/.vim` directory, and fetch submodules:

    cd ~/.vim
    git submodule init
    git submodule update
&lt;/pre&gt;
&lt;p&gt;附带了一个简单的github用法介绍.&lt;/p&gt;
&lt;p&gt;Pathgon: 10年10月就有了的, 现在已然3年过去了.&lt;/p&gt;
&lt;p&gt;我用svn+vundle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refining-search-patterns-with-the-command-line-window-7-51"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id36"&gt;#28 Refining search patterns with the command-line window (7:51)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Refining 是提炼的意思&lt;/p&gt;
&lt;p&gt;When you press : or / in Vim, you go into commandline mode. 此时:&lt;/p&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-p:&lt;/th&gt;&lt;td class="field-body"&gt;Show previous historical command/search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-n:&lt;/th&gt;&lt;td class="field-body"&gt;Show next         historical command/search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;ctrl-f:&lt;/th&gt;&lt;td class="field-body"&gt;Switch from commandline mode to the co    mmandline window&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在normal模式下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;q/&lt;/tt&gt;:  Open the commandline window with history of searches&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;q:&lt;/tt&gt;:  Open the commandline window with history of commands&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;command-line window, 需要练习, 对正则式来说也是不错的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在写command的时候, 可以用 &lt;tt class="docutils literal"&gt;ctrl+n&lt;/tt&gt; 自动提示.&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
\v'.+'
\v'[^']+'
\v'('\w|[^'])+'
\v'(('\w|[^'])+)'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="aligning-text-with-tabular-vim-5-11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id37"&gt;#29 Aligning text with Tabular.vim (5:11)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Tab /=
:Tab /:
&lt;/pre&gt;
&lt;p&gt;下面这个如果用在输入等号的时候格式化应该不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
inoremap &amp;lt;silent&amp;gt; &amp;lt;Bar&amp;gt;   &amp;lt;Bar&amp;gt;&amp;lt;Esc&amp;gt;:call &amp;lt;SID&amp;gt;align()&amp;lt;CR&amp;gt;a

function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') &amp;amp;&amp;amp; getline('.') =~# '^\s*|' &amp;amp;&amp;amp; (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="undo-branching-and-gundo-vim-6-30"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id38"&gt;#30 Undo branching and Gundo.vim (6:30)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;每次回到normal 状态的时候, 记录一个undo record, 这很重要!!&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;例1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在riv.vim插件里面, 如果设置了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
let s:default.buf_imaps = {
    \'&amp;lt;BS&amp;gt;'         : 'riv#action#ins_backspace()',
    \'&amp;lt;CR&amp;gt;'         : 'riv#action#ins_enter()'   ,
    \'&amp;lt;KEnter&amp;gt;'     : 'riv#action#ins_enter()'   ,
    ...
}
&lt;/pre&gt;
&lt;p&gt;这里粘贴一段多行文字的时候, 每次遇到&amp;lt;CR&amp;gt;都会切入normal模式, 造成多个undo history&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;例2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;自己的修改LastModified 字段的插件, 每次保存的时候, 都会生成两个undo history, undo 的时候会跳到文件头.&lt;/p&gt;
&lt;p&gt;不少人遇到这个问题:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/12741977/prevent-vim-from-updating-its-undo-tree"&gt;http://stackoverflow.com/questions/12741977/prevent-vim-from-updating-its-undo-tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stackoverflow.com/questions/17969784/vim-temporary-disable-undo"&gt;http://stackoverflow.com/questions/17969784/vim-temporary-disable-undo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都没有很好解决.&lt;/p&gt;
&lt;p&gt;我通过在python里面判断, 如果last modify 正好是当天, 就不做update, 来减少undo history&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="undo-branch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id41"&gt;undo branch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;vim 7.0的特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里讲解非常好!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为undo, redo 只能在一个分支上走, 不能到一个已经被丢弃的分支,
但是可以通过 &lt;tt class="docutils literal"&gt;g+&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;g-&lt;/tt&gt; 回到上一个状态(可以在undo branch之间切换!) 类似时光机.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:earlier {count}    Go to older text state {count} times.
:earlier {N}s       Go to older text state about {N} seconds before.
:earlier {N}m       Go to older text state about {N} minutes before.
:earlier {N}h       Go to older text state about {N} hours before.
:earlier {N}d       Go to older text state about {N} days before.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="gundo"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id42"&gt;gundo&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个插件, 可以展示undo branch的分支, 还能显示两次变换之间的diff.&lt;/p&gt;
&lt;p&gt;也是用python做的!&lt;/p&gt;
&lt;p&gt;很赞: &lt;a class="reference external" href="https://github.com/sjl/gundo.vim"&gt;https://github.com/sjl/gundo.vim&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-a-complement-to-command-line-git-8-27"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id43"&gt;#31 Fugitive.vim - a complement to command line git (8:27)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git run任何git命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Git log
:Git lg

:Gwrite
:Gread
:Gremove
:Gmove
&lt;/pre&gt;
&lt;p&gt;感觉没有必要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-working-with-the-git-index-11-41"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id44"&gt;#32 Fugitive.vim - working with the git index (11:41)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Gstatus&lt;/tt&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;之后用 &lt;tt class="docutils literal"&gt;-&lt;/tt&gt; 来修改是否要stage 一个文件, 很赞&lt;/li&gt;
&lt;li&gt;之后用 &lt;tt class="docutils literal"&gt;C&lt;/tt&gt; 来开始commit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Gblame&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;Gdiff&lt;/tt&gt; 是有点用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-resolving-merge-conflicts-with-vimdiff-11-35"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id45"&gt;#33 Fugitive.vim - resolving merge conflicts with vimdiff (11:35)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gdiff 3路merge , 太复杂.&lt;/p&gt;
&lt;p&gt;diffput, diffget 太夫在, &lt;tt class="docutils literal"&gt;dp&lt;/tt&gt; 还好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-browsing-the-git-object-database-9-45"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id46"&gt;#34 Fugitive.vim - browsing the git object database (9:45)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gbrowser挺强大和方便, &lt;em&gt;但是少用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;statusline显示git branch:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
set statusline=%&amp;lt;%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fugitive-vim-exploring-the-history-of-a-git-repository-10-04"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id47"&gt;#35 Fugitive.vim - exploring the history of a git repository (10:04)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Fugitive.vim这个插件挺强大和方便, 但是这些功能太少用了 -- 很多人几乎一年浏览一下某个项目的历史项目, 就不错了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vimgolf-prime-numbers-6-53"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id48"&gt;#36 VimGolf - Prime Numbers (6:53)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VimGolf是一个Vim挑战网站, 从获得Prime Numbers这个例子上, 可以学习宏/正则式.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-fold-8-49"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id49"&gt;#37 How to fold (8:49)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;:help fold-methods&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zi&lt;/tt&gt; switch folding on or off&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;za&lt;/tt&gt; toggle current fold open/closed&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zc&lt;/tt&gt;          close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zR&lt;/tt&gt; open all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zM&lt;/tt&gt; close all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zv&lt;/tt&gt; expand folds           to reveal cursor&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zo&lt;/tt&gt;  open current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zO&lt;/tt&gt;  recursively open current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zc&lt;/tt&gt;  close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zC&lt;/tt&gt;  recursively close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;za&lt;/tt&gt;  toggle current fold                           有用, 可以换掉zc, zo&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zA&lt;/tt&gt;  recursively open/close current fold&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zm&lt;/tt&gt;  reduce &lt;cite&gt;foldlevel&lt;/cite&gt; by one&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zM&lt;/tt&gt;  close all folds&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zr&lt;/tt&gt;  increase &lt;cite&gt;foldlevel&lt;/cite&gt; by one&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;zR&lt;/tt&gt;  open all folds&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;nnoremap &amp;lt;Space&amp;gt; za&lt;/tt&gt; 不错, 很方便.&lt;/p&gt;
&lt;p&gt;知识点不多, 基本都用惯了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-a-custom-fold-expression-12-07"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id50"&gt;#38 Writing a custom fold expression (12:07)&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;foldcolumn&lt;/tt&gt; 是说左边有几个列是放fold标记的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用foldmethod=marker 时, 可以用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{{{
{{{1  这里1表示级别
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s the boilerplate fold expression that we used to begin with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! MarkdownFolds()
  return &amp;quot;0&amp;quot;
endfunction
setlocal foldmethod=expr
setlocal foldexpr=MarkdownFolds()
&lt;/pre&gt;
&lt;p&gt;返回值:&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;0&amp;quot; the line is not in a fold
&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, ...   the line is in a fold with this level
&amp;quot;=&amp;quot; use fold level from the previous line
&amp;quot;&amp;gt;1&amp;quot;, &amp;quot;&amp;gt;2&amp;quot;  a fold with this level starts at this line&lt;/blockquote&gt;
&lt;p&gt;可以通过这个函数, 设置fold的区域显示什么:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
function! MarkdownFoldText()
  return getline(v:foldstart)
endfunction
setlocal foldtext=MarkdownFoldText()
&lt;/pre&gt;
&lt;p&gt;有用但是不重要&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="profiling-vimscript-performance-8-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id51"&gt;#39 Profiling Vimscript performance (8:09)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vim --cmd 'profile start vimrc.profile' --cmd 'profile! file ~/.vimrc'&lt;/p&gt;
&lt;p&gt;会把profile结果记录在vimrc.profile 里面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赞&lt;/strong&gt; , 有用技巧&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="long-range-line-duplication-6-31"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id52"&gt;#40 Long-range line duplication (6:31)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;没用, 不方便, 把第9行拷贝到16行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:9copy16
&lt;/pre&gt;
&lt;p&gt;拷贝到当前行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:9t.
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
set relativenumber, 显示相对行号

:-7t.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="meet-the-arglist-4-57"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id53"&gt;#41 Meet the arglist (4:57)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:args
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.&lt;/tt&gt; 是重复上一个编辑命令
&lt;tt class="docutils literal"&gt;&amp;#64;:&lt;/tt&gt; 是重复上一个命令模式的命令&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;buffer list&lt;/tt&gt; 包含 &lt;tt class="docutils literal"&gt;argument list&lt;/tt&gt;, 比如我用 &lt;tt class="docutils literal"&gt;lsrecent&lt;/tt&gt; 打开一个文件后, &lt;tt class="docutils literal"&gt;:args&lt;/tt&gt; 显示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[.recent]
&lt;/pre&gt;
&lt;p&gt;并不显示当前文件.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="populating-the-arglist-5-31"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id54"&gt;#42 Populating the arglist (5:31)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;how to set the contents of the arglist using the :args command, which can receive filepaths, globs, or even backtick expressions.&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:args notes/misc/vim-ctags-vs-cscope.rst
&lt;/pre&gt;
&lt;p&gt;会打开这个文件.&lt;/p&gt;
&lt;p&gt;args 有点像用 &lt;tt class="docutils literal"&gt;vim *.rst&lt;/tt&gt; 这样的命令打开多个文件的时候, 带的参数 &lt;tt class="docutils literal"&gt;*.rst&lt;/tt&gt;, 可以传shell 命令给args:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
args `cat a.txt`
&lt;/pre&gt;
&lt;img alt="" src="/imgs/vim_buffer_list_vs_arglist.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="using-argdo-to-change-multiple-files-5-40"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id55"&gt;#43 Using :argdo to change multiple files (5:40)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个没啥可说的&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="search-multiple-files-with-vimgrep-7-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id56"&gt;#44 Search multiple files with :vimgrep (7:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vimgrep is Vim’s built-in command for searching across multiple files. It’s not so fast as external tools like ack and git-grep, but it has its uses. vimgrep uses Vim’s built-in regex engine, so you can reuse the patterns that work with Vim’s standard search command.&lt;/p&gt;
&lt;p&gt;不如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ack
git-grep
ag
&lt;/pre&gt;
&lt;p&gt;快.&lt;/p&gt;
&lt;p&gt;grep 一个东西:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:Ack ensureIndex
:grep ensureIndex * -r  会把svn 之类的grep出来.

在当前文件中找:
:vimgrep /ensureIndex/g %

:vimgrep /ensureIndex/g *

:vimgrep /ensureIndex/g `find . -type f`

在arglist 里面搜索
:vimgrep /ensureIndex/g ##
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
:vim /pattern1/ `find . -type f`
:vim /pattern2/ `find . -type f`
:vim /pattern3/ `find . -type f`
&lt;/pre&gt;
&lt;p&gt;可以换成:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:args `find . -type f`
:vim /pattern1/ ##
:vim /pattern2/ ##
:vim /pattern3/ ##
&lt;/pre&gt;
&lt;p&gt;vimgrep 的优势只有: 和vim使用同样的正则.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-wide-find-and-replace-6-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id57"&gt;#45 Project-wide find and replace (6:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;把quickfix 窗口里面的文件名, 放到arglist里面去, &lt;strong&gt;非常有用&lt;/strong&gt;, 但是用到这种全局替换的case不多:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  &amp;quot; Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
&lt;/pre&gt;
&lt;p&gt;这样, 流程变为:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;vimgrep 找出需要替换的单词&lt;/li&gt;
&lt;li&gt;Qargs&lt;/li&gt;
&lt;li&gt;:argdo %s/xxx/xxxxx/ge&lt;/li&gt;
&lt;li&gt;:argdo w&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="search-for-the-selected-text-4-39"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id58"&gt;#46 Search for the selected text (4:39)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用内置功能:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:vmap X y/&amp;lt;C-R&amp;gt;&amp;quot;&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;用插件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
visual-star-search plugin from github,
&lt;/pre&gt;
&lt;p&gt;非常有用, 效果比之前用的 &lt;tt class="docutils literal"&gt;UtilVisualSelection&lt;/tt&gt; 好.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;某些时候可以替代ack&lt;/strong&gt; 也不错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot; recursively vimgrep for word under cursor or selection if you hit leader-star
nnoremap &amp;lt;leader&amp;gt;* :execute 'noautocmd vimgrep /\V' . substitute(escape(expand(&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;), '\'), '\n', '\\n', 'g') . '/ **'&amp;lt;CR&amp;gt;
vnoremap &amp;lt;leader&amp;gt;* :&amp;lt;C-u&amp;gt;call &amp;lt;SID&amp;gt;VSetSearch()&amp;lt;CR&amp;gt;:execute 'noautocmd vimgrep /' . &amp;#64;/ . '/ **'&amp;lt;CR&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;,*&lt;/tt&gt; 这个map比 &lt;tt class="docutils literal"&gt;F3&lt;/tt&gt; 也更好&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="smart-search-with-subvert-5-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id59"&gt;&amp;#64;47 Smart search with :Subvert (5:33)&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="supercharged-substitution-with-subvert-7-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id60"&gt;&amp;#64;48 Supercharged substitution with :Subvert (7:09)&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="enhanced-abbreviations-with-abolish-3-09"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id61"&gt;&amp;#64;49 Enhanced abbreviations with :Abolish (3:09)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;abolish插件对我应该不太有用.&lt;/p&gt;
&lt;p&gt;Abolish's killer feature is that it handles the fight between logical names &amp;amp; the English language.
在替换的时候能自动处理单复数, 大小写, 前后缀:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:%s/Notes/Entries/g
:%s/Note/Entry/g
:%s/notes/entries/g
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="an-introduction-to-vspec-7-15"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id62"&gt;#50 An introduction to vspec (7:15)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Vspec&lt;/tt&gt; is a library that allows you to test-drive your Vimscript code. In this tutorial, we’ll cover the basics: how to inspect the contents of a buffer, how to simulate the actions of a user, and how to invoke user-defined mappings.&lt;/p&gt;
&lt;p&gt;可以给vim 插件写测试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nnoremap x daw

describe 'vspec'

  before
    new
    put! = 'Welcome to Vimcasts'
  end

  after
    close!
  end

  it 'can read the contents of the buffer'                  #一个case
    Expect getline(1) == &amp;quot;Welcome to Vimcasts&amp;quot;
  end

  it 'feels just like operating Vim!'                       #一个case
    normal gg$
    normal daw
    Expect getline(1) == 'Welcome to'
    Expect getreg('&amp;quot;') == ' Vimcasts'
  end

  it 'can exercise user-defined mappings'                   #一个case
    normal gg$
    normal x
    Expect getline(1) == 'Welcome to'
    Expect getreg('&amp;quot;') == ' Vimcasts'
  end

end
&lt;/pre&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;把如上脚本转换为vimscrip (excommand)&lt;/li&gt;
&lt;li&gt;用Ex模式调用vim(不会出现gui), 并执行excommand&lt;/li&gt;
&lt;li&gt;可以用excommand &lt;tt class="docutils literal"&gt;normal d&lt;/tt&gt; 模拟normal 模式下按一下 &lt;tt class="docutils literal"&gt;d&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;非常赞&lt;/strong&gt; .&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-operations-using-the-default-register-4-07"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id63"&gt;#51 Simple operations using the default register (4:07)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;讲ddp交换两行.&lt;/p&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="meet-the-yank-register-4-29"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id64"&gt;#52 Meet the yank register (4:29)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;已知, 比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-vim-s-named-registers-3-29"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id65"&gt;#53 Using Vim's named registers (3:29)&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;quot;ayy&lt;/tt&gt; 是把当前行放入 &lt;tt class="docutils literal"&gt;寄存器a&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;quot;Ayy&lt;/tt&gt; 是把当前行append 到 &lt;tt class="docutils literal"&gt;寄存器a&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pasting-from-visual-mode-3-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id66"&gt;#54 Pasting from Visual mode (3:33)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pasting-from-insert-mode-4-15"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id67"&gt;#55 Pasting from Insert mode (4:15)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;insert下/命令模式下, 按 &lt;tt class="docutils literal"&gt;crtl+r 0&lt;/tt&gt;, 粘贴0号寄存器.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-calculations-with-vim-s-expression-register-4-02"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id68"&gt;#56 Simple calculations with Vim's expression register (4:02)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;表达式寄存器: &lt;tt class="docutils literal"&gt;&amp;quot;=&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt; : 编辑模式下: &lt;tt class="docutils literal"&gt;ctrl+r =&lt;/tt&gt; 输入 &lt;tt class="docutils literal"&gt;3*5&lt;/tt&gt; , 插入结果&lt;/p&gt;
&lt;p&gt;用下面这个map:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nnoremap Q 0yt=A&amp;lt;C-r&amp;gt;=&amp;lt;C-r&amp;gt;&amp;quot;&amp;lt;CR&amp;gt;&amp;lt;Esc&amp;gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
3*2 =
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="evaluating-scripts-with-vim-s-expression-register-3-56"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id69"&gt;#57 Evaluating scripts with Vim's expression register (3:56)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;system()&lt;/tt&gt; 函数&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;quot;=&lt;/tt&gt; 下可以用 abs(), round(), system()之类函数&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:help function-list
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
:put = 3+3
:put =system('echo $RANDOM')
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="accessing-the-system-clipboard-from-vim-4-48"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id70"&gt;#58 Accessing the system clipboard from Vim (4:48)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;+y
粘贴, 不需要设置set paste:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;+gp
:put +
&lt;/pre&gt;
&lt;p&gt;If you’d like to make it easier to interact with the system clipboard, try out this setting,&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:set clipboard=unnamed,unnamedplus
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;有用&lt;/strong&gt;, 但是会破坏我在 &lt;tt class="docutils literal"&gt;rst_bold_it&lt;/tt&gt; 的ctrl+c, ctrl+b, 因为这里我用了默认寄存器 &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt; , 我换成命名寄存器 &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 就好了&lt;/p&gt;
&lt;p&gt;上面这个行为想当于 在d, x, y, p 命令前都加了&amp;quot;*&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-vim-s-paste-mode-with-the-system-paste-command-4-25"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id71"&gt;#59 Using Vim's paste mode with the system paste command (4:25)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;set paste 之后 ， imap都失效了.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;unimpaired&lt;/tt&gt; 这个插件, 可以在我想要粘贴的时候, 按 &lt;tt class="docutils literal"&gt;yo&lt;/tt&gt; , 此时会自动 &lt;tt class="docutils literal"&gt;set paste&lt;/tt&gt; 贴完之后, 会自动 &lt;tt class="docutils literal"&gt;set nopaste&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;-对我基本没用&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="comparing-buffers-with-vimdiff-4-16"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id72"&gt;#60 Comparing buffers with vimdiff (4:16)&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
:windo diffthis 比较两个win.
:windo diffoff
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-repeatable-mappings-with-repeat-vim-4-33"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id73"&gt;#61 Creating repeatable mappings with repeat.vim (4:33)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基本没用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id74"&gt;关于&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;作者:&lt;a class="reference external" href="https://github.com/nelstrom/"&gt;https://github.com/nelstrom/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ning-vim-modline"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id75"&gt;ning: vim modline&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比如写在文件头:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;vim: foldmethod=marker
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id76"&gt;总结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前30个非常好, 后面知识较少.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>增大tcp init_cwnd</title><link href="/tcp_ip_increasing_init_cwnd.html" rel="alternate"></link><updated>2012-12-14T10:32:15+08:00</updated><author><name>ning</name></author><id>tag:,2012-12-14:tcp_ip_increasing_init_cwnd.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#an-argument-for-increasing-tcps-initial-congestion-window" id="id7"&gt;An Argument for Increasing TCP’s Initial Congestion Window&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id8"&gt;理论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id9"&gt;效果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id10"&gt;其它方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id11"&gt;负面影响&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#initcwnd-settings-of-major-cdn-providers" id="id12"&gt;Initcwnd settings of major CDN providers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tuning-initcwnd-for-optimum-performance" id="id13"&gt;Tuning initcwnd for optimum performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#zetatcp" id="id14"&gt;zetaTCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id15"&gt;工具&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#init-cwnd" id="id16"&gt;修改init_cwnd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#initcwnd-check" id="id17"&gt;initcwnd_check&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case" id="id18"&gt;case&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case-win" id="id19"&gt;case win&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case-tso" id="id20"&gt;case tso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id21"&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="an-argument-for-increasing-tcps-initial-congestion-window"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;An Argument for Increasing TCP’s Initial Congestion Window&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://code.google.com/speed/articles/tcp_initcwnd_paper.pdf"&gt;http://code.google.com/speed/articles/tcp_initcwnd_paper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;init_cwnd=10 =&amp;gt; 提升10%&lt;/p&gt;
&lt;p&gt;慢启动阶段, 拥塞窗口一直增加, 直到丢包, 丢包通常是由于 路由器buffer overflow&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;平均网页大小384KB.&lt;/li&gt;
&lt;li&gt;大多数连接，都是短连接.&lt;/li&gt;
&lt;li&gt;使用iptables 命令可以修改init_cwnd.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;理论&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;90%的网页在 网页 在16KB 以内.
所以改为10, 90%的网页都可以在一个RTT内发出&lt;/li&gt;
&lt;li&gt;init_cwnd 比较大, 如果拥塞, 能够尽快的快速重传, 而不是等待超时.
一下发送10个包, 如果丢了5个, 发送方很可能收到dup ack, 所以出发 Fast Restransmit.&lt;/li&gt;
&lt;/ol&gt;
&lt;img alt="" src="/imgs/google_init_cwnd1.png" /&gt;
&lt;p&gt;注意 除了init_cwnd 之外, client 的通告窗口(rwnd)如果太小, 也不能一下发送很多包,&lt;/p&gt;
&lt;img alt="" src="/imgs/google_init_cwnd_rwnd.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;效果&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;提升8%-16%&lt;/p&gt;
&lt;img alt="" src="/imgs/google_init_cwnd_improve.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;其它方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;cached cwnd. (可能是记录每个client ip 的最佳cwnd)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;负面影响&lt;/a&gt;&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;重传增加 (增加很少)&lt;/li&gt;
&lt;li&gt;浏览器本身会并发访问, 通常并发是3-6.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="initcwnd-settings-of-major-cdn-providers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;Initcwnd settings of major CDN providers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.cdnplanet.com/blog/initcwnd-settings-major-cdn-providers/"&gt;http://www.cdnplanet.com/blog/initcwnd-settings-major-cdn-providers/&lt;/a&gt;&lt;/p&gt;
&lt;img alt="" src="/imgs/initcwnd-cdns-may2012_12.png" /&gt;
&lt;p&gt;多数cdn 厂商的cwnd 都调高了.&lt;/p&gt;
&lt;p&gt;测试脚本: &lt;a class="reference external" href="http://www.cdnplanet.com/static/uploads/probe.py"&gt;http://www.cdnplanet.com/static/uploads/probe.py&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tuning-initcwnd-for-optimum-performance"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;Tuning initcwnd for optimum performance&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/"&gt;http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图不错:&lt;/p&gt;
&lt;img alt="" src="/imgs/init_cwnd_TCP1.png" /&gt;
&lt;img alt="" src="/imgs/init_cwnd_TCP2.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="zetatcp"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;zetaTCP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于小公司, 网页下载, 不需要这种技术, 直接调大init_cwnd 就行.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;工具&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="init-cwnd"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;修改init_cwnd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Step 1: check route settings.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sajal&amp;#64;sajal-desktop:~$ ip route show
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.100  metric 1
169.254.0.0/16 dev eth0  scope link  metric 1000
default via 192.168.1.1 dev eth0  proto static
sajal&amp;#64;sajal-desktop:~$
Make a note of the line starting with default.
&lt;/pre&gt;
&lt;p&gt;Step 2: Change the default settings:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Paste the current settings for default and add initcwnd 10 to it.

sajal&amp;#64;sajal-desktop:~$ sudo ip route change default via 192.168.1.1 dev eth0  proto static initcwnd 10
&lt;/pre&gt;
&lt;p&gt;Step 3: Verify:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sajal&amp;#64;sajal-desktop:~$ ip route show
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.100  metric 1
169.254.0.0/16 dev eth0  scope link  metric 1000
default via 192.168.1.1 dev eth0  proto static  initcwnd 10
&lt;/pre&gt;
&lt;p&gt;我试试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# ip route show
10.26.140.0/24 dev eth1  proto kernel  scope link  src 10.26.140.32
169.254.0.0/16 dev eth1  scope link  metric 1003
192.168.0.0/16 via 10.26.140.1 dev eth1
172.16.0.0/12 via 10.26.140.1 dev eth1  initcwnd 10
10.0.0.0/8 via 10.26.140.1 dev eth1

# ip route change 172.16.0.0/12 via 10.26.140.1 dev eth1 initcwnd 20

# ip route show
10.26.140.0/24 dev eth1  proto kernel  scope link  src 10.26.140.32
169.254.0.0/16 dev eth1  scope link  metric 1003
192.168.0.0/16 via 10.26.140.1 dev eth1
172.16.0.0/12 via 10.26.140.1 dev eth1  initcwnd 20
10.0.0.0/8 via 10.26.140.1 dev eth1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="initcwnd-check"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;initcwnd_check&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;需要apt-get 安装&lt;/p&gt;
&lt;pre class="literal-block"&gt;
libnetpacket-perl, libnet-pcap-perl, libnet-rawip-perl
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
(ENV)ning&amp;#64;ning-laptop ~/test/initcwnd_check$ sudo ./initcwnd_check.pl wlan0 http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js
+ connected from 172.22.146.48:6031 to 74.125.31.95:80
* ajax.googleapis.com (74.125.31.95) - init_cwnd: 10 (13800 byte), init_rwnd: 10 (14300 byte)

(ENV)ning&amp;#64;ning-laptop ~/test/initcwnd_check$ sudo ./initcwnd_check.pl wlan0 http://10.26.140.32:8080/500K.data
+ connected from 172.22.146.48:4648 to 10.26.140.32:8080
* 10.26.140.32 (10.26.140.32) - init_cwnd: 10 (14280 byte), init_rwnd: 10 (14600 byte)

(ENV)ning&amp;#64;ning-laptop ~/test/initcwnd_check$ sudo ./initcwnd_check.pl wlan0 http://10.26.138.25:8080/500K.data
+ connected from 172.22.146.48:6988 to 10.26.138.25:8080
* 10.26.138.25 (10.26.138.25) - init_cwnd: 44 (62832 byte), init_rwnd: 44 (63443 byte)                                                  //44.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="case"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;case&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="case-win"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;case win&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;虽然调大了，但是下面这个case 的还是只能发送4个, 因为接收放说win 5840:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(ENV)ning&amp;#64;ning-laptop ~/test/initcwnd_check$ sudo tcpdump -i wlan0 -nn 'host 123.125.115.254'
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlan0, link-type EN10MB (Ethernet), capture size 96 bytes

19:36:42.621338 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [S], seq 2478746345, win 5840, options [mss 1460,sackOK,TS val 19574584 ecr 0,nop,wscale 7], length 0
19:36:42.638841 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [S.], seq 3088442681, ack 2478746346, win 5840, options [mss 1380,sackOK,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop], length 0
19:36:42.638883 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 1, win 5840, length 0
19:36:42.639081 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [P.], seq 1:122, ack 1, win 5840, length 121
19:36:42.642216 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], ack 122, win 14600, length 0
19:36:42.642969 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 1:1025, ack 122, win 14600, length 1024
19:36:42.642999 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 1025, win 7168, length 0
19:36:42.644692 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 1025:2049, ack 122, win 14600, length 1024
19:36:42.644720 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 2049, win 9216, length 0
19:36:42.645531 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 2049:3073, ack 122, win 14600, length 1024
19:36:42.645548 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 3073, win 11264, length 0
19:36:42.648202 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [P.], seq 3073:4097, ack 122, win 14600, length 1024
19:36:42.648229 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 4097, win 13312, length 0

19:36:42.654387 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 4097:5121, ack 122, win 14600, length 1024
19:36:42.654416 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 5121, win 15360, length 0
19:36:42.659431 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 5121:6145, ack 122, win 14600, length 1024
19:36:42.659455 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 6145, win 17408, length 0
19:36:42.660544 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [P.], seq 6145:7169, ack 122, win 14600, length 1024
19:36:42.660558 IP 172.22.146.48.41102 &amp;gt; 123.125.115.254.80: Flags [.], ack 7169, win 19456, length 0
19:36:42.677194 IP 123.125.115.254.80 &amp;gt; 172.22.146.48.41102: Flags [.], seq 7169:8193, ack 122, win 14600, length 1024
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="case-tso"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;case tso&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们在使用 x工具 之后, 关闭它之后. 用上面的initcwnd_check 工具查看，发现init_cwnd变成了6，很奇怪:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(ENV)ning&amp;#64;ning-laptop ~/test/initcwnd_check$ sudo ./initcwnd_check.pl wlan0 http://10.26.138.25:8080/50K.data
+ connected from 172.22.146.48:3832 to 10.26.138.25:8080
* 10.26.138.25 (10.26.138.25) - init_cwnd: 6 (8568 byte), init_rwnd: 10 (14600 byte)
&lt;/pre&gt;
&lt;p&gt;抓包看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# tcpdump -nn 'host 172.22.146.48'
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 65535 bytes

17:28:32.410069 IP 172.22.146.48.2608 &amp;gt; 10.26.138.25.8080: Flags [S], seq 2380923257:2380923262, win 65535, options [mss 1460], length 5
17:28:32.410108 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [S.], seq 1345408678, ack 2380923258, win 14600, options [mss 1460], length 0
17:28:32.411585 IP 172.22.146.48.2608 &amp;gt; 10.26.138.25.8080: Flags [.], ack 1, win 65535, options [mss 1460], length 0
17:28:32.412577 IP 172.22.146.48.2608 &amp;gt; 10.26.138.25.8080: Flags [P.], seq 1:218, ack 1, win 65535, options [mss 1460], length 217
17:28:32.412611 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], ack 218, win 15544, length 0
17:28:32.412969 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 1:1461, ack 218, win 15544, length 1460
17:28:32.412983 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 1461:2921, ack 218, win 15544, length 1460
17:28:32.412991 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 2921:4381, ack 218, win 15544, length 1460
17:28:32.412999 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 4381:5841, ack 218, win 15544, length 1460
17:28:32.413005 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 5841:7301, ack 218, win 15544, length 1460
17:28:32.413012 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 7301:8761, ack 218, win 15544, length 1460
17:28:32.614498 IP 10.26.138.25.8080 &amp;gt; 172.22.146.48.2608: Flags [.], seq 1:1461, ack 218, win 15544, length 1460
17:28:32.622373 IP 172.22.146.48.2608 &amp;gt; 10.26.138.25.8080: Flags [R], seq 2380923475, win 65535, options [mss 1460], length 0
&lt;/pre&gt;
&lt;p&gt;和一台正常机器对比:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# tcpdump -nn 'host 172.22.146.48'
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 65535 bytes
17:28:30.780922 IP 172.22.146.48.1634 &amp;gt; 10.26.140.32.8080: Flags [S], seq 1797559918:1797559923, win 65535, options [mss 1460], length 5
17:28:30.780961 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [S.], seq 1660446299, ack 1797559919, win 14600, options [mss 1460], length 0
17:28:30.782374 IP 172.22.146.48.1634 &amp;gt; 10.26.140.32.8080: Flags [.], ack 1, win 65535, options [mss 1460], length 0
17:28:30.783062 IP 172.22.146.48.1634 &amp;gt; 10.26.140.32.8080: Flags [P.], seq 1:219, ack 1, win 65535, options [mss 1460], length 218
17:28:30.783096 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], ack 219, win 15544, length 0
17:28:30.783548 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], seq 1:2921, ack 219, win 15544, length 2920
17:28:30.783567 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], seq 2921:7301, ack 219, win 15544, length 4380
17:28:30.783576 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], seq 7301:11681, ack 219, win 15544, length 4380
17:28:30.783589 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], seq 11681:14601, ack 219, win 15544, length 2920
17:28:30.985323 IP 10.26.140.32.8080 &amp;gt; 172.22.146.48.1634: Flags [.], seq 1:1461, ack 219, win 15544, length 1460
17:28:30.991513 IP 172.22.146.48.1634 &amp;gt; 10.26.140.32.8080: Flags [R], seq 1797560137, win 65535, options [mss 1460], length 0
&lt;/pre&gt;
&lt;p&gt;同样是发了6个包. 客户端认为一个是6, 一个是10.  正常机器有大包, 怀疑是tso, 果然是两台机器tso 都开启:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# sudo ethtool -k eth0
Offload parameters for eth0:
rx-checksumming: on
tx-checksumming: on
scatter-gather: on
tcp-segmentation-offload: on            *****
udp-fragmentation-offload: off
generic-segmentation-offload: on
generic-receive-offload: on
large-receive-offload: off
&lt;/pre&gt;
&lt;p&gt;怀疑是x工具把tso 状态搞坏了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;参考&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/"&gt;http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>tcp cwnd 作用</title><link href="/tcpip-cwnd.html" rel="alternate"></link><updated>2012-10-14T21:45:47+08:00</updated><author><name>ning</name></author><id>tag:,2012-10-14:tcpip-cwnd.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cwnd" id="id9"&gt;关于cwnd 默认参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#s" id="id10"&gt;3s 延迟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id11"&gt;5s 延迟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bdp" id="id12"&gt;高BDP(带宽时延积)网络&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id13"&gt;带宽时延积&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rtt" id="id14"&gt;高rtt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#rttbdp" id="id15"&gt;高rtt情况根据BDP计算带宽:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case" id="id16"&gt;case&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case1" id="id17"&gt;case1 - 短连接&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id18"&gt;case1 分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id19"&gt;case1 注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#case2" id="id20"&gt;case2 - 长连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#xxxxxxxxxxxxxxx" id="id21"&gt;xxxxxxxxxxxxxxx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id22"&gt;方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id23"&gt;增加发送方初始cwnd(对短连接有效)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id24"&gt;使用长连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id25"&gt;增加接收方接收窗口.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vegas" id="id26"&gt;修改vegas 算法参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#reference" id="id27"&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cwnd"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;关于cwnd 默认参数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;初始cwnd 为2:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-source/kernel/linux-2.6.6/net/ipv4$ ack cwnd
tcp_ipv4.c
2071:   tp-&amp;gt;snd_cwnd = 2;
&lt;/pre&gt;
&lt;p&gt;初始rto 为3s, 所以我们经常看见3s延迟  /home/ning/idning-source/kernel/linux-3.6.2/Documentation/networking/ip-sysctl.txt:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rto_initial - INTEGER
    The initial round trip timeout value in milliseconds that will be used
    in calculating round trip times.  This is the initial time interval
    for retransmissions.

    Default: 3000

#define TCP_TIMEOUT_INIT ((unsigned)(3*HZ)) /* RFC 1122 initial RTO value   */

rto_max - INTEGER
    The maximum value (in milliseconds) of the round trip timeout.  This
    is the largest time interval that can elapse between retransmissions.

    Default: 60000

rto_min - INTEGER
    The minimum value (in milliseconds) of the round trip timeout.  This
    is the smallest time interval the can elapse between retransmissions.

    Default: 1000
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="s"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;3s 延迟&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;看代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#重传时x2
icsk-&amp;gt;icsk_rto = min(icsk-&amp;gt;icsk_rto &amp;lt;&amp;lt; 1, TCP_RTO_MAX);

/* Calculate rto without backoff.  This is the second half of Van Jacobson's
 * routine referred to above.
 */
static inline void tcp_set_rto(struct sock *sk)
{
    const struct tcp_sock *tp = tcp_sk(sk);
    /* Old crap is replaced with new one. 8)
     *
     * More seriously:
     * 1. If rtt variance happened to be less 50msec, it is hallucination.
     *    It cannot be less due to utterly erratic ACK generation made
     *    at least by solaris and freebsd. &amp;quot;Erratic ACKs&amp;quot; has _nothing_
     *    to do with delayed acks, because at cwnd&amp;gt;2 true delack timeout
     *    is invisible. Actually, Linux-2.4 also generates erratic
     *    ACKs in some circumstances.
     */
    inet_csk(sk)-&amp;gt;icsk_rto = __tcp_set_rto(tp);

    /* 2. Fixups made earlier cannot be right.
     *    If we do not estimate RTO correctly without them,
     *    all the algo is pure shit and should be replaced
     *    with correct one. It is exactly, which we pretend to do.
     */

    /* NOTE: clamping at TCP_RTO_MIN is not required, current algo
     * guarantees that rto is higher.
     */
    tcp_bound_rto(sk);
}
&lt;/pre&gt;
&lt;p&gt;计算当前rto:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline u32 __tcp_set_rto(const struct tcp_sock *tp)
{
    return (tp-&amp;gt;srtt &amp;gt;&amp;gt; 3) + tp-&amp;gt;rttvar;
}
&lt;/pre&gt;
&lt;p&gt;下面这里调用了tcp_set_rto:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static void tcp_valid_rtt_meas(struct sock *sk, u32 seq_rtt)
{
    tcp_rtt_estimator(sk, seq_rtt);
    tcp_set_rto(sk);
    inet_csk(sk)-&amp;gt;icsk_backoff = 0;
}

/* Read draft-ietf-tcplw-high-performance before mucking
 * with this code. (Supersedes RFC1323)
 */
static void tcp_ack_saw_tstamp(struct sock *sk, int flag)
{
    /* RTTM Rule: A TSecr value received in a segment is used to
     * update the averaged RTT measurement only if the segment
     * acknowledges some new data, i.e., only if it advances the
     * left edge of the send window.
     *
     * See draft-ietf-tcplw-high-performance-00, section 3.3.
     * 1998/04/10 Andrey V. Savochkin &amp;lt;saw&amp;#64;msu.ru&amp;gt;
     *
     * Changed: reset backoff as soon as we see the first valid sample.
     * If we do not, we get strongly overestimated rto. With timestamps
     * samples are accepted even from very old segments: f.e., when rtt=1
     * increases to 8, we retransmit 5 times and after 8 seconds delayed
     * answer arrives rto becomes 120 seconds! If at least one of segments
     * in window is lost... Voila.                          --ANK (010210)
     */
    struct tcp_sock *tp = tcp_sk(sk);

    tcp_valid_rtt_meas(sk, tcp_time_stamp - tp-&amp;gt;rx_opt.rcv_tsecr);
}
&lt;/pre&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* RTTM Rule: A TSecr value received in a segment is used to
 * update the averaged RTT measurement only if the segment
 * acknowledges some new data, i.e., only if it advances the
 * left edge of the send window.
&lt;/pre&gt;
&lt;p&gt;这就是说:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
A =SYN=&amp;gt; B
B =SYN=&amp;gt; A
A =PSH=&amp;gt; B
B =ack=&amp;gt; A
A =PSH=&amp;gt; B
B =ack=&amp;gt; A

这时候B第一次向A发数据, 如果这个包丢了, 此时的rtt也是3s::
B =PSH=&amp;gt; A
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;5s 延迟&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Do the 5-second pauses correspond with Zero Window announcements from the client?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bdp"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;高BDP(带宽时延积)网络&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id13"&gt;带宽时延积&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Bandwidth Delay Product（BDP）即带宽 x RTT&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rtt"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id14"&gt;高rtt&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常，同机房内ping 命令输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ping 10.65.19.52
PING 10.65.19.52 (10.65.19.52) 56(84) bytes of data.
64 bytes from 10.65.19.52: icmp_seq=0 ttl=59 time=0.766 ms
64 bytes from 10.65.19.52: icmp_seq=1 ttl=59 time=0.746 ms
64 bytes from 10.65.19.52: icmp_seq=2 ttl=59 time=0.884 ms
64 bytes from 10.65.19.52: icmp_seq=3 ttl=59 time=0.747 ms
&lt;/pre&gt;
&lt;p&gt;跨机房:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ping 10.220.109.45
PING 10.220.109.45 (10.220.109.45) 56(84) bytes of data.
64 bytes from 10.220.109.45: icmp_seq=0 ttl=58 time=28.8 ms
64 bytes from 10.220.109.45: icmp_seq=1 ttl=58 time=28.7 ms
64 bytes from 10.220.109.45: icmp_seq=2 ttl=58 time=28.6 ms
64 bytes from 10.220.109.45: icmp_seq=3 ttl=58 time=28.6 ms
&lt;/pre&gt;
&lt;p&gt;跨机房场景，就是典型的高延迟.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rttbdp"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;高rtt情况根据BDP计算带宽:&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;公式1:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
BDP = link_bandwidth * RTT
&lt;/pre&gt;
&lt;p&gt;tcp window_size 大小应该设置为BDP 或2 x BDP.  假设window_size = BDP, 则得到公式2:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
throughput = window_size / RTT
&lt;/pre&gt;
&lt;p&gt;对于上面case来说, 千兆网络, 带宽为125MB/s&lt;/p&gt;
&lt;pre class="literal-block"&gt;
BDP = 1000Mbps * 0.030 sec / 8 = 3.7MB (所以应该设置为3.7MB左右)

Linux 2.6 上默认的 TCP 窗口大小是 110KB, 根据公式1, 得到 throughput = window_size/RTT = 110KB/0.03 = 3.6MB.
如果设置为3.7MB                          根据公式1, 得到 throughput = window_size/RTT = 3.7MB/0.03 = 125MB.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="case"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;case&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="case1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;case1 - 短连接&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;短连接是指，传输数据量较小
很多时候slow start还没有结束, 连接就关闭了.&lt;/p&gt;
&lt;p&gt;在10.220.109.45.8080开启一个webserver, 从10.36.115.52下载一个256K的文件.&lt;/p&gt;
&lt;p&gt;发送方 10.220.109.45.8080   (被动打开)
接收放 10.36.115.52         (主动打开)&lt;/p&gt;
&lt;p&gt;发送方抓包(被动打开, 第一个包是接收到的syn):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
11:12:08.045299 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: S 2126508121:2126508121(0) win 5840 &amp;lt;mss 1460,sackOK,timestamp 1890669490 0,nop,wscale 7&amp;gt;
11:12:08.045376 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: S 2227406332:2227406332(0) ack 2126508122 win 5792 &amp;lt;mss 1460,sackOK,timestamp 1396920409 1890669490,nop,wscale 7&amp;gt;
11:12:08.074157 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 1 win 46 &amp;lt;nop,nop,timestamp 1890669518 1396920409&amp;gt;
11:12:08.074233 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: P 1:213(212) ack 1 win 46 &amp;lt;nop,nop,timestamp 1890669518 1396920409&amp;gt;             : 客户端发来请求GET xxx
11:12:08.074239 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920438 1890669518&amp;gt;                      : server表示收到请求
11:12:08.074647 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 1:1449(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;
11:12:08.074652 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 1449:2897(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;
11:12:08.074655 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 2897:4345(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;      : 连发3个包, 因为init_cwnd=3, 此时等待

11:12:08.103542 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 1449 win 69 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;                     : 等到了1个ack , cwnd+=1 =&amp;gt; 4
11:12:08.103548 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 4345:5793(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.103550 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 5793:7241(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.103591 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 2897 win 91 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;                     : 等到了1个ack , cwnd+=1 =&amp;gt; 5
11:12:08.103595 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 7241:8689(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.103598 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 8689:10137(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.103639 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 4345 win 114 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 6
11:12:08.103643 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 10137:11585(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.103645 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 11585:13033(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;     : 连发6个包

11:12:08.132462 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 5793 win 137 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 7
11:12:08.132467 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 13033:14481(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132469 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 14481:15929(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132558 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 7241 win 159 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 8
11:12:08.132563 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 15929:17377(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132565 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 17377:18825(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132654 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 8689 win 182 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 9
11:12:08.132658 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 18825:20273(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132661 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 20273:21721(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132663 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 10137 win 204 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 10
11:12:08.132666 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 21721:23169(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132668 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 23169:24617(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132670 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 11585 win 227 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 11
11:12:08.132673 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 24617:26065(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132675 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 26065:27513(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132678 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 13033 win 250 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;                    : 等到了1个ack , cwnd+=1 =&amp;gt; 12
11:12:08.132680 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 27513:28961(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.132683 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 28961:30409(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;     : 2ms内 连发12个包

11:12:08.161358 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 14481 win 272 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161362 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 30409:31857(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920525 1890669606&amp;gt;
11:12:08.161365 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 31857:33305(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920525 1890669606&amp;gt;
11:12:08.161406 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 15929 win 295 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161409 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 33305:34753(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161412 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 34753:36201(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161502 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 17377 win 318 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161506 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 36201:37649(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161509 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 37649:39097(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161511 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 18825 win 340 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161514 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 39097:40545(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161516 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 40545:41993(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161597 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 20273 win 363 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161602 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 41993:43441(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161604 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 43441:44889(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161606 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 21721 win 385 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161609 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 44889:46337(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161611 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 46337:47785(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161693 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 23169 win 408 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161697 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 47785:49233(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161700 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 49233:50681(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161702 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 24617 win 431 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161705 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 50681:52129(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161708 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 52129:53577(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161710 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 26065 win 453 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161713 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 53577:55025(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161715 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 55025:56473(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161717 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 27513 win 476 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161720 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 56473:57921(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161722 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 57921:59369(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161725 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 28961 win 499 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161727 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 59369:60817(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161730 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 60817:62265(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161732 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 30409 win 521 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.161735 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 62265:63713(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.161737 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 63713:65161(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;    : 4ms内连发24个包.

11:12:08.190703 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 31857 win 544 &amp;lt;nop,nop,timestamp 1890669635 1396920525&amp;gt;
11:12:08.190708 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 65161:66609(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920555 1890669635&amp;gt;
...
&lt;/pre&gt;
&lt;p&gt;接收端抓包(主动打开, 先发syn):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
11:12:08.060202 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: S 2126508121:2126508121(0) win 5840 &amp;lt;mss 1460,sackOK,timestamp 1890669490 0,nop,wscale 7&amp;gt;
11:12:08.089056 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: S 2227406332:2227406332(0) ack 2126508122 win 5792 &amp;lt;mss 1460,sackOK,timestamp 1396920409 1890669490,nop,wscale 7&amp;gt;
11:12:08.089069 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 1 win 46 &amp;lt;nop,nop,timestamp 1890669518 1396920409&amp;gt;
11:12:08.089133 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: P 1:213(212) ack 1 win 46 &amp;lt;nop,nop,timestamp 1890669518 1396920409&amp;gt;         : 请求发过去了

11:12:08.118014 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920438 1890669518&amp;gt;                  : 一个rtt后，收到ack
11:12:08.118448 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 1:1449(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;     : 同时收到响应.
11:12:08.118452 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 1449 win 69 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;                 : 收到一个马上就回复ack, 但是对方需要15ms以后才能收到
11:12:08.118493 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 1449:2897(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;
11:12:08.118497 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 2897 win 91 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;
11:12:08.118529 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 2897:4345(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920439 1890669518&amp;gt;  :收3个包
11:12:08.118532 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 4345 win 114 &amp;lt;nop,nop,timestamp 1890669548 1396920439&amp;gt;

11:12:08.147370 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 4345:5793(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.147378 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 5793 win 137 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;
11:12:08.147444 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 5793:7241(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.147446 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 7241 win 159 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;
11:12:08.147499 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 7241:8689(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.147516 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 8689:10137(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.147520 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 8689 win 182 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;
11:12:08.147522 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 10137 win 204 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;
11:12:08.147563 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 10137:11585(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;
11:12:08.147566 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 11585 win 227 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;
11:12:08.147569 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 11585:13033(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920468 1890669548&amp;gt;    :收6个包
11:12:08.147572 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 13033 win 250 &amp;lt;nop,nop,timestamp 1890669577 1396920468&amp;gt;

11:12:08.176267 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 13033:14481(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176274 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 14481 win 272 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176308 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 14481:15929(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176311 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 15929 win 295 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176384 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 15929:17377(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176388 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 17377 win 318 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176391 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 17377:18825(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176393 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 18825 win 340 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176460 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 18825:20273(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176463 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 20273 win 363 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176493 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 20273:21721(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176496 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 21721 win 385 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176581 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 21721:23169(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176584 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 23169 win 408 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176587 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 23169:24617(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176589 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 24617 win 431 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176592 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 24617:26065(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176595 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 26065 win 453 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176597 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 26065:27513(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176599 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 27513 win 476 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176602 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 27513:28961(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;
11:12:08.176604 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 28961 win 499 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;
11:12:08.176607 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 28961:30409(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920497 1890669577&amp;gt;    : 收12个包
11:12:08.176609 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 30409 win 521 &amp;lt;nop,nop,timestamp 1890669606 1396920497&amp;gt;

11:12:08.205168 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 30409:31857(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920525 1890669606&amp;gt;
11:12:08.205174 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 31857 win 544 &amp;lt;nop,nop,timestamp 1890669635 1396920525&amp;gt;
11:12:08.205226 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 31857:33305(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920525 1890669606&amp;gt;
11:12:08.205230 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 33305 win 566 &amp;lt;nop,nop,timestamp 1890669635 1396920525&amp;gt;
11:12:08.205248 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 33305:34753(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205250 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 34753 win 589 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205293 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 34753:36201(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205296 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 36201 win 612 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205312 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 36201:37649(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205315 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 37649 win 634 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205367 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 37649:39097(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205369 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 39097 win 657 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205372 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 39097:40545(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205374 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 40545 win 680 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205376 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 40545:41993(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205378 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 41993 win 702 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205423 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 41993:43441(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205425 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 43441 win 725 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205433 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 43441:44889(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205436 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 44889 win 747 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205481 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 44889:46337(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205484 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 46337 win 770 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205542 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 46337:47785(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205545 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 47785 win 793 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205547 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 47785:49233(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205549 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 49233 win 815 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205569 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 49233:50681(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205572 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 50681 win 838 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205574 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 50681:52129(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205576 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 52129 win 861 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205579 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 52129:53577(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205581 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 53577 win 883 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205616 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 53577:55025(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205618 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 55025 win 906 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205661 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 55025:56473(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205664 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 56473 win 928 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205667 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 56473:57921(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205669 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 57921 win 951 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205671 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 57921:59369(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205674 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 59369 win 974 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205676 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 59369:60817(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205678 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 60817 win 996 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205680 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 60817:62265(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205683 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 62265 win 1019 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205685 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 62265:63713(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;
11:12:08.205687 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 63713 win 1042 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;
11:12:08.205723 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 63713:65161(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920526 1890669606&amp;gt;    : 收24个包
11:12:08.205725 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 65161 win 1064 &amp;lt;nop,nop,timestamp 1890669635 1396920526&amp;gt;

11:12:08.234511 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 65161:66609(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920555 1890669635&amp;gt;
11:12:08.234517 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 66609 win 1087 &amp;lt;nop,nop,timestamp 1890669664 1396920555&amp;gt;
11:12:08.234552 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: . 66609:68057(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920555 1890669635&amp;gt;
11:12:08.234554 IP 10.36.115.52.55281 &amp;gt; 10.220.109.45.8080: . ack 68057 win 1109 &amp;lt;nop,nop,timestamp 1890669664 1396920555&amp;gt;
11:12:08.234619 IP 10.220.109.45.8080 &amp;gt; 10.36.115.52.55281: P 68057:69505(1448) ack 213 win 54 &amp;lt;nop,nop,timestamp 1396920555 1890669635&amp;gt;
&lt;/pre&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;case1 分析&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;平均1ms内发包6个, 假设拥塞窗口不受限的话, 30ms 可以发送:red:&lt;cite&gt;6*30=180个包&lt;/cite&gt;, 相当于`1448*180=260640(约260K)`&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id19"&gt;case1 注意&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;上面tcpdump输出中的win 都是54左右, 实际上这是因为wscale, 在第一个SYN包可以看见: wscale 7, 表示scale 为2^7 = 128
即54*128 = 6912&lt;/p&gt;
&lt;img alt="" src="/imgs/5M.pcap-win.png" /&gt;
&lt;p&gt;我们发现图中的win值刚开始是5888,后面逐渐增大.&lt;/p&gt;
&lt;p&gt;问题1: 这个win初始值和 tcp_rmem大小有啥关系?, 我们设的rmem默认值为2.5M.(程序可以通过setsockopt(SO_RCVBUF修改), 但是目前看curl 没有该设置)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat /proc/sys/net/ipv4/tcp_rmem
4096    2500000 5000000
&lt;/pre&gt;
&lt;p&gt;问题1.1  /proc/sys/net/ipv4/tcp_rmem /proc/sys/net/core/rmem_default 有啥关系?&lt;/p&gt;
&lt;p&gt;看到说该值覆盖 net.core.rmem_default:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tcp_rmem - vector of 3 INTEGERs: min, default, max
    min: Minimal size of receive buffer used by TCP sockets.
    It is guaranteed to each TCP socket, even under moderate memory
    pressure.
    Default: 1 page

    default: initial size of receive buffer used by TCP sockets.
    This value overrides net.core.rmem_default used by other protocols.
    Default: 87380 bytes. This value results in window of 65535 with
    default setting of tcp_adv_win_scale and tcp_app_win:0 and a bit
    less for default tcp_app_win. See below about these variables.
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop ~/idning-source/kernel/linux-2.6.9/net/ipv4$ ack tcp_rmem
tcp_ipv4.c
2086:   sk-&amp;gt;sk_rcvbuf = sysctl_tcp_rmem[1];
2621:   .sysctl_rmem        = sysctl_tcp_rmem,

tcp.c
281:int sysctl_tcp_rmem[3] = { 4 * 1024, 87380, 87380 * 2 };
284:EXPORT_SYMBOL(sysctl_tcp_rmem);
2296:       sysctl_tcp_rmem[0] = PAGE_SIZE;
2297:       sysctl_tcp_rmem[1] = 43689;
2298:       sysctl_tcp_rmem[2] = 2 * 43689;

sysctl_net_ipv4.c
526:        .procname   = &amp;quot;tcp_rmem&amp;quot;,
527:        .data       = &amp;amp;sysctl_tcp_rmem,
528:        .maxlen     = sizeof(sysctl_tcp_rmem),
&lt;/pre&gt;
&lt;p&gt;问题2: 为什么它有逐渐增加的趋势.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="case2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;case2 - 长连接&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们发现256K 的时候, 平均速度远小于传输大文件的 平均速度:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ time wget  'http://10.220.109.45:8080/30M.data'
real    0m1.228s
user    0m0.008s
sys     0m0.093s
                speed = 30M/1.228 = 24MB/s

$ time wget  'http://10.220.109.45:8080/256K.data'
real    0m0.208s
user    0m0.001s
sys     0m0.004s
                speed= 256K/0.2 = 1.28MB/s
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="xxxxxxxxxxxxxxx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;xxxxxxxxxxxxxxx&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;短连接:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
时间  发送方              接收方
00ms  发送syn
15ms                      收到syn, 发回syn
30ms  收到syn 发请求:
45ms                      收到请求，发回数据 (初始3个包)
60ms  收到3个包
90ms  收到6个包
120ms 收到12个包
150ms 收到24个包
180ms 收到48个包
210ms 收到89个包

182个包收完.
&lt;/pre&gt;
&lt;p&gt;长连接:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
时间  发送方              接收方
00ms  收到syn 发请求:
15ms                      收到请求，发回数据 (初始假设为96个包)
30ms  收到96个包
60ms  收到96个包

接收完成.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;方法&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;增加发送方初始cwnd(对短连接有效)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当cwnd 慢启动满了以后，速度又会稳定在某个值.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;使用长连接&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
(要注意如果发生超时重传，就进入慢启动了 ) (只有发生超时重传才会进入慢启动，连接上长时间没有传送数据也会重新开始慢启动)&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;增加接收方接收窗口.&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="vegas"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;修改vegas 算法参数&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
/proc/sys/net/ipv4/tcp_vegas_alpha
/proc/sys/net/ipv4/tcp_vegas_beta
/proc/sys/net/ipv4/tcp_vegas_cong_avoid
/proc/sys/net/ipv4/tcp_vegas_gamma&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id27"&gt;Reference&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;soso 的一个&amp;lt;&amp;lt;linux tcp 优化案例详解&amp;gt;&amp;gt; &lt;a class="reference external" href="http://wenku.Baidu.com/view/f587d2e90975f46527d3e11d"&gt;http://wenku.Baidu.com/view/f587d2e90975f46527d3e11d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[PDF] GSS：针对高带宽时延积网络的温和慢启动方法&lt;/li&gt;
&lt;li&gt;google 的一个论文，论证对于http 来说，平均页面大小通常是300K , cwnd初始值最好定为10, (第一次发送 15K) &lt;a class="reference external" href="http://code.google.com/speed/articles/tcp_initcwnd_paper.pdf"&gt;http://code.google.com/speed/articles/tcp_initcwnd_paper.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry><entry><title>gcc/gdb/gprof/gcov/valgrind使用</title><link href="/gcc_gdb_gprof_gcov_valgrind.html" rel="alternate"></link><updated>2012-10-05T23:44:06+08:00</updated><author><name>ning</name></author><id>tag:,2012-10-05:gcc_gdb_gprof_gcov_valgrind.html</id><summary type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title first"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gcc" id="id20"&gt;gcc编译带符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gdb" id="id21"&gt;gdb 启动参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id22"&gt;gdb 查看结构体，格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#some-ppt-for-gdb" id="id23"&gt;some ppt for gdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#core-dump" id="id24"&gt;core dump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id25"&gt;gdb 基本使用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id26"&gt;修改代码查找路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#run" id="id27"&gt;run&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#continue" id="id28"&gt;continue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bt" id="id29"&gt;bt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#list" id="id30"&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#break" id="id31"&gt;break&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#watch" id="id32"&gt;watch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#info" id="id33"&gt;info&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#info-locals" id="id34"&gt;info locals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#next-over" id="id35"&gt;next&amp;lt;over&amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#step-into" id="id36"&gt;step &amp;lt;into&amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#print" id="id37"&gt;print&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#x" id="id38"&gt;x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#set" id="id39"&gt;set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#call" id="id40"&gt;call&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#watch-rwatch" id="id41"&gt;watch &amp;amp; rwatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nexti-and-stepi" id="id42"&gt;nexti and stepi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#disassemble" id="id43"&gt;disassemble&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#trace-stack-control" id="id44"&gt;trace stack control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gdb-tui" id="id45"&gt;gdb TUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#cgdb" id="id46"&gt;cgdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vimgdb" id="id47"&gt;vimgdb ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#xxgdb-gui" id="id48"&gt;xxgdb (gui)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#ddd-gui" id="id49"&gt;DDD (gui)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gdb-scripts" id="id50"&gt;gdb scripts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id51"&gt;高级使用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#load" id="id52"&gt;启动load一个脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id53"&gt;获得某个地址对应的代码::&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id54"&gt;gcc&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gcc-warn" id="id55"&gt;gcc warn 选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id56"&gt;gcc编译生成汇编：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#i-l-l" id="id57"&gt;-I, -L -l&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id58"&gt;静态链接指定的库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gcc-object" id="id59"&gt;gcc 产生 object文件（只编译）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#shared-libraries" id="id60"&gt;关于shared-libraries&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#static-library" id="id61"&gt;Static Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id62"&gt;Shared Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id63"&gt;其它&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#nm" id="id64"&gt;nm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gcov" id="id65"&gt;gcov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id66"&gt;内存泄漏&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tcmalloc-heap-profiler" id="id67"&gt;tcmalloc heap_profiler.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#valgrind" id="id68"&gt;Valgrind&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id69"&gt;Valgrind 使用举例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#profiling" id="id70"&gt;profiling&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#gprof" id="id71"&gt;gprof&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id72"&gt;gprof基本用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id73"&gt;gprof 实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id74"&gt;使用注意：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id75"&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#google-cpu-profile" id="id76"&gt;google-cpu-profile&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id17" id="id77"&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id18" id="id78"&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#tcmalloc" id="id79"&gt;和tcmalloc 是同一个工具集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id19" id="id80"&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#perf" id="id81"&gt;perf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#source-level-analysis-with-perf-annotate" id="id82"&gt;Source level analysis with perf annotate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#perf-top" id="id83"&gt;perf top&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#callgrind" id="id84"&gt;callgrind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#oprofile" id="id85"&gt;oprofile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#systemtap-root" id="id86"&gt;systemtap(root)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#vtune-root" id="id87"&gt;vtune(root)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="gcc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;gcc编译带符号&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
-g
-g2
-g3: 最多调试信息  =&amp;gt; 最好用这个.
-ggdb: gdb 特有的符号表, 无法被其它调试器使用.
&lt;/pre&gt;
&lt;p&gt;默认情况下，GCC在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用GCC 的-g或者-ggdb选项。GCC在产生调试符号时，同样采用了分级的思路，开发人员可以通过在-g选项后附加数字1、2或3来指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括扩展的符号表、行号、局部或外部变量信息。级别3（-g3）包含级别2中的所有调试信息，以及源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储之用。回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gdb"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;gdb 启动参数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这种用法会报错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gdb ./redis-cli -h 127.0.0.5 -p 22002 --replay /tmp/r/redis-22001/data/appendonly.aof
gdb: unrecognized option '--replay'
Use `gdb --help' for a complete list of options.
&lt;/pre&gt;
&lt;p&gt;可以这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gdb ./redis-cli -ex 'r -h 127.0.0.5 -p 22002 --replay /tmp/r/redis-22001/data/appendonly.aof'
&lt;/pre&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/src$ cat d.gdb
r -h 127.0.0.5 -p 22002 --replay /tmp/r/redis-22001/data/appendonly.aof

ning&amp;#64;ning-laptop:~/idning-github/redis/src$ gdb ./redis-cli -x d.gdb
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id22"&gt;gdb 查看结构体，格式&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;直接 &lt;tt class="docutils literal"&gt;p *abc&lt;/tt&gt; 的话会出来一大团东西，好处是最短的垂直空间内能显示完，坏处是层次结构不好找。&lt;/p&gt;
&lt;p&gt;在gdb里运行一下set print pretty on
再输出就是层次结构了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-ppt-for-gdb"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;some ppt for gdb&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.slideshare.net/ftt/gdb-2764286"&gt;http://www.slideshare.net/ftt/gdb-2764286&lt;/a&gt;  淺入淺出 GDB  中央资工二 张竟.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="core-dump"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;core dump&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
$ ulimit -c 1024
$ ulimit -a
core file size (blocks, -c) 1024
$ gdb --core=core.9128&lt;/blockquote&gt;
&lt;p&gt;此时用bt看不到backtrace，也就是调用堆栈，原来GDB还不知道符号信息在哪里。我们告诉它一下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) file ./a.out
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id25"&gt;gdb 基本使用&lt;/a&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
gcc -g program.c -o programname
&lt;/pre&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;修改代码查找路径&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.html"&gt;http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
dir xxx
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="run"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;run&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb) run arg1 &amp;quot;arg2&amp;quot; ...
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="continue"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;continue&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
^+c
continue
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="bt"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id29"&gt;bt&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
back trace.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="list"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id30"&gt;list&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb) list
3 int main(int argc, char **argv)
4 {
5 int x = 30;
6 int y = 10;
7
8 x = y;
9
10 return 0;
11 }

(gdb) l 17
l -200  显示当前行往前200行处的代码.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="break"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id31"&gt;break&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
break LinkedList&amp;lt;int&amp;gt;::remove
break func1
b 27x
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="watch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id32"&gt;watch&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
watch [var] 当var变动时break

rwatch [var] 当var读取时break

info watch
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="info"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id33"&gt;info&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb) disable 2
(gdb) info breakpoints
Num Type Disp Enb Address What
2 breakpoint keep n 0x080483c3 in func2 at test.c:5
3 breakpoint keep y 0x080483da in func1 at test.c:10
&lt;/pre&gt;
&lt;div class="section" id="info-locals"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id34"&gt;info locals&lt;/a&gt;&lt;/h4&gt;
&lt;pre class="literal-block"&gt;
(gdb) info locals
msg = 0x7ffff680feb0
i = 2
&lt;/pre&gt;
&lt;p&gt;没有debuginfo时, 如果是数字, 字符串, 可以试试:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
I know that you can find any parameters by looking at a positive offset from $ebp using gdb:

(gdb) x/4wx $ebp
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="next-over"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;next&amp;lt;over&amp;gt;&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb)
Node&amp;lt;int&amp;gt;::next (this=0x0) at main.cc:28
28 Node&amp;lt;T&amp;gt;* next () const { return next_; }
(gdb)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="step-into"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id36"&gt;step &amp;lt;into&amp;gt;&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb) step
53 Node&amp;lt;T&amp;gt; *temp = 0; // temp points to one behind as we iterate
(gdb)
&lt;/pre&gt;
&lt;p&gt;next will go 'over' the function call to the next line of code, while step will go 'into' the function call.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="print"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id37"&gt;print&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
(gdb) p price[ii]
$7 = 1.1000000000000001
(gdb) p (bst[jj] / price[kk] * 0.97)
$8 = 92380.952380952382
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="x"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id38"&gt;x&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;examine memory in any of several formats&lt;/p&gt;
&lt;pre class="literal-block"&gt;
x/nfu addr
x addr
x
Use the x command to examine memory.
n, f, and u are all optional parameters that specify how much memory to display and how to format it; addr is an expression giving the address where you want to start displaying memory. If you use defaults for nfu, you need not type the slash `/'. Several commands set convenient defaults for addr.

n, the repeat count
The repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display.
f, the display format
The display format is one of the formats used by print, `s' (null-terminated string), or `i' (machine instruction). The default is `x' (hexadecimal) initially. The default changes each time you use either x or print.
u, the unit size
The unit size is any of
b
Bytes.
h
Halfwords (two bytes).
w
Words (four bytes). This is the initial default.
g
Giant words (eight bytes).
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="set"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id39"&gt;set&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
set x = 3
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="call"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id40"&gt;call&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
call abort()
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="watch-rwatch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id41"&gt;watch &amp;amp; rwatch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;write_watch &amp;amp; read_watch&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nexti-and-stepi"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id42"&gt;nexti and stepi&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;step through my code at the instruction level&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="disassemble"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id43"&gt;disassemble&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;see the assembly code my program is running:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) disassemble main
Dump of assembler code for function main:
0x80483c0 &amp;lt;main&amp;gt;: push %ebp
0x80483c1 &amp;lt;main+1&amp;gt;: mov %esp,%ebp
0x80483c3 &amp;lt;main+3&amp;gt;: sub $0x18,%esp
0x80483c6 &amp;lt;main+6&amp;gt;: movl $0x0,0xfffffffc(%ebp)
0x80483cd &amp;lt;main+13&amp;gt;: mov 0xfffffffc(%ebp),%eax
0x80483d0 &amp;lt;main+16&amp;gt;: movb $0x7,(%eax)
0x80483d3 &amp;lt;main+19&amp;gt;: xor %eax,%eax
0x80483d5 &amp;lt;main+21&amp;gt;: jmp 0x80483d7 &amp;lt;main+23&amp;gt;
0x80483d7 &amp;lt;main+23&amp;gt;: leave
0x80483d8 &amp;lt;main+24&amp;gt;: ret
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="trace-stack-control"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id44"&gt;trace stack control&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;f 0 : 到0对应的栈帧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gdb-tui"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id45"&gt;gdb TUI&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;偶然无意键入win命令，发现了TUI功能&lt;/p&gt;
&lt;p&gt;The GDB Text User Interface (TUI)&lt;/p&gt;
&lt;p&gt;gdb -tui&lt;/p&gt;
&lt;p&gt;问题：  当程序有printf到终端的时候，界面会乱掉.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cgdb"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id46"&gt;cgdb&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当遇到断点的时候cgdb就会停下来，
ESC进入到source模式，&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;j, k ，上下移动行&lt;/li&gt;
&lt;li&gt;space  添加断点。&lt;/li&gt;
&lt;li&gt;i 回到调试模式.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且可以记忆上次在cgdb session中写的命令.&lt;/p&gt;
&lt;p&gt;cgdb比emacs的gdb mode还是有相当的差距的，目前还算可以用，以后也会越来越好吧&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vimgdb"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id47"&gt;vimgdb ?&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="xxgdb-gui"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id48"&gt;xxgdb (gui)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;不好用&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ddd-gui"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id49"&gt;DDD (gui)&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="gdb-scripts"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id50"&gt;gdb scripts&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Using the GDB Scripts for Analyzing the Data&lt;/p&gt;
&lt;p&gt;Suppose that you have a singly-linked list that has strings in it. At some point, you might want to know the contents of the list. To do this, use the GDB scripting instead of adding the debug statements in your code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#Example for gslist traversal.
define p_gslist_str
set $list = ($arg0)
 while ((GSList *)$list-&amp;gt;next != 0)
p (char *)(GSList *)$list-&amp;gt;data
 set $list = (GSList *)$list-&amp;gt;next
 end
end
document p_gslist_str
p_gslist_str &amp;lt;list&amp;gt;: Dumps the strings in a GSList
end
&amp;lt;/code&amp;gt;
Add the above snippet into a file and load it into the GDB as follows:
&amp;lt;code&amp;gt;
(gdb) source /home/jjohnny/scripts/gdb/gslist.gdb
&amp;lt;/code&amp;gt;
Now, anywhere you want to take a look in the GSList, simply break and
&amp;lt;code&amp;gt;
(gdb) p_gslist_str server_uid_list
$17 = 0x7fffd81101b0 “7666BC1E000000015870BD1E00000001″
$18 = 0x7fffd810e330 “7666BC1E000000015970BD1E00000001″
$19 = 0x7fffd810cbe0 “7666BC1E000000015C70BD1E00000001″
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id51"&gt;高级使用&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="load"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id52"&gt;启动load一个脚本&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;比如调试redis, 每次进入gdb后, 需要 先设置breakpoint,  &lt;tt class="docutils literal"&gt;r xxx&lt;/tt&gt; 来启动, 此时可以把这些命令写入一个文件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat d.gdb
r -h 127.0.0.5 -p 22002 --replay /tmp/r/redis-22001/data/appendonly.aof

gdb ./redis-cli -x d.gdb
&lt;/pre&gt;
&lt;p&gt;或者通过在命令行中用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-ex&lt;/span&gt;&lt;/tt&gt; 指定命令&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gdb ./redis-cli -ex 'r -h 127.0.0.5 -p 22002 --replay /tmp/r/redis-22001/data/appendonly.aof'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id53"&gt;获得某个地址对应的代码::&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;比如mongodb 会自己打印breaktrace:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
532651f65c 0x7f53264fc016 0x7f5326527865 0x7f5326526293 0x7f5326527808 0x7f5326526293 0x7f5326527808 0x7f5326526293 0x7f5
326527808 0x7f5326526293 0x7f5326527261
 /home/ning/mongo/bin/mongod(_ZN5mongo15printStackTraceERSo+0x26) [0xc95896]
 /home/ning/mongo/bin/mongod(_ZN5mongo10abruptQuitEi+0x260) [0x6be1c0]
 /lib64/libc.so.6() [0x318ae32920]
 /lib64/libc.so.6(gsignal+0x35) [0x318ae328a5]
 /lib64/libc.so.6(abort+0x175) [0x318ae34085]
 /home/ning/mongo/bin/../lib64/libtokuportability.so(+0x4327) [0x7f53267da327]
 /home/ning/mongo/bin/../lib64/libtokuportability.so(+0x43a3) [0x7f53267da3a3]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0xc1299) [0x7f532656f299]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x712af) [0x7f532651f2af]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x7165c) [0x7f532651f65c]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x4e016) [0x7f53264fc016]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x79865) [0x7f5326527865]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x78293) [0x7f5326526293]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x79808) [0x7f5326527808]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x78293) [0x7f5326526293]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x79808) [0x7f5326527808]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x78293) [0x7f5326526293]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x79808) [0x7f5326527808]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x78293) [0x7f5326526293]
 /home/ning/mongo/bin/../lib64/libtokufractaltree.so(+0x79261) [0x7f5326527261]
&lt;/pre&gt;
&lt;p&gt;怎么获得这些地址对应的 函数呢?&lt;/p&gt;
&lt;p&gt;nm:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ nm ./src/third_party/ft-index/portability/libtokuportability.so | head
0000000000209148 d _DYNAMIC
00000000002093e0 d _GLOBAL_OFFSET_TABLE_
0000000000003e20 t _GLOBAL__I_65535_0_huge_page_detection.cc.o.3766.2377
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
0000000000004c00 T _Z10os_reallocPvm
0000000000004810 T _Z10toku_fstatiP4stat
0000000000004f10 T _Z11toku_callocmm
0000000000004cd0 T _Z11toku_mallocm
&lt;/pre&gt;
&lt;p&gt;更好的方法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gdb  lib64/libtokuportability.so --batch -ex 'info line *0x4327'

gdb  lib64/libtokufractaltree.so --batch -ex 'info line *0xc1299'
Line 198 of &amp;quot;/home/xiaobeibei/tokumxSrc/mongo/src/third_party/ft-index/ft/bndata.cc&amp;quot; starts at address 0xc1277 &amp;lt;_ZN7bn_data15get_memory_sizeEv+87&amp;gt; and ends at 0xc12a0 &amp;lt;_ZN7bn_data14verify_mempoolEv&amp;gt;.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id54"&gt;gcc&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="gcc-warn"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id55"&gt;gcc warn 选项&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-Werror
       Make all warnings into errors.

-Wall (打开大部分检查- 不是所有)
    This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.  This
    also enables some language-specific warnings described in C++ Dialect Options and Objective-C and Objective-C++ Dialect Options.

    -Wall turns on the following warning flags:

    -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration -Wcomment -Wformat -Wmain (only for C/ObjC and unless -ffreestanding)
    -Wmissing-braces -Wnonnull -Wparentheses -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1 -Wswitch -Wtrigraphs
    -Wuninitialized -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value -Wunused-variable -Wvolatile-register-var

-Wextra(这才是最猛的, 以前是叫&amp;quot;-W &amp;quot;)
    This enables some extra warning flags that are not enabled by -Wall.
    (This option used to be called -W.  The older name is still supported, but
    the newer name is more descriptive.)
&lt;/pre&gt;
&lt;p&gt;-W is now deprecated by -Wextra with new gcc versions.&lt;/p&gt;
&lt;p&gt;对部分文件关闭warning:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
When using GCC you can use the -isystem flag instead of the -I flag to disable warnings from that location.

So if you’re currently using

gcc -Iparent/path/of/bar …
use

gcc -isystem parent/path/of/bar …
instead. Unfortunately, this isn’t a particularly fine-grained control. I’m not aware of a more targeted mechanism.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id56"&gt;gcc编译生成汇编：&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;gcc -S inline.c -o inline_O0.s&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="i-l-l"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id57"&gt;-I, -L -l&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;-include和-I参数(x.h &amp;amp; path_to_x.h)&lt;/p&gt;
&lt;p&gt;-include用来包含头文件，但一般情况下包含头文件都在源码里用#include xxxxxx实现，-include参数很少用。-I参数是用来指定头文件目录，/usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/include里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I /myinclude参数了，如果不加你会得到一个&amp;quot;xxxx.h: No such file or directory&amp;quot;的错误。-I参数可以用相对路径，比如头文件在当前目录，可以用-I.来指定。上面我们提到的--cflags参数就是用来生成-I 参数的&lt;/p&gt;
&lt;p&gt;-l参数和-L参数(libx.a &amp;amp; path_to_libx.a )&lt;/p&gt;
&lt;blockquote&gt;
-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那么库名跟真正的库文件名有什么关系呢？就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的头lib和尾.so去掉就是库名了
好了现在我们知道怎么得到库名，当我们自已要用到一个第三方提供的库名字libtest.so，那么我们只要把libtest.so拷贝到/usr /lib里，编译时加上-ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与 libtest.so配套的头文件）
放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目 录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”，也就是链接程序ld在那3个目录里找不到libxxx.so，这时另外一个参数-L就派上用场了，比如常用的X11的库，它在/usr /X11R6/lib目录下，我们编译时就要用-L/usr/X11R6/lib -lX11参数，-L参数跟着的是库文件所在的目录名。再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L /aaa/bbb/ccc -ltest&lt;/blockquote&gt;
&lt;div class="section" id="id8"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id58"&gt;静态链接指定的库&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;比如说我要把mongo-c-driver 的静态.a 静态编译到nginx 里面去.&lt;/p&gt;
&lt;p&gt;You could also use ld option -Bdynamic:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc &amp;lt;objectfiles&amp;gt; -static -lstatic1 -lstatic2 -Wl,-Bdynamic -ldynamic1 -ldynamic2
&lt;/pre&gt;
&lt;p&gt;All libraries after it (including system ones linked by gcc automatically) will be linked dynamically.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="gcc-object"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id59"&gt;gcc 产生 object文件（只编译）&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;gcc -Wall -c main.c&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="shared-libraries"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id60"&gt;关于shared-libraries&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.dwheeler.com/program-library"&gt;http://www.dwheeler.com/program-library&lt;/a&gt;
&lt;a class="reference external" href="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html"&gt;http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html&lt;/a&gt;
&lt;a class="reference external" href="http://tldp.org/HOWTO/Program-Library-HOWTO/"&gt;http://tldp.org/HOWTO/Program-Library-HOWTO/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三种：
static libraries
shared libraries
dynamically loaded (DL) libraries.&lt;/p&gt;
&lt;blockquote&gt;
DL libraries aren't really a different kind of library format (both static and shared libraries can be used as DL libraries); instead, the difference is in how DL libraries are used by programmers.&lt;/blockquote&gt;
&lt;p&gt;DLL的多个意思：some people use the term dynamically linked libraries (DLLs) to refer to shared libraries, some use the term DLL to mean any library that is used as a DL library, and some use the term DLL to mean a library meeting either condition.&lt;/p&gt;
&lt;p&gt;If you're building an application that should port to many systems(Solaris等?), you might consider using GNU libtool to build and install libraries instead of using the Linux tools directly.&lt;/p&gt;
&lt;p&gt;This HOWTO's master location is &lt;a class="reference external" href="http://www.dwheeler.com/program-library"&gt;http://www.dwheeler.com/program-library&lt;/a&gt;, and it has been contributed to the Linux Documentation Project (&lt;a class="reference external" href="http://www.linuxdoc.org"&gt;http://www.linuxdoc.org&lt;/a&gt;)&lt;/p&gt;
&lt;div class="section" id="static-library"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id61"&gt;Static Library&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;过去用于节省重新编译的时间，但是现在编译器越来越快，这个已经不是主要原因
现在可以用来发布.h和.a，隐藏源代码
比动态库快：&lt;/p&gt;
&lt;p&gt;In theory, code in static ELF libraries that is linked into an executable should run slightly faster (by 1-5%) than a shared library or a dynamically loaded library, but in practice this rarely seems to be the case due to other confounding factors.&lt;/p&gt;
&lt;p&gt;创建：&lt;/p&gt;
&lt;p&gt;ar rcs my_library.a file1.o file2.o&lt;/p&gt;
&lt;p&gt;注意用gcc链接静态库的时候, -l要放在xxx.c后面. (AFTER the name of the file to be compiled.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id62"&gt;Shared Libraries&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;名字问题：&lt;/p&gt;
&lt;p&gt;linker name: &lt;tt class="docutils literal"&gt;/usr/lib/libreadline.so&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;soname: &lt;tt class="docutils literal"&gt;/usr/lib/libreadline.so.3&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;realname : &lt;tt class="docutils literal"&gt;/usr/lib/libreadline.so.3.0&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;the filename containing the actual library code
the linker name is simply created as a symbolic link to the &lt;tt class="docutils literal"&gt;latest&lt;/tt&gt; soname or the latest real name.&lt;/p&gt;
&lt;p&gt;You also need to understand where they should be placed in the filesystem.&lt;/p&gt;
&lt;p&gt;The GNU standards recommend installing by default all libraries in /usr/local/lib when distributing source code (and all commands should go into /usr/local/bin).
The Filesystem Hierarchy Standard (FHS) discusses what should go where in a distribution (see &lt;a class="reference external" href="http://www.pathname.com/fhs"&gt;http://www.pathname.com/fhs&lt;/a&gt;). According to the FHS, most libraries should be installed in /usr/lib, but libraries required for startup should be in /lib and libraries that are not part of the system should be in /usr/local/lib.&lt;/p&gt;
&lt;p&gt;当程序（ ELF binary）运行的时候，一个loader(/lib/ld-linux.so.X)自动加载其它所有library.&lt;/p&gt;
&lt;p&gt;ldconfig, ld.so.conf, ld.so.cache的关系：非常清楚!!! -Lin Yang 1/11/11 11:14 AM
扫描路径：The list of directories to be searched is stored in the file /etc/ld.so.conf
Searching all of these directories at program start-up would be grossly inefficient, so a caching arrangement is actually used. The program ldconfig(8) by default reads in the file /etc/ld.so.conf, sets up the appropriate symbolic links in the dynamic link directories,  and then writes a cache to /etc/ld.so.cache  The implication is that ldconfig must be run whenever a DLL is added, when a DLL is removed, or when the set of DLL directories changes; 之后. On start-up, then, the dynamic loader actually uses the file /etc/ld.so.cache and then loads the libraries it needs.
ldconfig是关键，ldconfig读取 /ect/ld.so.conf&lt;/p&gt;
&lt;p&gt;环境变量，覆盖上面/ect/ld.so.conf中的内容&lt;/p&gt;
&lt;p&gt;LD_LIBRARY_PATH&lt;/p&gt;
&lt;p&gt;a colon-separated set of directories where libraries should be searched for first,
最好只用于debug, LD_LIBRARY_PATH is handy for development and testing, but shouldn't be modified by an installation process for normal use by normal users;&lt;/p&gt;
&lt;p&gt;LD_PRELOAD&lt;/p&gt;
&lt;p&gt;The environment variable LD_PRELOAD lists shared libraries with functions that override the standard set, just as /etc/ld.so.preload does&lt;/p&gt;
&lt;p&gt;/lib/ld-linux.so.2 本身是个可执行的，可以这样用：&lt;/p&gt;
&lt;p&gt;/lib/ld-linux.so.2 --library-path PATH EXECUTABLE
/lib/ld-linux.so.2 test/protocol_test.out&lt;/p&gt;
&lt;p&gt;LD_DEBUG 用于调试：&lt;/p&gt;
&lt;p&gt;export LD_DEBUG=files
command_to_run&lt;/p&gt;
&lt;p&gt;LD_xxxx&lt;/p&gt;
&lt;p&gt;Most of them aren't well-documented; if you need to know about them, the best way to learn about them is to read the source code of the loader (part of gcc).&lt;/p&gt;
&lt;p&gt;Creating a Shared Library&lt;/p&gt;
&lt;p&gt;The -fPIC and -fpic options enable &lt;tt class="docutils literal"&gt;position independent code&lt;/tt&gt; generation， The -fPIC choice always works, but may produce larger code than -fpic&lt;/p&gt;
&lt;p&gt;The -Wl option passes options along to the linker (in this case the -soname linker option) - the commas after -Wl are not a typo&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;Here's an example, which creates two object files (a.o and b.o) and then creates a shared library that contains both of them. Note that this compilation includes debugging information (-g) and will generate warnings (-Wall), which aren't required for shared libraries but are recommended. The compilation generates object files (using -c), and includes the required -fPIC option:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -fPIC -g -c -Wall a.c
gcc -fPIC -g -c -Wall b.c
gcc -shared -Wl,-soname,libmystuff.so.1 \
-o libmystuff.so.1.0.1 a.o b.o -lc
&lt;/pre&gt;
&lt;p&gt;安装 Shared Library&lt;/p&gt;
&lt;p&gt;Once you've created a shared library, you'll want to install it. The simple approach is simply to copy the library into one of the standard directories (e.g., /usr/lib) and run ldconfig(8).
可以通过 ldconfig -n directory_with_shared_libraries 实现.
Usually you can update libraries without concern; if there was an API change, the library creator is supposed to change the soname.比如libevent, libevent2 -Lin Yang 1/11/11 11:51 AM  That way, multiple libraries can be on a single system, and the right one is selected for each program.&lt;/p&gt;
&lt;p&gt;make sure that your libraries are either backwards-compatible or that you've incremented the version number in the soname every time you make an incompatible change.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id63"&gt;其它&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="nm"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id64"&gt;nm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The nm(1) command can report the list of symbols in a given library:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;pcning:~/idning-paper/src$ nm test/protocol_test.out
08049f18 d _DYNAMIC
08049ff4 d _GLOBAL_OFFSET_TABLE_
08048dbc R _IO_stdin_used
         w _Jv_RegisterClasses
08049f08 d __CTOR_END__
08049f04 d __CTOR_LIST__
08049f10 D __DTOR_END__
08049f0c d __DTOR_LIST__
08048ef4 r __FRAME_END__
08049f14 d __JCR_END__
08049f14 d __JCR_LIST__
08048ede r __PRETTY_FUNCTION__.4058
         U __assert_fail&amp;#64;&amp;#64;GLIBC_2.0
0804a024 A __bss_start
0804a01c D __data_start
08048d70 t __do_global_ctors_aux
08048550 t __do_global_dtors_aux
0804a020 D __dso_handle
         w __gmon_start__
&lt;/pre&gt;
&lt;p&gt;nm输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
lowercase means that the symbol is local
uppercase means that the symbol is global
T (a normal definition in the code section),
D (initialized data section),
B (uninitialized data section),
U (undefined; the symbol is used by the library but not defined by the library),
W (weak; if another library also defines this symbol, that definition overrides this one).
&lt;/pre&gt;
&lt;p&gt;If you know the name of a function, but you truly can't remember what library it was defined in, you can use nm's &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-o&lt;/span&gt;&lt;/tt&gt; option (which prefixes the filename in each line) along with grep to find the library name. From a Bourne shell, you can search all the libraries in /lib, /usr/lib, direct subdirectories of /usr/lib, and /usr/local/lib for &lt;tt class="docutils literal"&gt;cos&lt;/tt&gt; as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nm -o /lib/* /usr/lib/* /usr/lib/*/* \
/usr/local/lib/* 2&amp;gt; /dev/null | grep 'cos$'
&lt;/pre&gt;
&lt;p&gt;Shared Libraries Can Be Scripts&lt;/p&gt;
&lt;p&gt;/usr/lib/libc.so on one of my systems:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* GNU ld script
Use the shared library, but some functions are only in
the static library, so try that secondarily. */
GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a )
&lt;/pre&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;使用和创建shared library的时候都只需要soname.&lt;/dt&gt;
&lt;dd&gt;When you install a new version of a library, you install it in one of a few special directories and then run the program ldconfig(8). ldconfig examines the existing files and creates the sonames as symbolic links to the real names, as well as setting up the cache file /etc/ld.so.cache (described in a moment).&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;自己的一个shared-library的例子&lt;/p&gt;
&lt;p&gt;原来只有libevent1.4, 安装了libevent2后
比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -o test/protocol_test.gen.o -c -D_DEBUG -Wall -Icommon -I/usr/local/include test/protocol_test.gen.c
gcc -o test/protocol_test.gen.out test/protocol_test.gen.o -Lcommon -L/usr/local/lib -lcommon -levent
&lt;/pre&gt;
&lt;p&gt;但是运行时发现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;pcning:~/idning-paper/src$ ./test/protocol_test.gen.out
./test/protocol_test.gen.out: error while loading shared libraries: libevent-2.0.so.5: cannot open shared object file: No such file or directory
&lt;/pre&gt;
&lt;p&gt;用ldd （list dynamic dependencies）查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;pcning:~/idning-paper/src$ ldd ./test/protocol_test.gen.out
        linux-gate.so.1 =&amp;gt;  (0x00fb4000)
        libevent-2.0.so.5 =&amp;gt; not found
        libc.so.6 =&amp;gt; /lib/tls/i686/cmov/libc.so.6 (0x00af5000)
        /lib/ld-linux.so.2 (0x00589000)
&lt;/pre&gt;
&lt;p&gt;这时候有两个办法：
运行前:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ export LD_LIBRARY_PATH=/usr/local/lib
$ ldd ./test/protocol_test.gen.out
        linux-gate.so.1 =&amp;gt;  (0x00a35000)
        libevent-2.0.so.5 =&amp;gt; /usr/local/lib/libevent-2.0.so.5 (0x00abd000)
        libc.so.6 =&amp;gt; /lib/tls/i686/cmov/libc.so.6 (0x00110000)
        librt.so.1 =&amp;gt; /lib/tls/i686/cmov/librt.so.1 (0x00a01000)
        /lib/ld-linux.so.2 (0x008a5000)
        libpthread.so.0 =&amp;gt; /lib/tls/i686/cmov/libpthread.so.0 (0x00bf1000)
&lt;/pre&gt;
&lt;p&gt;编译前:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ export LD_RUN_PATH=/usr/local/lib
&lt;/pre&gt;
&lt;p&gt;没用..这可能是 solarios上的选项 &lt;em&gt;-Lin Yang 1/11/11 10:17 AM&lt;/em&gt;&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;ldconfig －这个好使 &lt;em&gt;-Lin Yang 1/11/11 11:19 AM&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;又例如&lt;/p&gt;
&lt;p&gt;在安装libevent2的时候，使用 &lt;tt class="docutils literal"&gt;./configure&lt;/tt&gt; 将会安装到/usr/local/下&lt;/p&gt;
&lt;p&gt;运行程序的时候出现错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root&amp;#64;localhost src]# ./mds/mds.out
./mds/mds.out: error while loading shared libraries: libevent-2.0.so.5: cannot open shared object file: No such file or directory
&lt;/pre&gt;
&lt;p&gt;这时候需要:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vi /etc/ld.so.conf.d/libevent2.conf
/usr/local/lib
# libevent-2.0.so.5 在这个目录下

ldconfig
&lt;/pre&gt;
&lt;p&gt;然后就好了&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~gilpin/tutorial/"&gt;http://www.cs.cmu.edu/~gilpin/tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html"&gt;http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="gcov"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id65"&gt;gcov&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;gcov is a test coverage program
how often each line of code executes
what lines of code are actually executed
how much computing time each section of code uses&lt;/p&gt;
&lt;p&gt;When using gcov, you must first compile your program with two special GCC options: &lt;cite&gt;-fprofile-arcs -ftest-coverage&lt;/cite&gt;.&lt;/p&gt;
&lt;p&gt;For each source file compiled with -fprofile-arcs, an accompanying .gcda file will be placed in the object file directory.
usage:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ gcc -fprofile-arcs -ftest-coverage tmp.c
$ ./a.out
$ gcov tmp.c
90.00% of 10 source lines executed in file tmp.c
Creating tmp.c.gcov.
The file tmp.c.gcov contains output from gcov. Here is a sample:
-: 0:Source:tmp.c
-: 0:Graph:tmp.gcno
-: 0:Data:tmp.gcda
-: 0:Runs:1
-: 0:Programs:1
-: 1:#include &amp;lt;stdio.h&amp;gt;
-: 2:
-: 3:int main (void)
1: 4:{
1: 5: int i, total;
-: 6:
1: 7: total = 0;
-: 8:
11: 9: for (i = 0; i &amp;lt; 10; i++)
10: 10: total += i;
-: 11:
1: 12: if (total != 45)
#####: 13: printf (&amp;quot;Failure\n&amp;quot;);
-: 14: else
1: 15: printf (&amp;quot;Success\n&amp;quot;);
1: 16: return 0;
-: 17:}
&lt;/pre&gt;
&lt;p&gt;编译时: -fprofile-arcs -ftest-coverage
链接时: -l gcov&lt;/p&gt;
&lt;p&gt;The .gcno file is generated when the source file is compiled with the GCC -ftest-coverage option. It contains information to reconstruct the basic block graphs and assign source line numbers to blocks.
The .gcda file is generated when a program containing object files built with the GCC -fprofile-arcs option is executed. A separate.gcda file is created for each object file compiled with this option. It contains arc transition counts, and some summary information.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id66"&gt;内存泄漏&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="tcmalloc-heap-profiler"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id67"&gt;tcmalloc heap_profiler.&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="valgrind"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id68"&gt;Valgrind&lt;/a&gt;&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
valgrind --tool=memcheck --leak-check=full -v --log-file=lighttpd --num-callers=8 ./bin/lighttpd -D -f ./conf/lighttpd.conf
&lt;/pre&gt;
&lt;p&gt;A leak error Message involving an unloaded shared object:
84 bytes in 1 blocks are possibly lost in loss record 488 of 713 at 0x1B9036DA: operator new(unsigned) (vg_replace_malloc.c:132) by 0x1DB63EEB: ??? by 0x1DB4B800: ??? by 0x1D65E007: ??? by 0x8049EE6: main (main.cpp:24)&lt;/p&gt;
&lt;p&gt;-g&lt;/p&gt;
&lt;p&gt;Valgrind是一个GPL的软件，用于Linux（For x86, amd64 and ppc32）程序的内存调试和代码剖析。你可以在它的环境中运行你的程序来监视内存的使用情况，比如C 语言中的malloc和free或者 C++中的new和 delete。使用Valgrind的工具包，你可以自动的检测许多内存管理和线程的bug，避免花费太多的时间在bug寻找上，使得你的程序更加稳固。
Valgrind的主要功能
Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif。下面分别介绍个工具的作用：
Memcheck 工具主要检查下面的程序错误：
•        使用未初始化的内存 (Use of uninitialised memory)
•        使用已经释放了的内存 (Reading/writing memory after it has been free’d)
•        使用超过 malloc分配的内存空间(Reading/writing off the end of malloc’d blocks)
•        对堆栈的非法访问 (Reading/writing inappropriate areas on the stack)
•        申请的空间是否有释放 (Memory leaks – where pointers to malloc’d blocks are lost forever)
•        malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete [])
•        src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)
Callgrind
Callgrind收集程序运行时的一些数据，函数调用关系等信息，还可以有选择地进行cache 模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。
Cachegrind
它模拟 CPU中的一级缓存I1,D1和L2二级缓存，能够精确地指出程序中 cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。
Helgrind
它主要用来检查多线程程序中出现的竞争问题。Helgrind 寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为” Eraser” 的竞争检测算法，并做了进一步改进，减少了报告错误的次数。
Massif
堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。&lt;/p&gt;
&lt;p&gt;Valgrind 使用
用法: valgrind [options] prog-and-args [options]: 常用选项，适用于所有Valgrind工具
1.        -tool=&amp;lt;name&amp;gt; 最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。
2.        h –help 显示帮助信息。
3.        -version 显示valgrind内核的版本，每个工具都有各自的版本。
4.        q –quiet 安静地运行，只打印错误信息。
5.        v –verbose 更详细的信息, 增加错误数统计。
6.        -trace-children=no|yes 跟踪子线程? [no]
7.        -track-fds=no|yes 跟踪打开的文件描述？[no]
8.        -time-stamp=no|yes 增加时间戳到LOG信息? [no]
9.        -log-fd=&amp;lt;number&amp;gt; 输出LOG到描述符文件 [2=stderr]
10.        -log-file=&amp;lt;file&amp;gt; 将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID
11.        -log-file-exactly=&amp;lt;file&amp;gt; 输出LOG信息到 file
12.        -log-file-qualifier=&amp;lt;VAR&amp;gt; 取得环境变量的值来做为输出信息的文件名。 [none]
13.        -log-socket=ipaddr:port 输出LOG到socket ，ipaddr:port
LOG信息输出
1.        -xml=yes 将信息以xml格式输出，只有memcheck可用
2.        -num-callers=&amp;lt;number&amp;gt; show &amp;lt;number&amp;gt; callers in stack traces [12]
3.        -error-limit=no|yes 如果太多错误，则停止显示新错误? [yes]
4.        -error-exitcode=&amp;lt;number&amp;gt; 如果发现错误则返回错误代码 [0=disable]
5.        -db-attach=no|yes 当出现错误，valgrind会自动启动调试器gdb。[no]
6.        -db-command=&amp;lt;command&amp;gt; 启动调试器的命令行选项[gdb -nw %f %p]
适用于Memcheck工具的相关选项：
1.        -leak-check=no|summary|full 要求对leak给出详细信息? [summary]
2.        -leak-resolution=low|med|high how much bt merging in leak check [low]
3.        -show-reachable=no|yes show reachable blocks in leak check? [no]&lt;/p&gt;
&lt;div class="section" id="id12"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id69"&gt;Valgrind 使用举例&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;下面是一段有问题的C程序代码test.c:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;stdlib.h&amp;gt;
void f(void)
{
   int* x = malloc(10 * sizeof(int));
   x[10] = 0;  //问题1: 数组下标越界
}           //问题2: 内存没有释放

int main(void)
{
   f();
   return 0;
}
&lt;/pre&gt;
&lt;p&gt;1、 编译程序test.c
gcc -Wall test.c -g -o test
2、 使用Valgrind检查程序BUG
valgrind --tool=memcheck --leak-check=full ./test
3、 分析输出的调试信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
==3908== Memcheck, a memory error detector.
==3908== Copyright (C) 2002-2007, and GNU GPL'd, by Julian Seward et al.
==3908== Using LibVEX rev 1732, a library for dynamic binary translation.
==3908== Copyright (C) 2004-2007, and GNU GPL'd, by OpenWorks LLP.
==3908== Using valgrind-3.2.3, a dynamic binary instrumentation framework.
==3908== Copyright (C) 2000-2007, and GNU GPL'd, by Julian Seward et al.
==3908== For more details, rerun with: -v
==3908==
--3908-- DWARF2 CFI reader: unhandled CFI instruction 0:50
--3908-- DWARF2 CFI reader: unhandled CFI instruction 0:50
/*数组越界错误*/
==3908== Invalid write of size 4
==3908==    at 0x8048384: f (test.c:6)
==3908==    by 0x80483AC: main (test.c:11)
==3908==  Address 0x400C050 is 0 bytes after a block of size 40 alloc'd
==3908==    at 0x40046F2: malloc (vg_replace_malloc.c:149)
==3908==    by 0x8048377: f (test.c:5)
==3908==    by 0x80483AC: main (test.c:11)
==3908==
==3908== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 14 from 1)
==3908== malloc/free: in use at exit: 40 bytes in 1 blocks.
==3908== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.
==3908== For counts of detected errors, rerun with: -v
==3908== searching for pointers to 1 not-freed blocks.
==3908== checked 59,124 bytes.
==3908==
==3908==
/*有内存空间没有释放*/
==3908== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==3908==    at 0x40046F2: malloc (vg_replace_malloc.c:149)
==3908==    by 0x8048377: f (test.c:5)
==3908==    by 0x80483AC: main (test.c:11)
==3908==
==3908== LEAK SUMMARY:
==3908==    definitely lost: 40 bytes in 1 blocks.
==3908==    possibly lost: 0 bytes in 0 blocks.
==3908==    still reachable: 0 bytes in 0 blocks.
==3908==       suppressed: 0 bytes in 0 blocks.
&lt;/pre&gt;
&lt;p&gt;valgrind有使用方便，容易操作的特点，能够快速的查询出程序的代码占用内存情况，能够有效的找出内存的泄漏的原因，而且是开源。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="profiling"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id70"&gt;profiling&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="gprof"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id71"&gt;gprof&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.cs.utah.edu/dept/old/texinfo/as/gprof.h"&gt;http://www.cs.utah.edu/dept/old/texinfo/as/gprof.h&lt;/a&gt; tml#SEC3&lt;/p&gt;
&lt;div class="section" id="id13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id72"&gt;gprof基本用法&lt;/a&gt;&lt;/h4&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-pg&lt;/span&gt;&lt;/tt&gt; 选项编译和链接.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;执行你的应用程序，使之运行完成后生成供gprof分析的数据文件（默认是gmon.out）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用gprof程序分析你的应用程序生成的数据，例如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gprof a.out gmon.out
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id73"&gt;gprof 实现原理&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;gprof并不神奇，在编译和链接程序的时 候（使用 -pg 编译和链接选项），gcc 在你应用程序的每个函数中都加入了一个名为mcount（or“_mcount”, or“__mcount”）的函数，也就是说-pg编译的应用程序里的每一个函数都会调用mcount, 而mcount会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址。这张调用图也保存了所有与函数相关的调用时间，调用次 数等等的所有信息。
1. 在内存中分配一些内存，存储程序执行期间的统计数据
2. 在GCC使用-pg选项编译后，gcc会在程序的入口处(main 函数之前)调用
void monstartup(lowpc, highpc)
在每个函数的入口处调用
void _mcount()
在程序退出时(在 atexit () 里)调用
void _mcleanup()
monstartup：负责初始化profile环境，分配内存空间 _mcount: 记录每个函数代码的caller和callee的位置 _mcleanup：清除profile环境，保存结果数据为gmon.out，供gprof分析结果 3．在_mcount函数中跟踪程序的执行状况，记录程序代码的执行次数，时间等数据。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id74"&gt;使用注意：&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;1） 一般gprof只能查看用户函数信息。如果想查看库函数的信息，需要在编译是再加入“-lc_p”编译参数代替“-lc”编译参数，这样程序会链接libc_p.a库，才可以产生库函数的profiling信息。
2） gprof只能在程序 &lt;strong&gt;正常结束&lt;/strong&gt; 退出之后才 能生成程序测评报告，原因是gprof通过在atexit()里注册了一个函数来产生结果信息，任何非正常退出都不会执行atexit()的动作，所以不 会产生gmon.out文件。如果你的程序是一个不会退出的服务程序，那就只有修改代码来达到目的。如果不想改变程序的运行方式，可以添加一个信号处理函 数解决问题（这样对代码修改最少），例如：
static void sighandler( int sig_no ) { exit(0); } signal( SIGUSR1, sighandler );&lt;/p&gt;
&lt;p&gt;当使用 &lt;tt class="docutils literal"&gt;kill &lt;span class="pre"&gt;-USR1&lt;/span&gt; pid&lt;/tt&gt; 后，程序退出，生成gmon.out文件。&lt;/p&gt;
&lt;p&gt;编译：
cc的时候加 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-pg&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;ld的时候加：&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;/lib/gcrt0.o&lt;/tt&gt;  (或者/usr/lib/gcrt1.o)  现在不需要了. -Lin Yang 6/24/11 11:27 AM&lt;/p&gt;
&lt;p&gt;然后运行并且 &lt;strong&gt;正常终止&lt;/strong&gt; 程序&lt;/p&gt;
&lt;p&gt;发现生成gmon.out&lt;/p&gt;
&lt;p&gt;再:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gprof -z  dist/sbin/mfsmaster dist/localstatedir/mfs/gmon.out

不过我得到的报告都是0：
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
  0.00      0.00     0.00        3     0.00     0.00  mylock
  0.00      0.00     0.00        1     0.00     0.00  changeugid
  0.00      0.00     0.00        1     0.00     0.00  check_old_locks
  0.00      0.00     0.00        1     0.00     0.00  remove_old_wdlock
  0.00      0.00     0.00        1     0.00     0.00  wdlock
  0.00      0.00     0.00                             __do_global_ctors_aux
  0.00      0.00     0.00                             __do_global_dtors_aux
  0.00      0.00     0.00                             __gmon_start__
  0.00      0.00     0.00                             __libc_csu_fini
&lt;/pre&gt;
&lt;p&gt;可以用kprof打开  dist/sbin/mfsmaster察看（gmon.out要在exe文件的同一目录下.）
我自己用的时候:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
mv gmon.out client/
kprof
file / open . client/mount.out
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id75"&gt;问题&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;感觉不太靠谱:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ cc bench1.c libhiredis.a -pg
ning&amp;#64;ning-laptop:~/idning-github/redis/deps/hiredis$ ./a.out
$ gprof  ./a.out ./gmon.out  | vim -

Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
 22.23      0.04     0.04                             redisReaderGetReply
 16.67      0.07     0.03                             redisvFormatCommand
 11.12      0.09     0.02                             redisGetReply
 11.12      0.11     0.02                             sdscatlen
  5.56      0.12     0.01                             main
  5.56      0.13     0.01                             redisBufferRead
  5.56      0.14     0.01                             redisBufferWrite
  5.56      0.15     0.01                             sdsIncrLen
  5.56      0.16     0.01                             sdsempty
  5.56      0.17     0.01                             sdsnewlen
  2.78      0.18     0.01                             sdsMakeRoomFor
  2.78      0.18     0.01                             sdsRemoveFreeSpace
&lt;/pre&gt;
&lt;p&gt;总共7s, 为啥self seconds 加起来不是7s&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="google-cpu-profile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id76"&gt;google-cpu-profile&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;goolge profile 工具&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://goog-perftools.sourceforge.net/doc/cpu_profiler.html"&gt;http://goog-perftools.sourceforge.net/doc/cpu_profiler.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is the CPU profiler we use at Google. There are three parts to using it: linking the library into an application, running the code, and analyzing the output.&lt;/p&gt;
&lt;p&gt;生成调用关系图和时间占用.&lt;/p&gt;
&lt;img alt="" src="/imgs/pprof-test.gif" /&gt;
&lt;div class="section" id="id17"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id77"&gt;安装&lt;/a&gt;&lt;/h4&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;安装libunwind: &lt;a class="reference external" href="http://download.savannah.gnu.org/releases/libunwind/libunwind-1.1.tar.gz"&gt;http://download.savannah.gnu.org/releases/libunwind/libunwind-1.1.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;./configure --enable-frame-pointers --prefix=/home/ning/local/&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id18"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id78"&gt;使用&lt;/a&gt;&lt;/h4&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;链接时加上 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lprofiler&lt;/span&gt;&lt;/tt&gt;,
或者用 &lt;tt class="docutils literal"&gt;LD_PRELOAD&lt;/tt&gt; (不推荐)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
env LD_PRELOAD=&amp;quot;/usr/lib/libprofiler.so&amp;quot; &amp;lt;binary&amp;gt;
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#In your code, bracket the code you want profiled in calls to ProfilerStart() and ProfilerStop()   (google/profiler.h)
程序需要正常结束.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;analysis:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pprof is the script used to analyze a profile.
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux 2.6 and above, profiling works correctly with threads, automatically profiling all threads&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tcmalloc"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id79"&gt;和tcmalloc 是同一个工具集&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;TC Malloc:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc [...] -ltcmalloc
&lt;/pre&gt;
&lt;p&gt;Heap Checker:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc [...] -o myprogram -ltcmalloc
HEAPCHECK=normal ./myprogram
&lt;/pre&gt;
&lt;p&gt;Heap Profiler:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc [...] -o myprogram -ltcmalloc
HEAPPROFILE=/tmp/netheap ./myprogram
&lt;/pre&gt;
&lt;p&gt;Cpu Profiler:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc [...] -o myprogram -lprofiler
CPUPROFILE=/tmp/profile ./myprogram
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id19"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id80"&gt;例子&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;LD_PRELOAD试用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#1. 启动
PROFILEFREQUENCY=1000 CPUPROFILE=/tmp/profile LD_PRELOAD=/home/ning/local/lib/libprofiler.so bin/nutcracker -c /home/ning/tmp/r/nutcracker-4000/conf/nutcracker.conf -o /home/ning/tmp/r/nutcracker-4000/log/nutcracker.log -p /home/ning/tmp/r/nutcracker-4000/log/nutcracker.pid -s 5000 -v 4
#起压力
./redis-benchmark.1000 -n 1000 -p 4000 -t mget  -r 1000000000 -c 2

#2.  ^C结束后:
^CPROFILE: interrupts/evictions/bytes = 610/103/4120
$ pprof --text bin/nutcracker /tmp/profile

9470  71.5%  71.5%     9470  71.5% req_error
1040   7.8%  79.3%     1040   7.8% memcpy
 465   3.5%  82.8%      465   3.5% writev
 241   1.8%  84.7%      241   1.8% _msg_get
 171   1.3%  85.9%      171   1.3% msg_send_chain
 142   1.1%  87.0%      142   1.1% mbuf_get
 107   0.8%  87.8%      107   0.8% rbtree_insert
 107   0.8%  88.6%      107   0.8% redis_parse_req
  94   0.7%  89.3%       94   0.7% array_get
  86   0.6%  90.0%       86   0.6% mbuf_remove
  81   0.6%  90.6%       81   0.6% rsp_send_next
  80   0.6%  91.2%       80   0.6% req_done
&lt;/pre&gt;
&lt;p&gt;对性能影响很小.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="perf"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id81"&gt;perf&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;速度快. 2.6内核提供的. ubuntu, centos都默认安装, 不需要root&lt;/p&gt;
&lt;p&gt;perf list:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
List of pre-defined events (to be used in -e):

 cpu-cycles OR cycles                       [Hardware event]
 instructions                               [Hardware event]
 cache-references                           [Hardware event]
 cache-misses                               [Hardware event]    可以统计cache-miss噢.
 page-faults OR faults                      [Software event]
&lt;/pre&gt;
&lt;p&gt;有点像strace 对系统调用计数 .&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
perf stat -e cycles dd if=/dev/zero of=/dev/null count=100000
&lt;/pre&gt;
&lt;p&gt;attach:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
perf stat -e cycles -p 2262 sleep 2
&lt;/pre&gt;
&lt;div class="section" id="source-level-analysis-with-perf-annotate"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id82"&gt;Source level analysis with perf annotate&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div class="section" id="perf-top"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id83"&gt;perf top&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;系统级别top, 哪个函数正在占cpu. 很叼啊!!:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
perf top
Events: 4K cycles
 15.14%  libc-2.12.so            [.] memcpy
  6.16%  libc-2.12.so            [.] _wordcopy_fwd_dest_aligned
  4.79%  perf                    [.] 0x412d6
  2.57%  libc-2.12.so            [.] malloc
  2.53%  nutcracker              [.] msg_send_chain                                                 nutcracker
  2.10%  [kernel]                [k] intel_idle
  1.98%  [kernel]                [k] copy_user_generic_string
  1.95%  nutcracker              [.] mbuf_get                                                       nutcracker
  1.81%  nutcracker              [.] rbtree_insert                                                  nutcracker
  1.65%  libc-2.12.so            [.] _int_free
  1.55%  nutcracker              [.] redis_parse_req
  1.50%  nutcracker              [.] req_done
  1.46%  libc-2.12.so            [.] _int_malloc
  1.39%  [kernel]                [k] tcp_sendmsg
  1.23%  nutcracker              [.] rbtree_delete
&lt;/pre&gt;
&lt;p&gt;可以只采样一个 CPU:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
perf top -C &amp;lt;cpu-list&amp;gt;

 26.14%  libc-2.12.so        [.] memcpy
  7.69%  nutcracker          [.] mbuf_get
  7.11%  nutcracker          [.] _msg_get
  6.82%  nutcracker          [.] msg_send_chain
  4.40%  [kernel]            [k] copy_user_generic_string
  3.87%  nutcracker          [.] mbuf_remove
  3.79%  nutcracker          [.] req_done
  3.08%  nutcracker          [.] rbtree_delete
  3.02%  nutcracker          [.] rsp_recv_done
  2.54%  nutcracker          [.] rsp_send_next
  1.67%  nutcracker          [.] rbtree_insert
  1.57%  libc-2.12.so        [.] _IO_default_xsputn
  1.50%  nutcracker          [.] msg_get
  1.45%  nutcracker          [.] redis_parse_req
&lt;/pre&gt;
&lt;p&gt;不能只采样某个进程.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="callgrind"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id84"&gt;callgrind&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kcachegrind.sourceforge.net/html/Home.html"&gt;http://kcachegrind.sourceforge.net/html/Home.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is the homepage of the profiling tool Callgrind and the profile data visualization KCachegrind&lt;/p&gt;
&lt;img alt="" src="/imgs/callgrind-output-tile-2.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="oprofile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id85"&gt;oprofile&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;oprofile和Intel的VTune类似，都是利用CPU提供的性能计数功能对系统进行profiling. CPU提供一些性能计数器，经过配置可以对各种事件进行计数，当超过一定的threshold，会发出NMI中断，中断处理程序可以记录下当前的PC，current task等信息。用户可以对其dump进行分析。
采样往往会对系统性能带来一些影响(想想测不准原理)，oprofile带来的影响为1%-8%，还好。特别是考虑到它可能是唯一能提供你所需要的信息的工具。&lt;/p&gt;
&lt;p&gt;但不需要像gprof一样，必须优雅退出才可以剖分&lt;/p&gt;
&lt;ol class="arabic" start="3"&gt;
&lt;li&gt;&lt;p class="first"&gt;这就可以开始使用oprofile了，不过需要注意的是，需要有root权限才可以运行，请向&amp;gt;系统管理员索要sudo权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;对mysqld进行profile为例:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo opcontrol --reset
sudo opcontrol --separate=lib --no-vmlinux --start --image=/home/software/output/libexec/mysqld
在其他机器起压力,压力停止后再进行后续操作
sudo opcontrol --dump
sudo opcontrol --shutdown

opreport -l /home/software/output/libexec/mysqld
opannotate -s /home/software/output/libexec/mysqld
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="systemtap-root"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id86"&gt;systemtap(root)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;非常好用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vtune-root"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id87"&gt;vtune(root)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Intel® VTune™ Amplifier XE 2013 is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java*.&lt;/p&gt;
&lt;p&gt;Intel 提供. 只能用在Intel CPU上.&lt;/p&gt;
&lt;img alt="" src="/imgs/hotspots_xe_1.png" style="width: 463px; height: 307px;" /&gt;
&lt;p&gt;三种数据收集方式:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Sampling 采样, 打断处理器执行, (如每秒1000次)&lt;/li&gt;
&lt;li&gt;Call graph&lt;/li&gt;
&lt;li&gt;Counter Monitoring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在linux上安装Smpling Driver, 启动VTune Server, 在windows 安装客户端.&lt;/p&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="18%" /&gt;
&lt;col width="23%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="10%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;工具&lt;/th&gt;
&lt;th class="head"&gt;需要修改代码&lt;/th&gt;
&lt;th class="head"&gt;正常结束&lt;/th&gt;
&lt;th class="head"&gt;需要root&lt;/th&gt;
&lt;th class="head"&gt;影响性能&lt;/th&gt;
&lt;th class="head"&gt;推荐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;gprof&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;google-perf&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;callgrind&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;perf&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;td&gt;0.5&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;systemtap&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;oprofile&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;vtune&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;google-perf比gprof简单的一点是, 编译的时候不需要加 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-pg&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;google-perf的方法应该和 systemtap 类似, 采样.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐使用:
- google-perf
- systemtap&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="all"></category></entry></feed>